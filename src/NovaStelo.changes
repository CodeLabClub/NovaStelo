----QUIT----2019-12-09T19:53:41.770315+01:00 Pharo8.0-SNAPSHOT-32bit-6e95be0.image priorSource: 0!----QUIT----2019-12-09T19:54:05.261568+01:00 Pharo8.0-SNAPSHOT-32bit-6e95be0.image priorSource: 0!!ObjRefRecord commentStamp: 'jm 9/28/2003 11:18' prior: 0!Instances of me are used to temporarily record inter-object references when ObjStream is reading in an object structure. After all the objects have been read, a second pass is made to replace each object reference with a pointer directly to to the object in the object table.!!ObjStream commentStamp: 'jm 9/28/2003 15:39' prior: 0!I can serialize a collection of inter-connected objects onto a binary stream or reconstruct the original object network from its serialized form. This allows object structures to be saved in files, transmitted over a network, etc.I support user class evolution via class version numbers, making it possible to detect and, if so desired, convert old object formats.The format consists of a table of serialized objects. The first object in this table is the "root" object that was serialized; the rest of the objects in the table are objects reachable from this root object. Inter-object references are stored as indices into this table. These indices are mapped to actual object references when the structure is deserialized.Object storage formats fall into one of these categories:  a. immediate values: the constants nil, true, false, integers, and floats  b. fixed-format objects whose serialization is handled by this class  c. objects that handle their own serialization and whose formats may change over timeObjects in the first category are encoded in-line; they do not appear in the object table and thus cannot be shared. Integers that small enough to be represented in 16 bits have their own format. Objects in the second catetory are assumed to have stable storage formats, so they do not have a class version number. In the unlikely event that the storage format of any of these classes changes, the file format version must be incremented.Objects in the last category support user-defined serialization. They are expected to implement the three instance methods storeFieldsOnXX:, initializeFromFieldsXX:, and objStreamVersion, where XX is the class version number. In general, any change to the serialization format of an object requires adding new versions of the methods storeFieldsOnXX: and initializeFromFieldsXX:, then incrementing the version number returned by objStreamVersion.The class of every object in this category must appear in the class ID table. To ensure that old object files can be read, once an object has been assigned an ID that ID can't be changed and even if the class is deleted, it's ID must not used for another class.Maximums:  Object types (i.e., classes): 255  User-defined class fields: 255  Number of objects: 2^24 - 1  Indexable object size: 2^32 - 1!!ScratchTranslator commentStamp: 'jm 6/2/2008 15:11' prior: 0!I manage language translations for Scratch. All of my code in in class methods.!!ArgMorph commentStamp: 'jm 3/15/2003 12:22' prior: 0!I am an abstract superclass for all kinds of argument morphs--morphs that are used to hold the argument for various kinds of BlockMorph.!!ChoiceArgMorph commentStamp: 'jm 7/7/2004 00:28' prior: 0!I am used to represent an ArgMorph that allows the user to choose from a popup menu of choices. For example, I might allow selection of a sensor port from the list ('a', 'b', 'c', 'd').In an earlier version of Scratch, I was used to represent boolean values. That usage has been replaced with BooleanArgMorph.!!ChoiceOrExpressionArgMorph commentStamp: 'jm 11/28/2006 13:18' prior: 0!Argument placeholder that can either allow selection from a menu or be replaced with a numeric reporter block.!!ColorArgMorph commentStamp: 'jm 3/12/2003 18:44' prior: 0!I represent a color argument for a command block. Clicking on me allows the user to change my color value.!!EventTitleMorph commentStamp: 'jm 3/28/2005 15:16' prior: 0!I am used as the title for a named event hat. I have a popup list of events that includes a way to type in a new event name.Unlike other kind of ArgMorph, I can't be replaced with a reporter.!!ExpressionArgMorph commentStamp: 'jm 6/21/2004 13:29' prior: 0!I represent a literal value such as a number or string. I can be edited.!!ExpressionArgMorphWithMenu commentStamp: 'jm 3/28/2005 15:10' prior: 0!I represent a literal value such as a number or string. I can be edited by typing or a value can be chosen from a pull-down menu.!!SpriteArgMorph commentStamp: '<historical>' prior: 0!I represent a scriptable scratch morph argument for a command block.  Clicking on me and then another point on the screen allows the user to set my value to the scriptable scratch morph that has been clicked on.!!MultilineStringMorph commentStamp: 'jm 12/8/2006 12:28' prior: 0!An editable, multiple-line string in a single font with line wrapping.Best for small amounts of text; for longer texts or texts with multiple type styles, see TextMorph.My contents are stored in an array of strings ('lines') with all non-printing characters except cr's and spaces stripped out and tabs are replaced by a sequence of spaces.Selection start and end points are represented as points where y holds the line number and x holds the index in the line of the character immediately after the selection point. The range of x for line L is thus 1 to (L size + 1), where the last selection point within the line is just before the line break.Possible improvements:  a. handle tabs correctly  b. preserve non-printing characters (could be useful for editing files)!!ScratchBlockPaletteMorph commentStamp: 'jm 7/1/2004 23:16' prior: 0!I am used as a scrollable blocks palette morph in a ScratchViewerMorph.!!ScrollFrameMorph commentStamp: 'jm 6/3/2004 16:36' prior: 0!I am a frame for scrollable contents. I can independently show or hide my horizontal and vertical scrollbars.!!ScrollFrameMorph2 commentStamp: 'jm 2/23/2005 14:15' prior: 0!This subclass of ScrollFrameMorph uses ScratchScrollBars.!!StringFieldMorph commentStamp: 'jm 6/23/2005 16:08' prior: 0!I am a simple, editable one-line string for use in dialog boxes.If cr, lf, or enter is pressed and my client responds to it, I send the "accept" message to the client.I support selection by dragging the mouse. Double-clicking on a word selects that word. Double-clicking at either end selects everything.I respond to a number of editing keys including:  backspace/delete				delete the current selection; backspace if nothing is selected  ctrl-a							select all  ctrl-z, ctrl-x, ctrl-c, ctrl-v		undo, cut, copy, paste  left/right arrow				move the cursor left or rightEither the control or command key can be used to type the editing keys. That is, cmd-a does the same thing as ctrl-a. This should make both PC and Mac users happy.!!BaseIdTest commentStamp: '<historical>' prior: 0!A SteloIdTest is a test class for testing the behavior of SteloId!!EventIdTest commentStamp: '<historical>' prior: 0!A SEventIdTest is a test class for testing the behavior of SEventId!!LazyArrayTest commentStamp: '<historical>' prior: 0!A LasyArrayTest is a test class for testing the behavior of LasyArray!!ScratchBaseProcessTest commentStamp: '<historical>' prior: 0!A SteloProcessTest is a test class for testing the behavior of SteloProcess!!ScratchBytecodeLabelTest commentStamp: '<historical>' prior: 0!A SCodeLabelTest is a test class for testing the behavior of SCodeLabel!!ScratchBytecodeSymbolTest commentStamp: '<historical>' prior: 0!A SCodeSymbolTest is a test class for testing the behavior of SCodeSymbol!!ScratchBytecodeSymbolWithJumpTest commentStamp: '<historical>' prior: 0!A SCodeSymbolWithJumpTest is a test class for testing the behavior of SCodeSymbolWithJump!!ScratchBytecodeTest commentStamp: '<historical>' prior: 0!A SCodeTest is a test class for testing the behavior of SCode!!ScratchBytecodeValueTest commentStamp: '<historical>' prior: 0!A SCodeValueTest is a test class for testing the behavior of SCodeValue!!ScratchDirectoryTest commentStamp: '<historical>' prior: 0!A ScratchDirectoryTest is a test class for testing the behavior of ScratchDirectory!!ScratchExporterTest commentStamp: '<historical>' prior: 0!A SExporterTest is a test class for testing the behavior of SExporter!!ScratchSexpExporterTest commentStamp: '<historical>' prior: 0!A ScratchSexpExporterTest is a test class for testing the behavior of ScratchSexpExporter!!SexpLexerTest commentStamp: '<historical>' prior: 0!A SexpLexerTest is a test class for testing the behavior of SexpLexer!!SexpParserTest commentStamp: '<historical>' prior: 0!A SexpParserTest is a test class for testing the behavior of SexpParser!!VarDefTest commentStamp: '<historical>' prior: 0!A SVarIdTest is a test class for testing the behavior of SVarId!!VariablesTest commentStamp: '<historical>' prior: 0!A SVariablesTest is a test class for testing the behavior of SVariables!!ScratchScriptsMorph commentStamp: 'jm 8/3/2003 09:30' prior: 0!I hold the scripts and partially assembled scripts for a ScriptableScratchMorph.!!BlockMorph commentStamp: 'jm 3/13/2003 17:16' prior: 0!I and my subclasses represent statements in a block-based graphical programming language.!!CommandBlockMorph commentStamp: 'jm 5/10/2004 19:25' prior: 0!I represent a command or reporter. I have a label and may also have one or more arguments. The label text, number of arguments, and ordering of arguments and keywords are defined by my commandSpec string. This string consists of a sequence of keywords interspersed with argument specifications that indicate where the arguments appear. Here are some possible argument specifications:	%b	- boolean	%c	- color	%C	- color (chosen with eyedropper, not palette)	%m	- morph reference	%n	- number	%s	- stringExamples:	%b and %b	%m's color %C sees %C	repeat %n times!!CBlockMorph commentStamp: 'jm 12/7/2002 16:07' prior: 0!I am a command block that contains a nested sequence of command blocks, such as a loop.!!IfElseBlockMorph commentStamp: 'jm 12/13/2005 20:51' prior: 0!I am an "E" shaped block used for the if-then-else control structure.!!ListContentsBlockMorph commentStamp: 'jm 5/5/2008 10:40' prior: 0!Reporter for the contents of a list.!!VariableBlockMorph commentStamp: 'jm 2/20/2004 18:45' prior: 0!I am a block that reports the value of either a built-in or a user variable. When dropped into the workspace, I turn into a WatcherMorph for that variable with an optional slider.!!SetterBlockMorph commentStamp: 'jm 11/25/2003 13:04' prior: 0!I am a block for setting a variable.!!HatBlockMorph commentStamp: 'jm 3/28/2005 12:25' prior: 0!I represent a script consisting of a sequence of blocks.!!EventHatMorph commentStamp: 'jm 3/28/2005 12:25' prior: 0!I am a hat block for stacks triggered by Scratch events.!!ImageFrameMorph commentStamp: 'jm 10/20/2008 15:59' prior: 0!I am draw a rectangular frame using Forms. I have Forms for my four corners and form Forms that are used to tile my edges so that I can be resized.!!ToggleButton commentStamp: 'jm 8/22/2006 08:22' prior: 0!I am a button with several forms. Clicking on me toggles which form is shown and sends my target a message. If my isMomentary flag is true, then I return to my off state after I am pressed (i.e. when the mouse goes up).I can also show a different form on mouse-over.Finally, if I am disabled I can show a disabled form.!!BaseId class methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 11:18'!defaultUserNo	^ self reservedNo + 1! !!BaseId class methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 11:17'!reservedNo	^ 0! !!BaseId methodsFor: 'object i/o' stamp: 'EiichiroIto 9/13/2018 20:48'!fieldsVersion	^ 1! !!BaseId methodsFor: 'object i/o' stamp: 'EiichiroIto 3/13/2019 11:26'!initFieldsFrom: anObjStream version: classVersion	self initFieldsNamed: #(nextNo) from: anObjStream.! !!BaseId methodsFor: 'initialization' stamp: 'EiichiroIto 3/13/2019 11:18'!initialize	super initialize.	self rewind.! !!BaseId methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:25'!newNo	| v |	v := nextNo.	nextNo := nextNo + 1.	^ v! !!BaseId methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 11:25'!privNextNo	^ nextNo! !!BaseId methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 11:25'!privNextNo: anInteger	nextNo := anInteger! !!BaseId methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:28'!rewind	nextNo := self class defaultUserNo.! !!BaseId methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:25'!size	^ nextNo - 1! !!BaseId methodsFor: 'object i/o' stamp: 'EiichiroIto 3/13/2019 11:26'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(nextNo) on: anObjStream.! !!BaseId methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 12:21'!userDefinedVarNos	^ (self class defaultUserNo to: self size) asArray! !!EventId class methodsFor: 'accessing' stamp: 'EiichiroIto 3/14/2019 07:31'!loopEventNo	^ 3! !!EventId class methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 11:42'!reservedNo	^ 4! !!EventId class methodsFor: 'accessing' stamp: 'EiichiroIto 3/14/2019 07:32'!setupEventNo	^ 2! !!EventId class methodsFor: 'accessing' stamp: 'EiichiroIto 3/14/2019 07:32'!singleEventNo	^ 4! !!EventId class methodsFor: 'accessing' stamp: 'EiichiroIto 3/14/2019 07:32'!startupEventNo	^ 1! !!LazyArray class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/23/2019 22:12'!className: aSymbol	^ self basicNew		initialize;		className: aSymbol;		yourself! !!LazyArray class methodsFor: 'instance creation' stamp: 'EiichiroIto 10/27/2019 12:54'!newArray	^ self className: #Array! !!LazyArray methodsFor: 'private' stamp: 'EiichiroIto 9/24/2019 22:11'!allocateMore: anInteger	| newSize |	self assert: self fixedSize isNil.	newSize := anInteger roundUpTo: self defaultAllocationSize.	array := array		ifNil: [ self arrayClass new: newSize ]		ifNotNil: [ array grownBy: newSize ].! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 20:46'!array	array ifNil: [ array := self arrayClass new ].	^ array! !!LazyArray methodsFor: 'private' stamp: 'EiichiroIto 9/22/2019 12:07'!arrayClass	^ Smalltalk at: className! !!LazyArray methodsFor: 'private' stamp: 'EiichiroIto 10/27/2019 12:47'!assureExistsIndex: anInteger	self allocateMore: anInteger - self size! !!LazyArray methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 21:04'!assureExistsIndex: anInteger1 and: anInteger2	| arr |	anInteger1 > self size		ifTrue: [ self assureExistsIndex: anInteger1 ].	arr := array at: anInteger1.	arr		ifNil: [ arr := OrderedCollection new.			array at: anInteger1 put: arr ].	anInteger2 > arr size		ifTrue: [ arr := arr forceTo: anInteger2 paddingWith: self defaultValue.			array at: anInteger1 put: arr ].! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/17/2019 18:47'!at: anInteger	anInteger > self size		ifTrue: [ ^ self defaultValue ].	^ array at: anInteger! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/27/2019 12:47'!at: anInteger put: aValue	anInteger > self size		ifTrue: [ aValue = self defaultValue				ifTrue: [ ^ self ].			self assureExistsIndex: anInteger.			self assert: anInteger <= self size ].	array at: anInteger put: aValue! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 9/22/2019 12:05'!className	^ className! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 20:32'!className: aSymbol	className := aSymbol asSymbol! !!LazyArray methodsFor: 'private' stamp: 'EiichiroIto 9/23/2019 22:10'!defaultAllocationSize	^ 100! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/17/2019 18:47'!defaultValue	^ defaultValue ifNil: [ 0 ]! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/17/2019 18:48'!defaultValue: aNumber	self assert: defaultValue isNil.	defaultValue := aNumber.! !!LazyArray methodsFor: 'object i/o' stamp: 'EiichiroIto 10/17/2019 18:45'!fieldsVersion	^ 2! !!LazyArray methodsFor: 'private' stamp: 'EiichiroIto 9/24/2019 22:11'!fixedSize	^ fixedSize! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 9/24/2019 22:45'!forceSize: anInteger	self privFixedSize: anInteger.	array := array		ifNil: [ self arrayClass new: self fixedSize ]		ifNotNil: [ array forceTo: self fixedSize paddingWith: 0 ].! !!LazyArray methodsFor: 'object i/o' stamp: 'EiichiroIto 10/17/2019 18:46'!initFieldsFrom: anObjStream version: classVersion	classVersion = 1		ifTrue:			[ self initFieldsNamed: #(array className fixedSize) from: anObjStream ].	classVersion = 2		ifTrue: [ self				initFieldsNamed: #(array className fixedSize defaultValue)				from: anObjStream ]! !!LazyArray methodsFor: 'testing' stamp: 'EiichiroIto 9/23/2019 21:35'!isEmpty	^ array isNil or: [ array isEmpty ]! !!LazyArray methodsFor: 'testing' stamp: 'EiichiroIto 9/24/2019 22:06'!isFixed	^ fixedSize notNil! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:40'!list: anInteger1 add: anObject	anInteger1 = 0		ifTrue: [ ^ self ].	self assureExistsIndex: anInteger1 and: 0.	(array at: anInteger1) add: anObject! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:40'!list: anInteger1 at: anInteger2	| arr |	anInteger1 = 0		ifTrue: [ ^ self defaultValue ].	self assert: className = #Array.	anInteger1 > self size		ifTrue: [ self assureExistsIndex: anInteger1 ].	arr := array at: anInteger1.	(arr isNil or: [ anInteger2 > arr size ])		ifTrue: [ ^ self defaultValue ].	^ arr at: anInteger2! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:40'!list: anInteger1 at: anInteger2 put: anObject	anInteger1 = 0		ifTrue: [ ^ self ].	self assureExistsIndex: anInteger1 and: anInteger2.	(array at: anInteger1) at: anInteger2 put: anObject! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:40'!list: anInteger1 contains: anObject	anInteger1 = 0		ifTrue: [ ^ false ].	self assureExistsIndex: anInteger1 and: 0.	^ (array at: anInteger1) includes: anObject! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:40'!list: anInteger1 remove: anInteger2	| arr |	anInteger1 = 0		ifTrue: [ ^ self ].	self assureExistsIndex: anInteger1 and: 0.	arr := array at: anInteger1.	(anInteger2 > arr size or: [ anInteger2 = 0 ])		ifTrue: [ ^ self ].	arr removeAt: anInteger2! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:40'!list: anInteger1 set: aCollection	anInteger1 = 0		ifTrue: [ ^ self ].	self assureExistsIndex: anInteger1 and: 0.	array at: anInteger1 put: aCollection copy asOrderedCollection! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:41'!listSizeOf: anInteger	(anInteger between: 1 and: self size)		ifFalse: [ ^ 0 ].	^ (array at: anInteger) size! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 10/29/2019 14:23'!multiplyBy: aNumber	array		ifNil: [ defaultValue ifNotNil: [ defaultValue := defaultValue * aNumber ] ]		ifNotNil: [ array *= aNumber ]! !!LazyArray methodsFor: 'printing' stamp: 'EiichiroIto 9/24/2019 22:27'!printOn: aStream	aStream		nextPutAll: 'LazyArray(';		nextPutAll: className asString;		nextPutAll: ','.	self isFixed		ifTrue: [ aStream nextPut: $* ].	aStream		nextPutAll: self size asString;		nextPutAll: ')'.! !!LazyArray methodsFor: 'private' stamp: 'EiichiroIto 9/21/2019 17:35'!privArray	^ array! !!LazyArray methodsFor: 'private' stamp: 'EiichiroIto 9/21/2019 17:35'!privArray: anArray	array := anArray.! !!LazyArray methodsFor: 'private' stamp: 'EiichiroIto 9/24/2019 21:59'!privFixedSize: anInteger	fixedSize := anInteger.! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 9/24/2019 22:45'!reset	array := self isFixed		ifTrue: [ self arrayClass new: fixedSize ]		ifFalse: [ nil ]! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 9/22/2019 19:53'!setArray: aCollection	className ~= aCollection class name		ifTrue: [ self error ].	array := aCollection copy.! !!LazyArray methodsFor: 'accessing' stamp: 'EiichiroIto 9/21/2019 17:56'!size	array ifNil: [ ^ 0 ].	^ array size! !!LazyArray methodsFor: 'object i/o' stamp: 'EiichiroIto 10/17/2019 18:45'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(array className fixedSize defaultValue) on: anObjStream.! !!ObjRefRecord methodsFor: 'accessing' stamp: 'jm 9/23/2003 15:58'!objectID	^ objectID! !!ObjRefRecord methodsFor: 'accessing' stamp: 'jm 9/23/2003 15:59'!objectID: anInteger	objectID :=  anInteger.! !!ObjRefRecord methodsFor: 'printing' stamp: 'EiichiroIto 11/23/2019 16:02'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: objectID asString;		nextPut: $)! !!ObjStream class methodsFor: 'accessing' stamp: 'EiichiroIto 11/8/2019 21:43'!arrayFor: id size: size	| classSymbol |	classSymbol := (IDToClassEntry at: id) second.	classSymbol = #Array ifTrue: [ ^ Array new: size ].	classSymbol = #FloatArray ifTrue: [ ^ FloatArray new: size ].	classSymbol = #IntegerArray ifTrue: [ ^ IntegerArray new: size ].	self error: 'Invalid Array'! !!ObjStream class methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 16:39'!fileVersion: anAppClass from: aStream	"Answer the Scratch file version number from the given string. If the string is of the form: 'ScratchVxx', were xx is a two-digit integer, answer the value of xx. Otherwise, answer 0."	| str |	str := (aStream next: anAppClass appVersion size) asString.	(str beginsWith: anAppClass appVersionTag)		ifFalse: [ ^ 0 ].	^ (str		copyFrom: anAppClass appVersionTag size + 1		to: str size) asNumberNoError! !!ObjStream class methodsFor: 'private' stamp: 'EiichiroIto 11/8/2019 20:56'!fixedFormatClasses	"Answer an array of records for fixed-format classes."	^ #(		"id	class					read selector		write selector"		(1	UndefinedObject			getConst:id:			putConst:id:)		(2	True					getConst:id:			putConst:id:)		(3	False					getConst:id:			putConst:id:)		(4	SmallInteger			getSmallInt:id:		putSmallInt:id:)		(5	SmallInteger16			getSmallInt:id:		putSmallInt:id:)  "optimization for ints that fit into 16 bits"		(6	LargePositiveInteger		getBigInt:id:			putBigInt:id:)		(7	LargeNegativeInteger	getBigInt:id:			putBigInt:id:)		"(8	Float					getFloat:id:			putFloat:id:)"		(8		SmallFloat64					getFloat:id:			putFloat:id:)		(9		String					getBytes:id:			putBytes:id:)		(10	Symbol					getBytes:id:			putBytes:id:)		(11	ByteArray				getBytes:id:			putBytes:id:)		(12	BoxedFloat64					getFloat:id:			putFloat:id:)		(13	Bitmap					getBitmap:id:		putBitmap:id:)		(14	ByteString				getBytes:id:			putBytes:id:)		(15	FloatArray					getArray:id:			putArray:id:)		(16	ColorArray					getArray:id:			putArray:id:)		(17	WideString				getBytes:id:			putBytes:id:)		(18	IntegerArray				getArray:id:			putArray:id:)	"12-19 reserved for additional non-pointer objects"		(20	Array					getArray:id:			putArray:id:)		(21	OrderedCollection		getCollection:id:		putCollection:id:)		(22	Set						getCollection:id:		putCollection:id:)		(23	IdentitySet				getCollection:id:		putCollection:id:)		(24	Dictionary				getDict:id:			putDict:id:)		(25	IdentityDictionary		getDict:id:			putDict:id:)	"26-29 reserved for additional collections"		(30	Color					getColor:id:			putColor:id:)		"(31	TranslucentColor		getColor:id:			putColor:id:)"		(32	Point					getPoint:id:			putPoint:id:)		(33	Rectangle				getRect:id:			putRect:id:)		(34	Form					getForm:id:			putForm:id:)		(35	ColorForm				getForm:id:			putForm:id:)	"99 reserved for object references"	"100-255 reserved for user-defined classes"	)! !!ObjStream class methodsFor: 'class initialization' stamp: 'EiichiroIto 11/23/2019 23:39'!setupVariables	"self setupVariables"	| entry2 |	ObjectReferenceID := 99.	IDToClassEntry := Dictionary new.	NameToClassEntry := Dictionary new.	self fixedFormatClasses		do: [ :entry | 			(IDToClassEntry includesKey: entry first)				ifTrue: [ self error: 'duplicate fixed class ID' ].			IDToClassEntry at: entry first put: entry.			NameToClassEntry at: entry second put: entry ].	self userClasses		do: [ :pair | 			entry2 := pair , #(unused #putUserObj:id:).			(IDToClassEntry includesKey: entry2 first)				ifTrue: [ self error: 'duplicate user class ID' ].			IDToClassEntry at: entry2 first put: entry2.			NameToClassEntry at: entry2 second put: entry2 ].	FloatClassID := (NameToClassEntry at: #BoxedFloat64) first.	FirstPointerClassID := (NameToClassEntry at: #Array) first.	NameToClassEntry at: #ByteSymbol put: (NameToClassEntry at: #Symbol)! !!ObjStream class methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 08:48'!userClasses	"Answer an array of (<class id>, <class name>) records for all version numbered user classes."	"The following finds obsolete user classes:"	"self initialize. self userClasses reject: [:rec | Smalltalk includesKey: rec second]"	^ #(		"id		class"		(100		Morph)		(101		BorderedMorph)		"(102		RectangleMorph)"		(103		EllipseMorph)		(104		AlignmentMorph)		(105		StringMorph)		"(106		UpdatingStringMorph)"		"(106		UpdatingStringMorphWithParameter)"		"(107		SimpleSliderMorph)"		(108		SimpleButtonMorph)		"(109		SampledSound)"		(110		ImageMorph)		"111-129 for subclass"		(130 	EventId)		(131		Variables)		(132		VarDef)		(133 	LazyArray)		(140		ChoiceArgMorph)		(141		ColorArgMorph)		(142		ExpressionArgMorph)		"(143	ParameterReferenceMorph)"		"(144	PositionArgMorph)"		(145		SpriteArgMorph)		"(146	VariableArgMorph)"		(147		BlockMorph)		(148		CommandBlockMorph)		(149		CBlockMorph)		"(150	MethodCallBlockMorph)"		(151		HatBlockMorph)		"(152	ScratchButtonMorph)"		(153		ScratchScriptsMorph)		"(154		ScratchSliderMorph)"		"(155		WatcherMorph)"		"(156	ParameterMorph)"		(157		SetterBlockMorph)		(158		EventHatMorph)		(159		SubHatMorph)		(160		VariableBlockMorph)		"(161		IACTHatBlock)"		"(162		ImageMedia)"		"(163		MovieMedia)		(164		SoundMedia)		(165		KeyEventHatMorph)"		(166		BooleanArgMorph)		(167		EventTitleMorph)		"(168		MouseClickEventHatMorph)"		(169		ExpressionArgMorphWithMenu)		"(170		ReporterBlockMorph)"		(171		MultilineStringMorph)		(172		ToggleButton)		"(173		WatcherReadoutFrameMorph)"		"(174		WatcherSliderMorph)"		"(175		ScratchListMorph)"		"(176		ScrollingStringMorph)"	)! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/23/2003 14:15'!classEntryFor: anObject	"Answer the entry containing the class id and read/write selectors for the given object's class. Raise an error if the class is not registered."	^ NameToClassEntry at: anObject class name		ifAbsent: [self error: 'Unknown class ',  anObject class name]! !!ObjStream methodsFor: 'private-reading' stamp: 'EiichiroIto 9/27/2016 21:01'!classForID: classID	"Answer the class for the given class ID."	^ Smalltalk at: (self classSymbolForID: classID)! !!ObjStream methodsFor: 'private-reading' stamp: 'EiichiroIto 9/27/2016 21:01'!classSymbolForID: classID	"Answer the class symbol for the given class ID."	^ (IDToClassEntry at: classID) second! !!ObjStream methodsFor: 'private' stamp: 'EiichiroIto 9/30/2016 22:36'!convertFromUTF8: aString	^ UTF8TextConverter new convertFromSystemString: aString asString asByteString! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/28/2003 15:27'!fixReferencesForObjectRecord: objectRecord	"After reading all the objects in the objects table, this method is called on each object record to replace all its object references with pointers to the actual object in the object table. The fields for user-defined objects are still held in an array in the object table record. Fixed-format objects are processed by calling their read selector a second time and, since firstPass is now false, this read method fixes any object references."	| obj classEntry classID readSelector |	obj := objectRecord first.	classEntry := self classEntryFor: obj.	classID := classEntry first.	classID >= FirstPointerClassID ifTrue: [		classID > ObjectReferenceID			ifTrue: [  "user defined class"				self fixRefsInArray: (objectRecord at: 4)]			ifFalse: [  "fixed format class"				readSelector := classEntry at: 3.				self perform: readSelector with: obj with: classID]].! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 10/21/2003 10:36'!fixRefsInArray: anArray	"Replace any ObjRefRecord objects in the given array with references to the actual objects."	| el |	1 to: anArray size do: [:i |		el := anArray at: i.		el class = ObjRefRecord ifTrue: [			el objectID > objects size				ifTrue: [anArray at: i put: #badObjRef]				ifFalse: [anArray at: i put: (objects at: el objectID) first]]].! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'EiichiroIto 10/17/2019 20:50'!getArray: anObject id: classID	| sz result |	firstPass ifTrue: [		sz := stream uint32.		result := self class arrayFor: classID size: sz.		1 to: sz do: [:i | result at: i put: self readField].		^ result].	"fix references"	self fixRefsInArray: anObject.! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/28/2003 11:39'!getBigInt: anObject id: classID	| digitCount result |	digitCount := stream uint16.	result := (self classForID: classID) new: digitCount.	1 to: digitCount do: [:i | result digitAt: i put: stream next].	^ result! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 10/10/2003 09:07'!getBitmap: anObject id: classID	| count result |	count := stream uint32.	result := Bitmap new: count.	1 to: count do: [:i | result at: i put: stream uint32].	^ result! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'EiichiroIto 10/23/2018 21:00'!getBytes: anObject id: classID	| byteCount result |	byteCount := stream uint32.	result := stream next: byteCount.	classID = 9		ifTrue: [ ^ result asString ].	classID = 10		ifTrue: [ ^ result asString asSymbol ].	classID = 14		ifTrue: [ ^ self convertFromUTF8: result ].	classID = 17		ifTrue: [ ^ result asWideString ].	^ result.! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/28/2003 11:56'!getCollection: anObject id: classID	| sz result newContents |	firstPass ifTrue: [		sz := stream uint32.		result := (self classForID: classID) new: sz.		sz timesRepeat: [result add: self readField].		^ result].	"fix references"	newContents := anObject asArray.	self fixRefsInArray: newContents.	anObject removeAll: anObject copy; addAll: newContents.! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'EiichiroIto 9/14/2018 08:35'!getColor: anObject id: classID	| rgb |	firstPass		ifFalse: [ ^ anObject ].	rgb := stream uint32.	^ Color basicNew		setRGB: rgb;		setAlpha: stream next / 255.0.! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/23/2003 16:35'!getConst: anObject id: classID	classID = 1 ifTrue: [^ nil].	classID = 2 ifTrue: [^ true].	classID = 3 ifTrue: [^ false].! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'EiichiroIto 10/1/2016 09:18'!getDict: anObject id: classID	| sz result key value newContents |	firstPass ifTrue: [		sz := stream uint32.		result := (self classForID: classID) new: sz.		sz timesRepeat: [			key := self readField.			value := self readField.			result at: key put: value].		^ result].	"fix references"	newContents := OrderedCollection new: anObject size.	anObject copy associationsDo: [:assoc |		newContents add: ((self targetObjectFor: assoc key) -> (self targetObjectFor: assoc value)).		anObject removeKey: assoc key].	anObject size = 0 ifFalse: [self error: 'should be empty!!'].	anObject addAll: newContents asDictionary.! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/24/2003 09:58'!getFloat: anObject id: classID	| result |	result := Float new: 2.	result basicAt: 1 put: stream uint32.	result basicAt: 2 put: stream uint32.	^ result! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/24/2003 12:43'!getForm: anObject id: classID	| w h d offset bits result |	firstPass ifTrue: [		w := self readField.		h := self readField.		d := self readField.		offset := self readField.		bits := self readField.		result := (self classForID: classID) basicNew			setExtent: w@h depth: d bits: bits;			offset: offset.		(result class = ColorForm) ifTrue: [result privateColors: self readField].		^ result].	"fix references"	anObject bits: (self targetObjectFor: anObject bits).	anObject offset: (self targetObjectFor: anObject privateOffset).	(anObject class = ColorForm) ifTrue: [anObject privateColors: (self targetObjectFor: anObject privateColors)].! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/24/2003 14:13'!getPoint: anObject id: classID	| x y |	firstPass ifTrue: [		x := self readField.		y := self readField.		^ Point x: x y: y].	"fix references"	anObject		setX: (self targetObjectFor: anObject x)		setY: (self targetObjectFor: anObject y).! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/24/2003 14:13'!getRect: anObject id: classID	| x1 y1 x2 y2 |	firstPass ifTrue: [		x1 := self readField.		y1 := self readField.		x2 := self readField.		y2 := self readField.		^ (Point x: x1 y: y1) corner: (Point x: x2 y: y2)].	"fix references"	anObject origin		setX: (self targetObjectFor: anObject origin x)		setY: (self targetObjectFor: anObject origin y).	anObject corner		setX: (self targetObjectFor: anObject corner x)		setY: (self targetObjectFor: anObject corner y).! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/23/2003 16:52'!getSmallInt: anObject id: classID	classID = 4 ifTrue: [^ stream int32].	classID = 5 ifTrue: [^ stream int16].! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 7/13/2004 00:21'!initializeUserDefinedFields: objectRecord	"If the given object record designates a user-defined object, ask that object to initialiize itself from its fields list. Otherwise, do nothing."	| obj classID classVersion |	obj := objectRecord at: 1.	classID := objectRecord at: 2.	classID > ObjectReferenceID ifTrue: [  "user defined class"		classVersion := objectRecord at: 3.		fields := objectRecord at: 4.		fieldIndex := 0.		obj initFieldsFrom: self version: classVersion].! !!ObjStream methodsFor: 'entry points' stamp: 'jm 7/8/2008 05:58'!nextField	"Answer the next field and advance to the next field. This method should only be called from initFieldsFrom:version: during deserialization."	"Note: If class versions are managed correctly, it should not be necessary to check that fieldIndex is in bounds. However, sometimes during development, we store a project that has objects with an extra field that is later removed. The check on fields size allows us to fail more gracefully in such cases."	fieldIndex := fieldIndex + 1.	fieldIndex > fields size ifTrue: [^ nil]. "fail gracefully"	^ fields at: fieldIndex! !!ObjStream methodsFor: 'entry points' stamp: 'jm 5/14/2005 11:44'!objects	^ objects! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/23/2003 20:16'!putArray: anObject id: classID	self putCollection: anObject id: classID.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/23/2003 16:49'!putBigInt: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint16: anObject digitLength.	1 to: anObject digitLength do: [:i | stream nextPut: (anObject digitAt: i)].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 10/10/2003 09:06'!putBitmap: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint32: anObject size.	anObject do: [:el | stream uint32: el].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'EiichiroIto 10/23/2018 21:00'!putBytes: anObject id: classID	| buf |	firstPass		ifTrue: [ ^ self ].	buf := anObject asByteArray.	stream nextPut: classID.	stream uint32: buf size.	stream nextPutAll: buf.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/23/2003 20:15'!putCollection: anObject id: classID	firstPass ifFalse: [		stream nextPut: classID.		stream uint32: anObject size].	anObject do: [:el | self putField: el].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'EiichiroIto 9/14/2018 08:33'!putColor: anObject id: classID	| a |	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint32: anObject privateRGB.	a := (anObject privateAlpha asInteger min: 255) max: 0.	stream nextPut: a.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/22/2003 18:31'!putConst: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/22/2003 18:57'!putDict: anObject id: classID	firstPass ifFalse: [		stream nextPut: classID.		stream uint32: anObject size].	anObject associationsDo: [:assoc |		self putField: assoc key.		self putField: assoc value].! !!ObjStream methodsFor: 'entry points' stamp: 'jm 9/28/2003 12:07'!putField: anObject	"Put the given object. If the given object is nil, true, false, an integer, or a float, it is stored directly. Otherwise, it is stored as an object reference and the object will be stored exactly once no matter how many other objects refer to it."	| entry classID putSelector |	entry := self classEntryFor: anObject.	classID := entry at: 1.	putSelector := entry at: 4. 	firstPass ifTrue: [fields addLast: anObject].	fieldIndex := fieldIndex + 1.	classID <= FloatClassID ifTrue: [  "store the value directly inline"		firstPass ifFalse: [self perform: putSelector with: anObject with: classID].		^ self].		firstPass		ifTrue: [self recordObject: anObject id: classID]		ifFalse: [self writeObjRef: (fields at: fieldIndex)].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/28/2003 11:48'!putFloat: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint32: (anObject basicAt: 1).	stream uint32: (anObject basicAt: 2).! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/24/2003 12:16'!putForm: anObject id: classID	firstPass ifFalse: [stream nextPut: classID].	anObject hibernate.	self putField: anObject width.	self putField: anObject height.	self putField: anObject depth.	self putField: anObject privateOffset.	self putField: anObject bits.	(anObject class = ColorForm) ifTrue: [self putField: anObject colors].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/22/2003 18:55'!putPoint: anObject id: classID	firstPass ifFalse: [		stream nextPut: classID].	self putField: anObject x.	self putField: anObject y.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/22/2003 18:56'!putRect: anObject id: classID	firstPass ifFalse: [		stream nextPut: classID].	self putField: anObject left.	self putField: anObject top.	self putField: anObject right.	self putField: anObject bottom.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/23/2003 13:55'!putSmallInt: anObject id: classID	firstPass ifTrue: [^ self].	((-32768 <= anObject) and: [anObject <= 32767])		ifTrue: [  "optimization for integers that fit into 16 bits"			stream nextPut: classID + 1.			stream int16: anObject]		ifFalse: [			stream nextPut: classID.			stream int32: anObject].! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/23/2003 14:16'!putUserObj: anObject id: ignored	"Ask the given user-defined object to write it's fields."	anObject storeFieldsOn: self.! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/23/2003 18:30'!readField	"Read a single object field. The result may be an object or an object reference."	| classID readSelector |	classID := stream next.	classID = ObjectReferenceID ifTrue: [		^ ObjRefRecord new objectID: stream uint24].	readSelector := (IDToClassEntry at: classID) at: 3.	^ self perform: readSelector with: nil with: classID! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/23/2003 15:11'!readFileHeader	"Read the file header on my stream."	(((stream next: 4) asString = 'ObjS') &	 (stream next = 1) &	 ((stream next: 4) asString = 'Stch') &	 (stream next = 1)) ifFalse: [		self error: 'bad header'].! !!ObjStream methodsFor: 'entry points' stamp: 'jm 5/15/2005 09:12'!readObjFrom: aStream	"Read the root object from the given binary stream."	^ self readObjFrom: aStream showProgress: false! !!ObjStream methodsFor: 'entry points' stamp: 'EiichiroIto 6/30/2019 21:18'!readObjFrom: aStream showProgress: showProgress	"Read the root object from the given binary stream. If showProgress is true, display a progress bar."	| objCount tenPercent |	objects := OrderedCollection new.	stream := aStream.	self readFileHeader.	firstPass := true.	objCount := stream uint32.	showProgress		ifTrue: [			tenPercent := objCount // 10.			('Reading' localized, ScratchTranslator ellipsesSuffix)				displayProgressFrom: 0 to: objCount + tenPercent				during: [:progressBar |					1 to: objCount do: [:i |						objects addLast: self readObjectRecord.						progressBar value: i].					firstPass := false.					objects do: [:rec | self fixReferencesForObjectRecord: rec].					progressBar value: objCount + (tenPercent // 2).					objects do: [:rec | self initializeUserDefinedFields: rec].					progressBar value: objCount + tenPercent.					(Delay forMilliseconds: 200) wait]]		ifFalse: [			objCount timesRepeat: [objects addLast: self readObjectRecord].			firstPass := false.			objects do: [:rec | self fixReferencesForObjectRecord: rec].			objects do: [:rec | self initializeUserDefinedFields: rec]].	^ objects first first! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/28/2003 12:15'!readObjectRecord	"Read the next object record. Answer an array of the form (<obj> <class ID> [<version> <fieldsArray>]). The version and fields array are supplied only for user-defined objects."	| classID obj classVersion fieldCount fieldList readSelector |	classID := stream next.	classID > ObjectReferenceID		ifTrue: [  "user defined object"			obj := (self classForID: classID) new.			classVersion := stream next.			fieldCount := stream next.			fieldList := (1 to: fieldCount) collect: [:i | self readField].			^ Array with: obj with: classID with: classVersion with: fieldList]		ifFalse: [  "fixed format object"			readSelector := (IDToClassEntry at: classID) at: 3.			obj := self perform: readSelector with: nil with: classID.			^ Array with: obj with: classID].! !!ObjStream methodsFor: 'entry points' stamp: 'jm 6/14/2005 10:08'!readObjsFrom: aStream	"For testing. Answer the entire objects table from the given stream."	| objCount |	objects := OrderedCollection new.	stream := aStream.	self readFileHeader.	firstPass := true.	objCount := stream uint32.	objCount timesRepeat: [objects addLast: self readObjectRecord].	firstPass := false.	objects do: [:rec | self fixReferencesForObjectRecord: rec].	objects do: [:rec | self initializeUserDefinedFields: rec].	^ objects! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/23/2003 15:19'!recordFieldsOf: anObject	"Record the fields of the given object."	"Details: Sometimes a user-defined class creates an object dynamically in a call to putField:. To preserve object identity between passes one and two, the objects passed to all calls to putField: are recorded during the first pass (i.e., by this method) and those exact same objects are used in the second pass."	| entry classID putSelector |	entry := self classEntryFor: anObject.	classID := entry at: 1.	putSelector := entry at: 4.	fields := OrderedCollection new.	fieldIndex := 0.	self perform: putSelector with: anObject with: classID.	(objects at: anObject) at: 4 put: fields asArray.! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/28/2003 12:26'!recordObject: anObject id: classID	"Assign an ID for the given object, add it to the list of objects to be stored in the object table, and add it to the toDo list. Do nothing if this object has already been recorded."	(objects includesKey: anObject) ifTrue: [^ self].	objects at: anObject put: (Array with: objectIndex with: anObject with: classID with: nil).	toDo addLast: anObject.	objectIndex := objectIndex + 1.! !!ObjStream methodsFor: 'entry points' stamp: 'jm 5/14/2005 11:23'!storeObj: anObject on: aStream	"Write the given object and all the objects that can be reached from it on the given binary stream. Do not display a progress bar."	self storeObj: anObject on: aStream showProgress: false.! !!ObjStream methodsFor: 'entry points' stamp: 'EiichiroIto 6/30/2019 21:21'!storeObj: anObject on: aStream showProgress: showProgress	"Write the given object and all the objects that can be reached from it on the given binary stream. If showProgress is true, display a progress bar."	| sortedObjEntries i obj |	objects := IdentityDictionary new.	objectIndex := 1.	"collect objects"	stream := nil.	firstPass := true.	toDo := OrderedCollection new.	self recordObject: anObject id: (self classEntryFor: anObject) first.	[toDo size > 0] whileTrue: [self recordFieldsOf: toDo removeFirst].	"write object table"	stream := aStream.	firstPass := false.	sortedObjEntries := objects asArray sort: [:e1 :e2 | e1 first < e2 first].	self writeFileHeader.	stream uint32: sortedObjEntries size.	showProgress		ifTrue: [			i := 0.  "object counter for progress bar"			'Saving...'				displayProgressFrom: 0 to: sortedObjEntries size				during:  [:progressBar |					sortedObjEntries do: [:objEntry |						progressBar value: (i := i + 1).						obj := objEntry at: 2.						self writeObject: obj objEntry: objEntry]]]		ifFalse: [			sortedObjEntries do: [:objEntry |				obj := objEntry at: 2.				self writeObject: obj objEntry: objEntry]].! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/23/2003 18:33'!targetObjectFor: anObject	"If the argument is an ObjRefRecord, answer the object that it refers to. Otherwise, just answer the argument."	anObject class = ObjRefRecord		ifTrue: [^ (objects at: anObject objectID) first]		ifFalse: [^ anObject].! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/23/2003 15:08'!writeFileHeader	"Write the file header on my stream."	stream nextPutAll: 'ObjS' asByteArray.	stream nextPut: 1.	stream nextPutAll: 'Stch' asByteArray.	stream nextPut: 1.! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 2/3/2009 14:14'!writeObjRef: anObject	"Write a reference to the given object to my output stream. The object must have an entry in the object dictionary."	| objEntry objIndex |	objEntry := objects at: anObject ifAbsent: [self error: 'object not in dictionary'].  "should never happen"	objIndex := objEntry at: 1.	stream nextPut: ObjectReferenceID.	stream uint24: objIndex.! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/24/2003 15:37'!writeObject: anObject objEntry: objEntry	"Write the object described by the given entry."	| entry classID putSelector |	entry := self classEntryFor: anObject.	classID := entry at: 1.	putSelector := entry at: 4.	fields := objEntry at: 4.	fieldIndex := 0.	putSelector = #putUserObj:id: ifTrue: [		stream nextPut: classID.		stream nextPut: anObject fieldsVersion.		stream nextPut: fields size].	self perform: putSelector with: anObject with: classID.! !!Object methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 22:27'!asNumberNoError	^ 0! !!Object methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/30/2016 21:17'!initFieldsNamed: varList from: anObjStream	"Initialize my instance variables in the given list from the given object stream."	| allVars |	allVars := self class allInstVarNames.	varList		do: [ :varName | 			(allVars indexOf: varName)				in: [ :index | 					index = 0						ifTrue: [ anObjStream nextField ]						ifFalse: [ self instVarAt: index put: anObjStream nextField ] ] ]! !!Object methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 10:07'!storeFieldsNamed: varList on: anObjStream	"Store the instance variables in the given list on the given object stream."	| allVars |	allVars := self class allInstVarNames.	varList		do: [ :varName | 			(allVars indexOf: varName)				in: [ :index | 					index = 0						ifTrue: [ anObjStream putField: 0 ]						ifFalse: [ anObjStream putField: (self instVarAt: index) ] ] ]! !!ScratchBaseProcess methodsFor: 'testing' stamp: 'EiichiroIto 8/8/2019 22:40'!isRunning	self subclassResponsibility.! !!ScratchBaseProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:37'!loop	self subclassResponsibility.! !!ScratchBaseProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:16'!program	^ program! !!ScratchBaseProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:16'!program: aProgram	program := aProgram.! !!ScratchBaseProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:37'!single	self subclassResponsibility.! !!ScratchBaseProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:37'!startup	self subclassResponsibility.! !!ScratchBaseProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:37'!step	self subclassResponsibility.! !!ScratchBaseProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:37'!stop	self subclassResponsibility.! !!ScratchBlockParser class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 20:27'!allSymbols	"self allSymbols inspect."	| list |	list := ScratchScript allBlockSpecs.	list := list select: [ :each | each isArray ].	list := list collect: [ :each | each third ].	list := list collect: [ :each | self operatorAt: each ifAbsent: [ each ] ].	list := list asSet.	list := list asSortedCollection.	^ list asArray! !!ScratchBlockParser class methodsFor: 'private' stamp: 'EiichiroIto 9/6/2019 10:52'!buildOperatorDict	"self buildOperatorDict"	OperatorDict := Dictionary new.	OperatorDict at: #+ put: #plus:and:.	OperatorDict at: #- put: #minus:with:.	OperatorDict at: #* put: #multiply:and:.	OperatorDict at: #/ put: #divide:by:.	OperatorDict at: #< put: #less:than:.	OperatorDict at: #= put: #equal:to:.	OperatorDict at: #> put: #more:than:.	OperatorDict at: #& put: #and:with:.	OperatorDict at: #| put: #or:with:.	OperatorDict at: #\\ put: #mod:by:.	InvOperatorDict := Dictionary new.	OperatorDict		keysAndValuesDo: [ :key :value | InvOperatorDict at: value asSymbol put: key asString ]! !!ScratchBlockParser class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/20/2018 18:34'!codeGenerator: aCodeGenerator	^ self basicNew		privCodeGenerator: aCodeGenerator;		yourself.! !!ScratchBlockParser class methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 21:51'!initialize	"ScratchBlockParser initialize."	self buildOperatorDict.! !!ScratchBlockParser class methodsFor: 'accessing' stamp: 'EiichiroIto 8/2/2019 17:09'!invOperatorAt: aSymbol ifAbsent: aBlock	^ InvOperatorDict at: aSymbol asSymbol ifAbsent: aBlock! !!ScratchBlockParser class methodsFor: 'testing' stamp: 'EiichiroIto 8/2/2019 17:07'!isInvOperator: aSymbol	^ InvOperatorDict includesKey: aSymbol asSymbol! !!ScratchBlockParser class methodsFor: 'testing' stamp: 'EiichiroIto 9/7/2018 16:23'!isOperator: aSymbol	^ OperatorDict includesKey: aSymbol asSymbol! !!ScratchBlockParser class methodsFor: 'instance creation' stamp: 'EiichiroIto 6/15/2018 10:57'!new	self shouldNotImplement! !!ScratchBlockParser class methodsFor: 'accessing' stamp: 'EiichiroIto 9/7/2018 16:23'!operatorAt: aSymbol ifAbsent: aBlock	^ OperatorDict at: aSymbol asSymbol ifAbsent: aBlock! !!ScratchBlockParser methodsFor: 'arg generator' stamp: 'EiichiroIto 9/20/2018 18:29'!argString: anArgMorph 	^ codeGenerator argString: anArgMorph.! !!ScratchBlockParser methodsFor: 'arg generator' stamp: 'EiichiroIto 9/20/2018 18:29'!booleanArgString: anArgMorph 	^ codeGenerator falseString.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 6/15/2018 07:09'!emitBlock: aMorph indent: indent	self emitBlockCode: aMorph! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 12:11'!emitBlockBegin: aMorph 	codeGenerator generateBegin: aMorph selector morph: aMorph.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 12:11'!emitBlockCenter: aMorph 	codeGenerator generateCenter: aMorph selector morph: aMorph.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 12:10'!emitBlockCode: aMorph 	codeGenerator generateCode: aMorph selector morph: aMorph.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 12:12'!emitBlockEnd: aMorph 	codeGenerator generateEnd: aMorph selector morph: aMorph.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 9/13/2018 09:14'!emitCBlock: aMorph indent: indent 	self emitBlockBegin: aMorph.	aMorph nestedBlock ifNil: [self emitPassIndent: indent + 1]		ifNotNil: [self emitCode: aMorph nestedBlock indent: indent + 1].	self emitBlockEnd: aMorph.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!emitCode: aMorph indent: indent 	self emitIndent: indent.	aMorph emitCode: self indent: indent.	aMorph nextBlock		ifNotNil: [self				emitCode: aMorph nextBlock				indent: indent]! !!ScratchBlockParser methodsFor: 'code generator'!emitCodeHat: aHatBlock	aHatBlock emitCode: self indent: 0.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 9/11/2019 21:43'!emitEventHatBlock: aMorph indent: indent	| str |	str := aMorph eventName.	str isEmpty ifTrue: [^ self].	codeGenerator generateEventHeader: str.	aMorph nextBlock		ifNotNil: [self				emitCode: aMorph nextBlock				indent: indent + (codeGenerator indentLevelFor: str)].	codeGenerator generateEventFooter: str.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 14:39'!emitHatBlock: aMorph indent: indent	codeGenerator generateHat: aMorph morph: aMorph.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 9/13/2018 16:07'!emitIfElseBlock: aMorph indent: indent 	self emitBlockBegin: aMorph.	aMorph trueBlock ifNil: [self emitPassIndent: indent + 1]		ifNotNil: [self emitCode: aMorph trueBlock indent: indent + 1].	self emitBlockCenter: aMorph.	aMorph falseBlock ifNil: [self emitPassIndent: indent + 1]		ifNotNil: [self emitCode: aMorph falseBlock indent: indent + 1].	self emitBlockEnd: aMorph.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 9/20/2018 18:29'!emitIndent: anInteger	codeGenerator generateIndent: anInteger! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 9/20/2018 18:29'!emitPassIndent: indent	self emitIndent: indent.	codeGenerator generatePass.! !!ScratchBlockParser methodsFor: 'code generator' stamp: 'EiichiroIto 9/11/2019 21:43'!emitSubHatBlock: aMorph indent: indent	| str |	str := aMorph subName.	str isEmpty ifTrue: [^ self].	codeGenerator generateSubHeader: str.	aMorph nextBlock		ifNotNil: [self				emitCode: aMorph nextBlock				indent: indent + (codeGenerator indentLevelFor: str)].	codeGenerator generateSubFooter: str.! !!ScratchBlockParser methodsFor: 'arg generator' stamp: 'EiichiroIto 10/9/2018 16:59'!eventTitleArgString: aMorph	^ codeGenerator eventTitleString: aMorph eventName! !!ScratchBlockParser methodsFor: 'arg generator' stamp: 'EiichiroIto 9/20/2018 18:29'!expressionArgWithMenuString: t1 	^ codeGenerator expressionArgWithMenuString: t1! !!ScratchBlockParser methodsFor: 'accessing' stamp: 'EiichiroIto 8/2/2019 14:15'!parseBlock: aTopBlock	aTopBlock emitCode: self indent: 0.! !!ScratchBlockParser methodsFor: 'private' stamp: 'EiichiroIto 7/14/2019 09:02'!privCodeGenerator: aCodeGenerator	codeGenerator := aCodeGenerator.! !!ScratchBlockParser methodsFor: 'arg generator' stamp: 'EiichiroIto 8/2/2019 12:30'!reporterArgString: aReporterMorph	| selector |	selector := aReporterMorph selector.	(self class isOperator: selector)		ifTrue: [ selector := self class operatorAt: selector ifAbsent: [ self error ] ].	^ codeGenerator generateReporter: selector morph: aReporterMorph! !!ScratchBlockParser methodsFor: 'arg generator' stamp: 'EiichiroIto 9/20/2018 18:29'!spriteArgString: aSpriteArgMorph	^ codeGenerator spriteArgString: aSpriteArgMorph evaluate! !!ScratchBlockParser methodsFor: 'arg generator' stamp: 'EiichiroIto 6/18/2018 20:36'!valueString: aMorph	^ aMorph argString: self! !!ScratchBlockParser methodsFor: 'arg generator' stamp: 'EiichiroIto 9/20/2018 18:29'!variableArgString: aVariableMorph	^ codeGenerator variableArgString: aVariableMorph variable.! !!ScratchBytecode class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/13/2018 09:31'!new	self shouldNotImplement.! !!ScratchBytecode methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 16:51'!codeSize	^ 1! !!ScratchBytecode methodsFor: 'testing' stamp: 'EiichiroIto 9/11/2019 21:54'!isCall	^ false! !!ScratchBytecode methodsFor: 'testing' stamp: 'EiichiroIto 9/13/2018 16:54'!isJump	^ false! !!ScratchBytecode methodsFor: 'testing' stamp: 'EiichiroIto 9/13/2018 16:51'!isLabel	^ false! !!ScratchBytecode methodsFor: 'accessing' stamp: 'EiichiroIto 9/22/2018 07:27'!putOn: aStream	"do nothing"! !!ScratchBytecode methodsFor: 'accessing' stamp: 'EiichiroIto 9/10/2019 16:30'!putShort: anInteger on: aStream	| v |	aStream nextPut: #pushShort.	v := anInteger >= 0		ifTrue: [ anInteger ]		ifFalse: [ 16r10000 + anInteger ].	aStream nextPut: (v bitAnd: 16rFF).	v := v >> 8.	aStream nextPut: (v bitAnd: 16rFF).! !!ScratchBytecodeCall class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/11/2019 21:53'!subName: aString	^ self basicNew		initialize;		subName: aString;		yourself! !!ScratchBytecodeCall class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/12/2019 10:03'!subName: aString address: anInteger	^ self basicNew		initialize;		subName: aString;		address: anInteger;		yourself! !!ScratchBytecodeCall methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 21:50'!address	^ address! !!ScratchBytecodeCall methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 21:50'!address: anObject	address := anObject! !!ScratchBytecodeCall methodsFor: 'accessing' stamp: 'EiichiroIto 9/12/2019 08:53'!codeSize	^ 4! !!ScratchBytecodeCall methodsFor: 'testing' stamp: 'EiichiroIto 9/11/2019 21:55'!isCall	^ true! !!ScratchBytecodeCall methodsFor: 'printing' stamp: 'EiichiroIto 9/11/2019 21:57'!printOn: aStream	aStream		nextPutAll: '<call=';		nextPutAll: subName asString;		nextPutAll: ',to=';		nextPutAll: address asString;		nextPut: $>.! !!ScratchBytecodeCall methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 21:57'!putOn: aStream	address ifNil: [ self error ].	self putShort: address on: aStream.	aStream nextPut: #call.! !!ScratchBytecodeCall methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 21:50'!subName	^ subName! !!ScratchBytecodeCall methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 21:50'!subName: anObject	subName := anObject! !!ScratchBytecodeLabel class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/13/2018 09:39'!id: anInteger	^ self basicNew initialize		id: anInteger;		yourself.! !!ScratchBytecodeLabel methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 16:51'!codeSize	^ 0! !!ScratchBytecodeLabel methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 09:39'!id	^ id! !!ScratchBytecodeLabel methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 09:39'!id: anInteger	id := anInteger.! !!ScratchBytecodeLabel methodsFor: 'testing' stamp: 'EiichiroIto 9/13/2018 16:51'!isLabel	^ true! !!ScratchBytecodeLabel methodsFor: 'printing' stamp: 'EiichiroIto 9/15/2018 18:08'!printOn: aStream	aStream		nextPutAll: '<label=';		nextPutAll: id asString;		nextPut: $>.! !!ScratchBytecodeSymbol class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/13/2018 09:30'!selector: aSymbol	^ self basicNew initialize		selector: aSymbol;		yourself.! !!ScratchBytecodeSymbol methodsFor: 'printing' stamp: 'EiichiroIto 9/15/2018 18:08'!printOn: aStream	aStream		nextPutAll: '<symbol=';		nextPutAll: selector asString;		nextPut: $>.! !!ScratchBytecodeSymbol methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 16:57'!putOn: aStream	aStream nextPut: selector.! !!ScratchBytecodeSymbol methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 09:29'!selector	^ selector! !!ScratchBytecodeSymbol methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 09:29'!selector: aSymbol	selector := aSymbol.! !!ScratchBytecodeSymbolWithJump class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/15/2018 18:03'!selector: aSymbol labelId: anInteger	^ self basicNew		initialize;		selector: aSymbol;		labelId: anInteger;		yourself! !!ScratchBytecodeSymbolWithJump methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 16:59'!address	^ address! !!ScratchBytecodeSymbolWithJump methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 16:59'!address: anInteger	address := anInteger.! !!ScratchBytecodeSymbolWithJump methodsFor: 'accessing' stamp: 'EiichiroIto 9/10/2019 16:28'!codeSize	^ 4! !!ScratchBytecodeSymbolWithJump methodsFor: 'testing' stamp: 'EiichiroIto 9/13/2018 16:54'!isJump	^ true! !!ScratchBytecodeSymbolWithJump methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 09:41'!labelId	^ labelId! !!ScratchBytecodeSymbolWithJump methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 09:41'!labelId: anInteger	labelId := anInteger.! !!ScratchBytecodeSymbolWithJump methodsFor: 'printing' stamp: 'EiichiroIto 9/22/2018 07:40'!printOn: aStream	aStream		nextPutAll: '<symbol=';		nextPutAll: selector asString;		nextPutAll: ',id=';		nextPutAll: labelId asString;		nextPutAll: ',jump=';		nextPutAll: address asString;		nextPut: $>.! !!ScratchBytecodeSymbolWithJump methodsFor: 'accessing' stamp: 'EiichiroIto 9/10/2019 16:32'!putOn: aStream	address ifNil: [ self error ].	self putShort: address on: aStream.	aStream nextPut: selector.! !!ScratchBytecodeValue class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/13/2018 16:47'!data: anObject	^ self basicNew		initialize;		data: anObject;		yourself! !!ScratchBytecodeValue methodsFor: 'accessing' stamp: 'EiichiroIto 9/10/2019 15:51'!codeSize	data = false		ifTrue: [ ^ 1 ].	data = true		ifTrue: [ ^ 1 ].	data = 0		ifTrue: [ ^ 1 ].	data = 1		ifTrue: [ ^ 1 ].	(data isInteger and: [ data between: -32768 and: 32767 ])		ifTrue: [ ^ 3 ].	^ 5! !!ScratchBytecodeValue methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 09:28'!data	^ data! !!ScratchBytecodeValue methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2018 09:29'!data: anObject	data := anObject.! !!ScratchBytecodeValue methodsFor: 'printing' stamp: 'EiichiroIto 9/22/2018 07:44'!printOn: aStream	aStream		nextPutAll: '<value=';		nextPutAll: data asString;		nextPut: $>.! !!ScratchBytecodeValue methodsFor: 'private' stamp: 'EiichiroIto 9/10/2019 15:44'!putFloatOn: aStream	| v |	aStream nextPut: #pushFloat.	v := data asFloat asIEEE32BitWord.	aStream nextPut: (v bitAnd: 16rFF).	v := v >> 8.	aStream nextPut: (v bitAnd: 16rFF).	v := v >> 8.	aStream nextPut: (v bitAnd: 16rFF).	v := v >> 8.	aStream nextPut: (v bitAnd: 16rFF).! !!ScratchBytecodeValue methodsFor: 'accessing' stamp: 'EiichiroIto 9/10/2019 15:50'!putOn: aStream	data = false		ifTrue: [ ^ aStream nextPut: #push0 ].	data = true		ifTrue: [ ^ aStream nextPut: #push1 ].	data = 0		ifTrue: [ ^ aStream nextPut: #push0 ].	data = 1		ifTrue: [ ^ aStream nextPut: #push1 ].	(data isInteger and: [ data between: -32768 and: 32767 ])		ifTrue: [ ^ self putShortOn: aStream ].	self putFloatOn: aStream! !!ScratchBytecodeValue methodsFor: 'private' stamp: 'EiichiroIto 9/10/2019 16:30'!putShortOn: aStream	self putShort: data on: aStream! !!ScratchBytecodeGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 20:17'!address	^ address! !!ScratchBytecodeGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 20:17'!address: anInteger	address := anInteger.! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 20:17'!addressOfSubName: aString	subTable ifNil: [ self error ].	^ subTable at: aString! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!and: x with: y	^ self binaryCommand: #and arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:32'!appendCall: aString	stream		nextPut: (ScratchBytecodeCall subName: aString address: (self addressOfSubName: aString))! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:33'!appendLabel: anInteger	stream nextPut: (ScratchBytecodeLabel id: anInteger).! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:33'!appendSymbol: aSymbol	stream nextPut: (ScratchBytecodeSymbol selector: aSymbol).! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:33'!appendSymbol: aSymbol withJump: anInteger	stream nextPut: (ScratchBytecodeSymbolWithJump selector: aSymbol labelId: anInteger).! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:33'!appendValue: anObject	| v |	v := anObject isBlock		ifTrue: [ anObject value ]		ifFalse: [ anObject ].	v ifNil: [ ^ self ].	stream nextPut: (ScratchBytecodeValue data: v).! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 20:17'!binaryCommand: aSymbol arg1: anObject1 arg2: anObject2	self appendValue: anObject1.	self appendValue: anObject2.	self appendSymbol: aSymbol.	^ nil! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!callSub: aString	self appendCall: aString.! !!ScratchBytecodeGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 20:17'!code	| firstPass array out |	firstPass := stream contents.	array := self labelsAndJumpsFor: firstPass.	self resolveJumpAddress: array second using: array first.	out := WriteStream on: Array new.	firstPass do: [ :each | each putOn: out ].	out nextPut: #stop.	^ out contents! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!computeFunction: aSymbol of: x	^ self unaryCommand: aSymbol arg: x! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!divide: x by: y	^ self binaryCommand: #div arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!doIfBegin: cond	| id |	id := labelId newNo.	self appendValue: cond.	self appendSymbol: #jumpIfFalse withJump: id.	^ id! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!doIfElse: orgId	| newId |	newId := labelId newNo.	self appendSymbol: #jump withJump: newId.		self appendLabel: orgId.	^ newId! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!doIfEnd: id	self appendLabel: id.! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!doRepeatBegin: num	| label1 label2 |	label1 := labelId newNo.	label2 := labelId newNo.	self appendValue: num.	self appendLabel: label1.	self appendSymbol: #dup.	self appendValue: 0.	self appendSymbol: #equal.	self appendSymbol: #jumpIfTrue withJump: label2.	^ 	Array with: label1 with: label2! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!doRepeatEndLabels: aCollection	self appendSymbol: #dec.	self appendSymbol: #jump withJump: aCollection first.	self appendLabel: aCollection second.	self appendSymbol: #drop.! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!doUntilBegin	| id |	id := labelId newNo.	self appendLabel: id.	^ id! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!doUntilEnd: cond id: id	self appendValue: cond.	self appendSymbol: #jumpIfFalse withJump: id.! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!equal: x to: y	^ self binaryCommand: #equal arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'sensing ops' stamp: 'EiichiroIto 10/20/2019 20:17'!getId	^ self nullaryCommand: #getId! !!ScratchBytecodeGenerator methodsFor: 'initialization' stamp: 'EiichiroIto 10/20/2019 20:17'!initialize	super initialize.	stream := WriteStream on: Array new.	labelId := BaseId new.	address := 1.! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!is: a between: x and: y	self lessEqual: x than: a.	self lessEqual: a than: y.	self appendSymbol: #and.	^ nil! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 20:17'!labelsAndJumpsFor: aCollection	| labels jumps |	labels := Array new: labelId size.	jumps := OrderedCollection new.	aCollection		do: [ :each | 			each isLabel				ifTrue: [ labels at: each id put: address ].			each isJump				ifTrue: [ jumps add: each ].			address := address + each codeSize ].	^ Array with: labels with: jumps asArray! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!less: x than: y	^ self binaryCommand: #less arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!lessEqual: x than: y	^ self binaryCommand: #lessEqual arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!minus: x with: y	^ self binaryCommand: #minus arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!mod: x by: y	^ self binaryCommand: #mod arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!multiply: x and: y	^ self binaryCommand: #mul arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!not: x	^ self unaryCommand: #not arg: x! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 20:17'!nullaryCommand: aSymbol	self appendSymbol: aSymbol.	^ nil! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!or: x with: y	^ self binaryCommand: #or arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!plus: x and: y	^ self binaryCommand: #plus arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 20:17'!privLabelId	^ labelId! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 20:17'!privStream	^ stream! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!randomFrom: x to: y	^ self binaryCommand: #randomFromTo arg1: x arg2: y! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 20:17'!resolveJumpAddress: aCollection using: anArray	aCollection		do: [ :each | 			each isJump				ifTrue: [ each address: (anArray at: each labelId) ] ].! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!return: anInteger	self unaryCommand: #return arg: anInteger! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!returnValue	^ self nullaryCommand: #returnValue! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!rounded: x	^ self unaryCommand: #rounded arg: x! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!stopAll	self nullaryCommand: #stopAll.! !!ScratchBytecodeGenerator methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 20:17'!stopThread	self nullaryCommand: #stop.! !!ScratchBytecodeGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 20:17'!subTable	^ subTable! !!ScratchBytecodeGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 20:17'!subTable: aDictionary	subTable := aDictionary.! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 20:17'!ternaryCommand: aSymbol arg1: anObject1 arg2: anObject2 arg3: anObject3	self appendValue: anObject1.	self appendValue: anObject2.	self appendValue: anObject3.	self appendSymbol: aSymbol.	^ nil! !!ScratchBytecodeGenerator methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 20:17'!truncated: x	^ self unaryCommand: #truncated arg: x! !!ScratchBytecodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 20:17'!unaryCommand: aSymbol arg: anObject	self appendValue: anObject.	self appendSymbol: aSymbol.	^ nil! !!ScratchCode class methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 19:52'!addCommand: aSymbol	UsedCommands add: aSymbol.! !!ScratchCode class methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 19:52'!clearUsedCommands	"self clearUsedCommands"	UsedCommands := Set new.! !!ScratchCode class methodsFor: 'class initialization' stamp: 'EiichiroIto 10/20/2019 19:52'!initialize	self clearUsedCommands.! !!ScratchCode class methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 19:52'!usedCommands	^ UsedCommands! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!and: x with: y	^ bcGenerator		and: [ x argString: parser ]		with: [ y argString: parser ]! !!ScratchCode methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 19:52'!argString: anArgMorph 	| v |	^ anArgMorph labelMorph		ifNil: [0]		ifNotNil: 			[v := anArgMorph evaluate.			self literalStringFrom: v]! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!broadcast: msg	bcGenerator broadcast: [ msg argString: parser ].! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!callSub: subName	| str |	str := subName choice.	str isEmpty		ifTrue: [ ^ self ].	bcGenerator callSub: str.! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!computeFunction: operator of: num	| op |	op := operator choice.	op = 'e ^'		ifTrue: [ op := 'exp' ].	op = '10 ^'		ifTrue: [ op := 'exp10' ].	^ bcGenerator		computeFunction: op asSymbol		of: [ num argString: parser ]! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!computeFunctionof: aMorph	| op v |	op := aMorph blockArgs first choice asSymbol.	op = 'e ^'		ifTrue: [ op := 'exp' ].	op = '10 ^'		ifTrue: [ op := 'exp10' ].	v := [ aMorph blockArgs second argString: parser ].	^ bcGenerator computeFunction: op asSymbol of: v! !!ScratchCode methodsFor: 'basic ops' stamp: 'EiichiroIto 10/20/2019 21:09'!die	bcGenerator die.! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!divide: x by: y	^ bcGenerator		divide: [ x argString: parser ]		by: [ y argString: parser ]! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!doIfBegin: aMorph	| cond id |	cond := aMorph blockArgs first argString: parser.	id := bcGenerator doIfBegin: cond.	aMorph labelId: id.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!doIfElseBegin: aMorph	self doIfBegin: aMorph.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!doIfElseCenter: aMorph	| orgId newId |	orgId := aMorph labelId.	newId := bcGenerator doIfElse: orgId.	aMorph labelId: newId.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!doIfElseEnd: aMorph	self doIfEnd: aMorph.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!doIfEnd: aMorph	bcGenerator doIfEnd: aMorph labelId.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!doRepeatBegin: aMorph	| num labels |	num := aMorph blockArgs first argString: parser.	labels := bcGenerator doRepeatBegin: num.	aMorph labelId: labels.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!doRepeatEnd: aMorph	bcGenerator doRepeatEndLabels: aMorph labelId.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!doUntilBegin: aMorph	| id |	id := bcGenerator doUntilBegin.	aMorph labelId: id.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!doUntilEnd: aMorph	| cond id |	cond := aMorph blockArgs first argString: parser.	id := aMorph labelId.	bcGenerator doUntilEnd: cond id: id.! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!equal: x to: y	^ bcGenerator		equal: [ x argString: parser ]		to: [ y argString: parser ]! !!ScratchCode methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 21:06'!eventTitleString: aString	^ targetMorph project eventIdFor: aString asSymbol! !!ScratchCode methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 19:52'!expressionArgWithMenuString: aMorph	^ aMorph evaluate! !!ScratchCode methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 19:52'!falseString	^ false! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 10/20/2019 19:52'!generateBegin: aSymbol morph: aMorph	| selector |	selector := aSymbol copyWithout: $:.	selector := (selector, 'Begin:') asSymbol.	self perform: selector with: aMorph.! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 10/20/2019 19:52'!generateCenter: aSymbol morph: aMorph	| selector |	selector := aSymbol copyWithout: $:.	selector := (selector, 'Center:') asSymbol.	self perform: selector with: aMorph.! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 11/28/2019 21:20'!generateCode: aSymbol morph: aMorph	self class addCommand: aSymbol.	SpScratchApp		try: [ self perform: aSymbol withArguments: aMorph blockArgs ]		onFailure: [ aMorph showBalloon: 'error' ]! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 10/20/2019 19:52'!generateEnd: aSymbol morph: aMorph	| selector |	selector := aSymbol copyWithout: $:.	selector := (selector, 'End:') asSymbol.	self perform: selector with: aMorph.! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 10/20/2019 19:52'!generateEventFooter: aString 	bcGenerator stopThread.! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 10/20/2019 19:52'!generateEventHeader: aString	"do nothing"! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 10/20/2019 19:52'!generateIndent: anInteger	"do nothing"! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 10/20/2019 19:52'!generatePass	"do nothing"! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 11/28/2019 21:20'!generateReporter: aSymbol morph: aMorph	| ret |	self class addCommand: aSymbol.	ret := 0.	SpScratchApp		try: [ ret := self				perform: aSymbol asSymbol				withArguments: aMorph blockArgs ]		onFailure: [ aMorph showBalloon: 'error' ].	^ ret! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 10/20/2019 19:52'!generateSubFooter: aString 	bcGenerator return: 0.! !!ScratchCode methodsFor: 'code generator' stamp: 'EiichiroIto 10/20/2019 19:52'!generateSubHeader: aString	"do nothing"! !!ScratchCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 10/20/2019 19:52'!getBreedId	^ bcGenerator getBreedId! !!ScratchCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 10/20/2019 19:52'!getId	^ bcGenerator getId! !!ScratchCode methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 19:52'!indentLevelFor: aString 	^ 0! !!ScratchCode methodsFor: 'initialization' stamp: 'EiichiroIto 10/20/2019 19:58'!initialize	super initialize.	parser := ScratchBlockParser codeGenerator: self.! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!is: x between: from and: to	^ bcGenerator		is: [ x argString: parser ]		between: [ from argString: parser ]		and: [ to argString: parser ]! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!less: x than: y	^ bcGenerator		less: [ x argString: parser ]		than: [ y argString: parser ]! !!ScratchCode methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 19:52'!literalStringFrom: anObject	anObject isString		ifTrue: [ ^ anObject asNumberNoError ].	anObject isNumber		ifTrue: [ ^ anObject ].	^ 0! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!minus: x with: y	^ bcGenerator		minus: [ x argString: parser ]		with: [ y argString: parser ]! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!mod: x by: y	^ bcGenerator		mod: [ x argString: parser ]		by: [ y argString: parser ]! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!more: x than: y	^ bcGenerator		less: [ y argString: parser ]		than: [ x argString: parser ]! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!multiply: x and: y	^ bcGenerator		multiply: [ x argString: parser ]		and: [ y argString: parser ]! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 11/12/2019 15:15'!negated: x	^ bcGenerator minus: 0 with: [ x argString: parser ]! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!not: x	^ bcGenerator not: (x argString: parser)! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!or: x with: y	^ bcGenerator		or: [ x argString: parser ]		with: [ y argString: parser ]! !!ScratchCode methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 19:52'!parse: aTopBlock target: aMorph	targetMorph := aMorph.	parser parseBlock: aTopBlock.	^ bcGenerator code.! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!plus: x and: y	^ bcGenerator plus: [ x argString: parser ] and: [ y argString: parser ]! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!randomFrom: a to: b	^ bcGenerator		randomFrom: [ a argString: parser ]		to: [ b argString: parser ]! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!return: num	bcGenerator return: [ num argString: parser ].! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!returnValue	^ bcGenerator returnValue! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!rounded: x	^ bcGenerator rounded: (x argString: parser)! !!ScratchCode methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 11:25'!spriteArgString: aMorph	^ aMorph breedNo! !!ScratchCode methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 19:52'!startAddress: anInteger	bcGenerator address: anInteger.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!stopAll	bcGenerator stopAll.! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 10/20/2019 19:52'!stopThread	bcGenerator stopThread.! !!ScratchCode methodsFor: 'accessing' stamp: 'EiichiroIto 10/20/2019 19:52'!subTable: aDictionary	bcGenerator subTable: aDictionary.! !!ScratchCode methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/20/2019 19:52'!truncated: x	^ bcGenerator truncated: (x argString: parser)! !!ScratchCode methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 19:52'!variableArgString: aString	| v |	v := [ targetMorph varId varNoFor: aString ] ifError: [ nil ].	v ifNil: [ ^ 0 ].	^ bcGenerator getVar: v! !!ScratchDirectory class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 10:01'!current	^ Current ifNil: [ Current := self new ]! !!ScratchDirectory class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:56'!reset	Current := nil! !!ScratchDirectory methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:54'!appName	^ appName! !!ScratchDirectory methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:55'!appName: aString	appName := aString! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 10:01'!computer	^ FileLocator root asFileReference! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 10:01'!desktop	^ FileLocator desktop asFileReference! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 10:01'!examples	| dir |	dir := FileSystem workingDirectory / 'Examples'.	dir isDirectory		ifFalse: [ dir := FileSystem workingDirectory ].	^ dir! !!ScratchDirectory methodsFor: 'accessing' stamp: 'EiichiroIto 11/27/2019 20:56'!getDefaultFolderForType: aSymbol	(#(project export) includes: aSymbol)		ifTrue: [ ^ self project ].	^ self user! !!ScratchDirectory methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 10:06'!getLastFolderForType: aSymbol	| dir |	dir := lastDirectories at: aSymbol ifAbsent: [ nil ].	(dir notNil and: [ dir isDirectory ])		ifTrue: [ ^ dir ].	^ self getDefaultFolderForType: aSymbol! !!ScratchDirectory methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 10:06'!initialize	appName := nil.	lastDirectories := Dictionary new.	homeDirectory := nil! !!ScratchDirectory methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:57'!lastFolderIsSampleProjectsFolder	| lastDirPath sampleProjectDirPath |	lastDirPath := (self getLastFolderForType: #project) pathString.	sampleProjectDirPath := self examples pathString.	^ lastDirPath beginsWith: sampleProjectDirPath! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 20:38'!privHomeDirectory	^ homeDirectory! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 20:39'!privHomeDirectory: aFileReference	homeDirectory := aFileReference! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 20:38'!privLastDirectories	^ lastDirectories! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 20:55'!project	^ self projectFor: self appName! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 20:55'!projectFor: aString	| dir |	aString ifNil: [ ^ FileSystem workingDirectory ].	dir := FileLocator documents asFileReference / aString.	dir exists		ifFalse: [ dir createDirectory ].	dir isDirectory		ifFalse: [ dir := FileSystem workingDirectory ].	^ dir! !!ScratchDirectory methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 10:04'!setHomeDir: aFileReference	homeDirectory := aFileReference asFileReference! !!ScratchDirectory methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 10:05'!setLastFolderTo: aFileReference forType: aSymbol	lastDirectories at: aSymbol put: aFileReference! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 10:05'!user	^ homeDirectory ifNil: [ FileLocator documents asFileReference ]! !!ScratchExporter methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 22:25'!exportFrom: anApplication	| project |	project := anApplication project.	stream := WriteStream on: ''.	self writeHeader: project.	self writeScripts: project scripts.	self writeFooter: project.	^ stream contents! !!ScratchExporter methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 22:26'!exportScript: aMorph	stream := WriteStream on: ''.	self writeScript: aMorph.	^ stream contents! !!ScratchExporter methodsFor: 'private' stamp: 'EiichiroIto 4/9/2019 07:59'!privStream	^ stream! !!ScratchExporter methodsFor: 'private' stamp: 'EiichiroIto 4/9/2019 19:22'!privStream: aStream	stream := aStream.! !!ScratchExporter methodsFor: 'private' stamp: 'EiichiroIto 8/5/2019 20:55'!writeFooter: aMorph	self subclassResponsibility! !!ScratchExporter methodsFor: 'private' stamp: 'EiichiroIto 8/5/2019 20:55'!writeHeader: aMorph	self subclassResponsibility! !!ScratchExporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:24'!writeScript: aMorph	self subclassResponsibility.! !!ScratchExporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:25'!writeScripts: aCollection	aCollection do: [ :each | self writeScript: each ].! !!ScratchSexpExporter class methodsFor: 'instance creation' stamp: 'EiichiroIto 10/25/2019 12:31'!appName: aString	^ self basicNew		initialize;		appName: aString;		yourself! !!ScratchSexpExporter class methodsFor: 'instance creation' stamp: 'EiichiroIto 10/25/2019 12:32'!new	self shouldNotImplement! !!ScratchSexpExporter methodsFor: 'accessing' stamp: 'EiichiroIto 10/25/2019 12:29'!appName	^ appName! !!ScratchSexpExporter methodsFor: 'accessing' stamp: 'EiichiroIto 10/25/2019 12:29'!appName: anObject	appName := anObject! !!ScratchSexpExporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:23'!writeFooter: aProject	stream nextPutAll: '))'.! !!ScratchSexpExporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:22'!writeHeader: aProject	stream		nextPut: $(;		nextPutAll: appName;		nextPutAll: ' ('.	aProject scripts		do: [ :each | stream nextPutAll: each objName ]		separatedBy: [ stream nextPut: Character space ].	stream nextPut: $).	stream nextPut: Character lf.	stream nextPut: $(! !!ScratchSexpExporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:24'!writeScript: aScript	| code |	stream		nextPutAll: '(for ';		nextPutAll: aScript objName;		nextPut: Character space;		nextPut: $(.	aScript varNames		do: [ :each | stream nextPutAll: (SexpLexer quotedString: each) ]		separatedBy: [ stream nextPut: Character space ].	stream		nextPut: $);		nextPut: Character lf;		nextPut: $(.	aScript subBlocks		do: [ :each | 			code := ScratchSexpGenerator new parse: each target: aScript.			stream nextPutAll: code ].	aScript eventBlocks		do: [ :each | 			code := ScratchSexpGenerator new parse: each target: aScript.			stream nextPutAll: code ].	stream		nextPutAll: '))';		nextPut: Character lf! !!ScratchImporter methodsFor: 'acccessing' stamp: 'EiichiroIto 8/6/2019 10:54'!import: aString to: aMorph	self subclassResponsibility.! !!ScratchSexpImporter class methodsFor: 'instance creation' stamp: 'EiichiroIto 10/25/2019 12:32'!appName: aString	^ self basicNew		initialize;		appName: aString;		yourself! !!ScratchSexpImporter class methodsFor: 'instance creation' stamp: 'EiichiroIto 10/25/2019 12:32'!new	self shouldNotImplement! !!ScratchSexpImporter methodsFor: 'accessing' stamp: 'EiichiroIto 10/25/2019 12:29'!appName	^ appName! !!ScratchSexpImporter methodsFor: 'accessing' stamp: 'EiichiroIto 10/25/2019 12:29'!appName: anObject	appName := anObject! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 8/3/2019 15:55'!cBlockTupleFrom: anArray	| tuple innerBlock |	tuple := anArray copy.	tuple at: 1 put: (tuple at: 1) asSymbol.	2 to: tuple size - 1 do: [ :each | 		| arg |		arg := tuple at: each.		arg isArray			ifTrue: [ arg := self tupleFrom: arg.				tuple at: each put: arg ] ].	innerBlock := tuple at: tuple size.	innerBlock := innerBlock isEmpty		ifTrue: [ nil ]		ifFalse: [ innerBlock collect: [ :each | self tupleFrom: each ] ].	tuple at: tuple size put: innerBlock.	^ tuple! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 8/6/2019 15:32'!evaluateArg: anObject	anObject isArray		ifTrue: [ ^ self tupleFrom: anObject ]		ifFalse: [ anObject isString				ifTrue: [ anObject isNumberString						ifTrue: [ ^ anObject asNumberNoError ] ] ].	^ anObject! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 9/12/2019 13:11'!eventBlockTupleFor: aString	^ { #EventHatMorph. aString }! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 8/3/2019 15:32'!getVarTupleFrom: aCollection	^ {#readVariable.	aCollection second}! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 8/3/2019 15:49'!ifElseTupleFrom: anArray	| cond trueBlock falseBlock |	cond := self tupleFrom: anArray second.	trueBlock := anArray third.	trueBlock := trueBlock isEmpty		ifTrue: [ nil ]		ifFalse: [ trueBlock collect: [ :each | self tupleFrom: each ] ].	falseBlock := anArray fourth.	falseBlock := falseBlock isEmpty		ifTrue: [ nil ]		ifFalse: [ falseBlock collect: [ :each | self tupleFrom: each ] ].	^ {anArray first asSymbol.	cond.	trueBlock.	falseBlock}! !!ScratchSexpImporter methodsFor: 'acccessing' stamp: 'EiichiroIto 11/23/2019 22:32'!import: aString to: anApplication	| lex list |	project := anApplication project.	lex := SexpLexer new read: aString.	list := SexpParser new parse: lex.	self importWorld: list.! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:32'!importEvent: aCollection for: aScript eventName: aString	| block prev tuple |	prev := aScript blocksBin.	tuple := self eventBlockTupleFor: aString.	block := aScript hatBlockFromTuple: tuple receiver: aScript.	prev addMorph: block.	prev := block.	aCollection		do: [ :each | 			tuple := self tupleFrom: each.			block := aScript blockFromTuple: tuple receiver: aScript.			prev nextBlock: block.			prev := block ]! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:36'!importScripts: aCollection	| script |	aCollection		do: [ :each | 			each first = 'for'				ifTrue: [ script := project findObjName: each second.					each third do: [ :v | script addVariable: v ].					self importScripts: each fourth for: script ] ]! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:33'!importScripts: aCollection for: aScript	aCollection		do: [ :each | 			each first = 'when'				ifTrue: [ self importEvent: each third for: aScript eventName: each second ].			each first = 'sub'				ifTrue: [ self importSub: each third for: aScript subName: each second ]].	aScript cleanUp! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:35'!importSub: aCollection for: aScript subName: aString	| block prev tuple |	prev := aScript blocksBin.	tuple := self subBlockTupleFor: aString.	block := aScript hatBlockFromTuple: tuple receiver: aScript.	prev addMorph: block.	prev := block.	aCollection		do: [ :each | 			tuple := self tupleFrom: each.			block := aScript blockFromTuple: tuple receiver: aScript.			prev nextBlock: block.			prev := block ]! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 22:36'!importWorld: aCollection	aCollection first = appName		ifFalse: [ self error ].	aCollection second do: [ :each | project assureExistsBreed: each ].	self importScripts: aCollection third! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 10/19/2019 19:05'!operatorTupleFrom: aCollection	| selector tuple |	selector := ScratchBlockParser				invOperatorAt: aCollection first asSymbol				ifAbsent: [ self error ].	tuple := aCollection copy.	tuple at: 1 put: selector.	self updateArgs: tuple.	^ tuple! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 8/6/2019 15:36'!setVarTupleFrom: aCollection	| arg |	arg := aCollection third.	arg := self evaluateArg: arg.	^ {#changeVariable.	aCollection second.	aCollection first asSymbol.	arg}! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 9/12/2019 13:13'!subBlockTupleFor: aString	^ { #SubHatMorph. aString }! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 10/19/2019 19:05'!tupleFrom: aCollection	| selector tuple |	selector := aCollection first asSymbol.	(ScratchBlockParser isInvOperator: selector)		ifTrue: [ ^ self operatorTupleFrom: aCollection ].	selector = #getVar		ifTrue: [ ^ self getVarTupleFrom: aCollection ].	(#(setVar:to: changeVar:by:) includes: selector)		ifTrue: [ ^ self setVarTupleFrom: aCollection ].	selector = #doIfElse		ifTrue: [ ^ self ifElseTupleFrom: aCollection ].	(#(doIf doRepeat) includes: selector)		ifTrue: [ ^ self cBlockTupleFrom: aCollection ].	tuple := aCollection copy.	self updateArgs: tuple.	^ tuple! !!ScratchSexpImporter methodsFor: 'private' stamp: 'EiichiroIto 8/6/2019 15:32'!updateArgs: anArray	anArray at: 1 put: (anArray at: 1) asSymbol.	2 to: anArray size do: [ :each | 		| arg |		arg := anArray at: each.		arg := self evaluateArg: arg.		anArray at: each put: arg ]! !!ScratchNativeThread class methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 17:10'!cachedSymbols	cachedSymbols ifNil: [ self setupCachedSymbols ].	^ cachedSymbols! !!ScratchNativeThread class methodsFor: 'acccessing' stamp: 'EiichiroIto 11/19/2019 17:10'!indexOfSymbol: aSymbol	^ (self cachedSymbols indexOf: aSymbol) - 1! !!ScratchNativeThread class methodsFor: 'class initialization' stamp: 'EiichiroIto 10/22/2019 08:52'!initialize	"self initialize."	self setupCachedSymbols.	self setupOpTable.! !!ScratchNativeThread class methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!setupCachedSymbols	cachedSymbols := #(#push0 #push1 #pushShort #pushFloat) , self symbols! !!ScratchNativeThread class methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!setupOpTable	OpTable := Array new: cachedSymbols size.	cachedSymbols		withIndexDo: [ :each :index | OpTable at: index put: each ].! !!ScratchNativeThread class methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 13:41'!symbols	| list |	list := self allMethods.	list := list select: [ :each | each category endsWith: 'ops' ].	list := list collect: #selector.	^ list sort! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!abs	| x |	x := self pop.	self push: x abs.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!acos	| x |	x := self pop.	self push: (x min: 1.0 max: -1.0) arcCos radiansToDegrees.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!and	| x y |	x := self pop.	y := self pop.	self push: x & y.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!asin	| x |	x := self pop.	self push: (x min: 1.0 max: -1.0) arcSin radiansToDegrees.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!atan	| x |	x := self pop.	self push: (x min: 1.0 max: -1.0) arcTan radiansToDegrees.! !!ScratchNativeThread methodsFor: 'control ops' stamp: 'EiichiroIto 10/22/2019 08:52'!call	| address |	address := self pop.	self push: pc.	pc := address.! !!ScratchNativeThread methodsFor: 'accessing' stamp: 'EiichiroIto 10/22/2019 08:52'!codes	^ codes! !!ScratchNativeThread methodsFor: 'accessing' stamp: 'EiichiroIto 10/22/2019 08:52'!codes: anObject	codes := anObject! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!cos	| x |	x := self pop.	self push: x degreesToRadians cos.! !!ScratchNativeThread methodsFor: 'misc ops' stamp: 'EiichiroIto 10/22/2019 08:52'!dec	| v |	v := self pop.	self push: v - 1.! !!ScratchNativeThread methodsFor: 'misc ops' stamp: 'EiichiroIto 10/22/2019 08:52'!direction	| x y d |	y := self pop.	x := self pop.	d := (x closeTo: 0)		ifTrue: [ y < 0				ifTrue: [ -90 ]				ifFalse: [ 90 ] ]		ifFalse: [ (x @ y) degrees ].	self push: d.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!div	| x y |	y := self pop.	x := self pop.	(y closeTo: 0)		ifTrue: [ ^ self errorOccuered ].	self push: (x / y) asFloat.! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!doOneCycle	| code |	isRunning := true.	[ pc > codes size		ifTrue: [ ^ self error ].	code := codes at: pc.	pc := pc + 1.	self perform: code.	isRunning ] whileTrue.	^ false! !!ScratchNativeThread methodsFor: 'misc ops' stamp: 'EiichiroIto 10/22/2019 08:52'!drop	self pop.! !!ScratchNativeThread methodsFor: 'misc ops' stamp: 'EiichiroIto 10/22/2019 08:52'!dup	| v |	v := self pop.	self push: v.	self push: v.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!equal	| x y |	y := self pop.	x := self pop.	self push: (x closeTo: y).! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!errorOccuered	self stopAll.! !!ScratchNativeThread methodsFor: 'accessing' stamp: 'EiichiroIto 10/22/2019 08:52'!evaluate: anInteger	self pc: anInteger.	[ self doOneCycle ] whileTrue.	^ self pop! !!ScratchNativeThread methodsFor: 'accessing' stamp: 'EiichiroIto 10/22/2019 08:52'!execute: anInteger	self pc: anInteger.	[ self doOneCycle ] whileTrue.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!exp	| x |	x := self pop.	self push: x exp.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!exp10	| x |	x := self pop.	self push: (10.0 raisedTo: x).! !!ScratchNativeThread methodsFor: 'variable ops' stamp: 'EiichiroIto 10/22/2019 08:52'!getId	self push: id.! !!ScratchNativeThread methodsFor: 'initialization' stamp: 'EiichiroIto 10/22/2019 08:52'!initialize	super initialize.	stack := OrderedCollection new.	pc := 1.	isRunning := false.	isTerminated := false.	retVal := 0.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!inv	| x |	x := self pop.	self push: (x bitXor: 16rFFFF).! !!ScratchNativeThread methodsFor: 'testing' stamp: 'EiichiroIto 10/22/2019 08:52'!isRunning	^ isRunning! !!ScratchNativeThread methodsFor: 'testing' stamp: 'EiichiroIto 10/22/2019 08:52'!isTerminated	^ isTerminated! !!ScratchNativeThread methodsFor: 'control ops' stamp: 'EiichiroIto 10/22/2019 08:52'!jump	| address |	address := self pop.	pc := address.! !!ScratchNativeThread methodsFor: 'control ops' stamp: 'EiichiroIto 10/22/2019 08:52'!jumpIfFalse	| address cond |	address := self pop.	cond := self pop.	cond = 0		ifTrue: [ pc := address ].! !!ScratchNativeThread methodsFor: 'control ops' stamp: 'EiichiroIto 10/22/2019 08:52'!jumpIfTrue	| address cond |	address := self pop.	cond := self pop.	cond = 0		ifFalse: [ pc := address ].! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!less	| x y |	y := self pop.	x := self pop.	self push: (x < y).! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!lessEqual	| x y |	y := self pop.	x := self pop.	self push: (x <= y).! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!ln	| x |	x := self pop.	self push: x ln.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!log	| x |	x := self pop.	self push: x log.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!minus	| x y |	y := self pop.	x := self pop.	self push: x - y.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!mod	| x y |	y := self pop.	x := self pop.	self push: x \\ y.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!mul	| x y |	y := self pop.	x := self pop.	self push: x * y.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!not	| x |	x := self pop.	self push: (x bitXor: 1).! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!or	| x y |	x := self pop.	y := self pop.	self push: x | y.! !!ScratchNativeThread methodsFor: 'accessing' stamp: 'EiichiroIto 10/22/2019 08:52'!pc	^ pc! !!ScratchNativeThread methodsFor: 'accessing' stamp: 'EiichiroIto 10/22/2019 08:52'!pc: anInteger	pc := anInteger.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!plus	| x y |	y := self pop.	x := self pop.	self push: x + y.! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!pop	^ stack removeLast! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!privId	^ id! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!privId: anInteger	id := anInteger! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!privIsRunning: aBoolean	isRunning := aBoolean.! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!privIsTerminated: aBoolean	isTerminated := aBoolean.! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!privRetVal: anInteger	retVal := anInteger.! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!push0	self push: 0.! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!push1	self push: 1.! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!push: anObject	| x |	x := anObject.	x = true		ifTrue: [ x := 1 ].	x = false		ifTrue: [ x := 0 ].	stack add: x.! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!pushFloat	| v |	v := codes at: pc.	pc := pc + 1.	v := (codes at: pc) * 16r100 + v.	pc := pc + 1.	v := (codes at: pc) * 16r10000 + v.	pc := pc + 1.	v := (codes at: pc) * 16r1000000 + v.	pc := pc + 1.	v := Float fromIEEE32Bit: v.	self push: v! !!ScratchNativeThread methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 08:52'!pushShort	| v |	v := codes at: pc.	pc := pc + 1.	v := (codes at: pc) * 16r100 + v.	pc := pc + 1.	v >= 16r8000		ifTrue: [ v := v - 16r10000 ].	^ self push: v! !!ScratchNativeThread methodsFor: 'misc ops' stamp: 'EiichiroIto 10/22/2019 08:52'!randomFromTo	| to from result |	to := self pop.	from := self pop.	result := (from to: to) atRandom.	self push: result.! !!ScratchNativeThread methodsFor: 'accessing' stamp: 'EiichiroIto 10/22/2019 08:52'!retVal	^ retVal! !!ScratchNativeThread methodsFor: 'control ops' stamp: 'EiichiroIto 10/22/2019 08:52'!return	retVal := self pop.	pc := self pop.! !!ScratchNativeThread methodsFor: 'control ops' stamp: 'EiichiroIto 10/22/2019 08:52'!returnValue	self push: retVal.! !!ScratchNativeThread methodsFor: 'misc ops' stamp: 'EiichiroIto 11/9/2019 18:44'!rot	| x1 x2 x3 |	x1 := self pop.	x2 := self pop.	x3 := self pop.	self push: x2.	self push: x1.	self push: x3! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!rounded	| x |	x := self pop.	self push: x rounded.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!sin	| x |	x := self pop.	self push: x degreesToRadians sin.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!sqrt	| x |	x := self pop.	x < 0		ifTrue: [ ^ self errorOccuered ].	self push: x sqrt.! !!ScratchNativeThread methodsFor: 'accessing' stamp: 'EiichiroIto 10/22/2019 08:52'!stack	^ stack! !!ScratchNativeThread methodsFor: 'control ops' stamp: 'EiichiroIto 10/22/2019 08:52'!stop	isRunning := false.! !!ScratchNativeThread methodsFor: 'control ops' stamp: 'EiichiroIto 10/22/2019 08:52'!stopAll	isRunning := false.	isTerminated := true.! !!ScratchNativeThread methodsFor: 'misc ops' stamp: 'EiichiroIto 10/22/2019 08:52'!swap	| x y |	x := self pop.	y := self pop.	self push: x.	self push: y.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!tan	| x |	x := self pop.	self push: x degreesToRadians tan.! !!ScratchNativeThread methodsFor: 'arithmetic ops' stamp: 'EiichiroIto 10/22/2019 08:52'!truncated	| x |	x := self pop.	self push: x truncated.! !!ScratchProject class methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:19'!appVersion	self subclassResponsibility! !!ScratchProject class methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:19'!appVersionTag	self subclassResponsibility! !!ScratchProject methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:24'!addScript: aScript	scripts := scripts copyWith: aScript! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:01'!allEventNames	"Answer a list of all events that have been defined in this project."	| result |	result := Set new: 100.	self scripts do: [ :m | m addEventNamesTo: result ].	result remove: '' ifAbsent: [  ].	^ result asArray sort! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:24'!appVersion	^ self class appVersion! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:24'!application	^ application! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:24'!application: anApplication	application := anApplication! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:25'!author	^ info at: #author ifAbsent: [ '' ]! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:22'!author: aString	^ info at: #author put: aString! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:15'!comment	^ info at: 'comment' ifAbsent: [ '' ]! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:15'!comment: aString	info at: 'comment' put: aString asString! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:01'!defaultEventName	| evtNames |	evtNames := self allEventNames.	^ evtNames isEmpty		ifTrue: [ '' ]		ifFalse: [ evtNames first ]! !!ScratchProject methodsFor: 'file read/write' stamp: 'EiichiroIto 11/23/2019 23:23'!extractInfoFrom: aByteArray	| s version |	s := ReadStream on: aByteArray.	version := ObjStream fileVersion: self class from: s.	version = 1		ifFalse: [ ^ self error: 'Invalid version' ].	s skip: 4.	info := self newObjStream readObjFrom: s showProgress: false! !!ScratchProject methodsFor: 'file read/write' stamp: 'EiichiroIto 11/23/2019 23:23'!extractProjectFrom: aByteArray	| s version proj |	s := ReadStream on: aByteArray.	version := ObjStream fileVersion: self class from: s.	version = 1		ifFalse: [ ^ self error: 'Invalid version' ].	s skip: s uint32.	proj := self newObjStream readObjFrom: s showProgress: true.	proj isProject		ifFalse: [ ^ self error: 'Invalid project format :', proj class asString ].	ScratchScript buildBlockSpecDictionary.	proj scripts		do: [ :m | 			m convertStacksToTuples.			m convertTuplesToStacks.			m project: proj ].	^ proj! !!ScratchProject methodsFor: 'object i/o' stamp: 'EiichiroIto 11/23/2019 20:57'!fieldsVersion	^ 1! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:25'!findObjName: aString	^ self scripts detect: [ :each | each objName = aString ]! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 20:49'!getScratchInfoFrom: aFileReference	| result f version buf |	result := Dictionary new.	SpScratchApp		try: [ f := aFileReference binaryReadStream.			version := ObjStream fileVersion: self class from: f.			version = 1				ifFalse: [ self error: 'invalid version' ].			buf := f next: f uint32.			result := ObjStream new readObjFrom: (ReadStream on: buf).			f close ]		onFailure: [ ^ nil ].	^ result! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:26'!info	^ info! !!ScratchProject methodsFor: 'object i/o' stamp: 'EiichiroIto 11/23/2019 20:57'!initFieldsFrom: anObjStream version: classVersion	self		initFieldsNamed: #(scripts info)		from: anObjStream! !!ScratchProject methodsFor: 'initialization' stamp: 'EiichiroIto 11/23/2019 20:26'!initialize	info := Dictionary new.	scripts := Array new.	modified := true! !!ScratchProject methodsFor: 'testing' stamp: 'EiichiroIto 11/23/2019 20:26'!isEmpty	^ true! !!ScratchProject methodsFor: 'testing' stamp: 'EiichiroIto 11/23/2019 20:24'!isProject	^ true! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:26'!modified	^ modified! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:26'!modified: aBoolean	modified := aBoolean! !!ScratchProject methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 23:21'!newObjStream	self subclassResponsibility! !!ScratchProject methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 21:00'!newProgram	self subclassResponsibility! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:59'!programOf: aDictionary	| program |	program := self newProgram.	self scripts		do: [ :each | each setupProgram: program events: aDictionary ].	^ program! !!ScratchProject methodsFor: 'file read/write' stamp: 'EiichiroIto 11/28/2019 21:22'!readProjectFrom: aFileReference	| f projData newProj |	f := aFileReference binaryReadStream.	f		ifNil: [ UIManager default				alert: aFileReference pathString				title: 'Could not read' localized.			^ nil ].	SpScratchApp		try: [ projData := f contents.			newProj := self extractProjectFrom: projData.			newProj extractInfoFrom: projData ]		onFailure: [ :err :rcvr | 			UIManager default				alert: err				title: 'Could not read project; file may be damaged'.			^ nil ].	^ newProj! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:55'!scripts	^ scripts! !!ScratchProject methodsFor: 'object i/o' stamp: 'EiichiroIto 11/23/2019 20:58'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(scripts info) on: anObjStream.! !!ScratchProject methodsFor: 'file read/write' stamp: 'EiichiroIto 11/23/2019 23:24'!storeProjectInfoOn: aBinaryStream	| s |	s := WriteStream on: (ByteArray new: 100000).	self newObjStream storeObj: info on: s.	aBinaryStream uint32: s size.	aBinaryStream nextPutAll: s contents! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:57'!thumbnailForm: aForm	info at: 'thumbnail' put: aForm! !!ScratchProject methodsFor: 'file read/write' stamp: 'EiichiroIto 11/23/2019 20:56'!unusedNameStartingWith: prefix in: aFileReference	| usedNames i result |	usedNames := (aFileReference entries		collect: [ :each | each basename ]) asSet.	i := 0.	result := prefix , '0'.	[ usedNames includes: result ]		whileTrue: [ result := prefix , (i := i + 1) printString ].	^ aFileReference / result! !!ScratchProject methodsFor: 'file read/write' stamp: 'EiichiroIto 11/23/2019 23:24'!writeProjectAs: aFileReference	| saveError out tmpFile |	ScratchScript buildBlockSpecDictionary.	self scripts		do: [ :m | 			m blocksBin				allMorphsDo: [ :b | 					b isBlockMorph						ifTrue: [ b stop ] ].			m convertStacksToTuples ].	saveError := nil.	tmpFile := (self		unusedNameStartingWith: 'tmp'		in: aFileReference parent) asFileReference.	[ out := tmpFile binaryWriteStream.	out		ifNil: [ saveError := 'Folder may be locked or read-only' ]		ifNotNil: [ out nextPutAll: self appVersion asByteArray.			self storeProjectInfoOn: out.			self newObjStream storeObj: self on: out.			out close ] ]		ifError: [ :err :rcvr | 			out				ifNotNil: [ [ out close.					tmpFile delete ] ifError: [  ] ].			saveError := err ].	self scripts do: [ :m | m convertTuplesToStacks ].	saveError		ifNotNil: [ UIManager default alert: saveError title: 'Save failed'.			^ false ].	aFileReference deleteIfAbsent: [  ].	[ tmpFile renameTo: aFileReference basename ]		ifError: [ UIManager default				alert: 'Is the folder read-only?' localized				title: 'Save failed'.			^ false ].	^ true! !!ScTestScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/30/2019 08:26'!objName	^ 'test'! !!ScTestScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/30/2019 08:29'!varNames	^ #(a 'b c')! !!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/23/2019 21:24'!allBlockSpecs	| stream |	stream := WriteStream on: Array new.	self allSubclassesDo: [ :each | stream nextPutAll: each blockSpecs ].	^ stream contents! !!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/23/2019 21:24'!blockColorAt: aSymbol	^ self blockColorDict at: aSymbol ifAbsent: [Color red].! !!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/23/2019 21:25'!blockColorDict	BlockColorDict ifNil: [ self buildBlockSpecDictionary ].	^ BlockColorDict! !!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/23/2019 21:25'!blockColorFor: aCategory	'control' = aCategory		ifTrue: [ ^ Color h: 41 s: 0.85 v: 0.9 ].	'basic' = aCategory		ifTrue: [ ^ Color h: 225 s: 0.65 v: 0.83 ].	'motor' = aCategory		ifTrue: [ ^ Color h: 220 s: 0.85 v: 0.725 ].	'color' = aCategory		ifTrue: [ ^ Color h: 264 s: 0.62 v: 0.89 ].	'misc' = aCategory		ifTrue: [ ^ Color h: 165 s: 1 v: 0.63 ].	'operators' = aCategory		ifTrue: [ ^ Color h: 93 s: 0.9 v: 0.76 ].	'patch' = aCategory		ifTrue: [ ^ Color h: 296 s: 0.66 v: 0.85 ].	'sensing' = aCategory		ifTrue: [ ^ Color h: 200 s: 0.98 v: 0.86 ].	'variables' = aCategory		ifTrue: [ ^ Color h: 25 s: 0.88 v: 0.95 ].	"'list' = aCategory ifTrue: [^ ListBlockColor]."	^ Color h: 0 s: 0.81 v: 0.83! !!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/23/2019 21:25'!blockSpecAt: aSymbol	^ self blockSpecDict at: aSymbol ifAbsent: [nil].! !!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/23/2019 21:25'!blockSpecDict	BlockSpecDict ifNil: [ self buildBlockSpecDictionary ].	^ BlockSpecDict! !!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/23/2019 21:27'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	| blocks |	blocks := #(		'control'			('when loop'					L	-)			('when I receive %e'		E	-)			-			('repeat %n'					c	doRepeat 10)			-			('broadcast %e'				-	broadcast:)			('call %S'						-	callSub: '')			-			('if %b'							c	doIf)			('if %b'							c	doIfElse)			('repeat until %b'			c	doUntil)			-			('return %n'					-	return: 0)			('stop script'					-	stopThread)			('stop all'						-	stopAll)		'operators'			('%n + %n'						r	+ - -)			('%n - %n'						r	- - -)			('%n * %n'						r	* - -)			('%n / %n'						r	/ - -)			('- %n'								r	negated: 1)			-			('pick random %n to %n'		r	randomFrom:to: 1 10)			-			('%s < %s'						b	< '' '')			('%s = %s'						b	= '' '')			('%s > %s'						b	> '' '')			('%n between %n and %n'	b is:between:and: 50 0 100)			-			('%b and %b'					b	&)			('%b or %b'						b	|)			('not %b'							b	not)			-			('%n mod %n'					r	\\ - -)			('round %n'						r	rounded -)			('truncate %n'					r	truncated -)			-			('%f of %n'						r	computeFunction:of: 'sqrt' 10)		'sensing'			('return value'				r	returnValue)	).	^ blocks! !!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/23/2019 21:25'!blockSpecsForTranslation	"Answer a collection blocks for translation. Obsolete blocks are removed."	| allSpecs |	allSpecs := Set new.	self allBlockSpecs		do: [ :el | 			el isArray				ifTrue: [ allSpecs add: el first ]				ifFalse: [ ((el beginsWith: 'obsolete') or: [ #('-' '~') includes: el ])						ifFalse: [ allSpecs add: el ] ] ].	allSpecs		add: 'else';		add: 'variables';		add: 'set %v to %n';		add: 'change %v by %n'.	^ allSpecs asArray sort! !!ScratchScript class methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 21:26'!buildBlockSpecDictionary	"self buildBlockSpecDictionary"	| blockColor sel |	BlockSpecDict := IdentityDictionary new: 250.	BlockColorDict := IdentityDictionary new: 250.	self		withAllSubclassesDo: [ :cl | 			blockColor := Color blue.			cl blockSpecs				do: [ :spec | 					(spec isString and: [ spec size > 1 ])						ifTrue:							[ blockColor := self blockColorFor: spec ].					spec isArray						ifTrue: [ sel := spec at: 3.							BlockSpecDict at: sel put: spec.							BlockColorDict at: sel put: blockColor ] ] ]! !!ScratchScript class methodsFor: 'class initialization' stamp: 'EiichiroIto 11/24/2019 22:03'!initialize	"ScratchScript initialize"	self buildBlockSpecDictionary! !!ScratchScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:30'!addEventNamesTo: aSet	"Add the names of all events implemented by this morph, excluding keyboard events. Suppress duplicates (ignoring case differences)."	blocksBin isMorph		ifFalse: [ ^ self ].	blocksBin		allMorphsDo: [ :m | 			m class = EventTitleMorph				ifTrue: [ (aSet anySatisfy: [ :el | (el compare: m eventName) = 2 ])						ifFalse: [ aSet add: m eventName ] ] ]! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/25/2019 16:29'!addGenericListBlocksTo: page y: startY	"Add the generic list blocks to the given page starting at the given y offset."	| addButton deleteButton x y hasLists |	addButton := ScratchTheme		buttonLabel: 'Make a list' localized		selector: #addList:.	deleteButton := ScratchTheme		buttonLabel: 'Delete a list' localized		selector: #deleteList:.	x := 13.	y := startY + 10.	page		addMorph:			(addButton				target: self project application;				arguments: { self };				position: x @ y).	y := addButton bottom + 3.	hasLists := self listVarNames notEmpty.	hasLists		ifFalse: [ ^ self ].	page		addMorph:			(deleteButton				target: self;				position: x @ y).	y := deleteButton bottom + 10.	"y := (self addListReportersTo: page x: x y: y) + 10."	(self blocksFor: 'list')		do: [ :blockOrSym | 			blockOrSym = #- | (blockOrSym = #~)				ifTrue: [ "insert a half space"					blockOrSym = #-						ifTrue: [ y := y + 15 ].					blockOrSym = #~						ifTrue: [ y := y + 5 ] ]				ifFalse: [ y := self createBlock: blockOrSym atPosition: x @ y onPage: page.					page submorphs last color: ScratchTheme listBlockColor ] ]! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/25/2019 12:36'!addGenericVariableBlocksTo: page x: x y: startY	"Add the generic variable blocks to the given page starting at the given y offset. Answer the new y."	| y vName block varBlocks |	y := startY.	"pick a default variable name"	self varNames isEmpty		ifTrue: [ ^ y ].	vName := self varNames first.	varBlocks := OrderedCollection new.	block := SetterBlockMorph new		receiver: self;		initSetterForVar: vName.	block expressionArg stringExpression: '0'.	varBlocks add: block.	block := SetterBlockMorph new		receiver: self;		initChangerForVar: vName.	block expressionArg numExpression: '1'.	varBlocks add: block.	(self blocksFor: 'variables')		do: [ :b | 			b defaultArgs: (Array with: vName).			varBlocks add: b ].	varBlocks		do: [ :b | 			b color: ScratchTheme variableBlockColor.			page addMorph: (b position: x @ y).			y := b bottom + 3 ].	^ y! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:31'!addSubBlock: aPoint name: aString	| morph |	morph := self newSubMorph		position: aPoint;		subName: aString;		yourself.	blocksBin addMorph: morph! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:31'!addVariableReportersTo: page x: x y: startY	| y b watcherButton yOffset |	y := startY.	self varNames		do: [ :vName | 			b := VariableBlockMorph new				commandSpec: vName;				receiver: self.			watcherButton := self createToggleButtonFor: b.			yOffset := (b fullBounds height - watcherButton height) // 2.			page addMorph: (watcherButton position: x @ (y + yOffset)).			page addMorph: (b position: (x + watcherButton width + 4) @ y).			y := y + b height + 3 ].	^ y! !!ScratchScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:31'!blockCategories	^ (self class blockSpecs		select: [ :el | el isString and: [ el ~= '-' and: [ el ~= '~' ] ] ])		asArray! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/24/2019 22:42'!blockFromSpec: spec color: blockColor	| blockLabelSpec blockType selector defaultArgs block rcvr argPermutation c |	c := blockColor.	blockLabelSpec := spec at: 1.	argPermutation := CommandBlockMorph		argPermutationForSpec: (spec at: 1)		withTranslation: blockLabelSpec.	blockType := spec at: 2.	selector := (spec at: 3) asSymbol.	defaultArgs := self defaultArgsFor: spec.	(#(E K M S T L) includes: blockType)		ifTrue: [ ^ (self hatBlockType: blockType) color: blockColor ].	(blockType includes: $c)		ifTrue: [ block := selector = #doIfElse				ifTrue: [ IfElseBlockMorph new isSpecialForm: true ]				ifFalse: [ CBlockMorph new isSpecialForm: true ] ]		ifFalse: [ (blockType includes: $r) | (blockType includes: $b)				ifTrue: [ block := ReporterBlockMorph new.					c := c darker ]				ifFalse: [ block := CommandBlockMorph new ] ].	(blockType includes: $b)		ifTrue: [ block isBoolean: true ].	(blockType includes: $s)		ifTrue: [ block isSpecialForm: true ].	(blockType includes: $t)		ifTrue: [ block isTimed: true ].	rcvr := self.	^ block		argPermutation: argPermutation;		color: c;		selector: selector;		receiver: rcvr;		commandSpec: blockLabelSpec;		defaultArgs: defaultArgs;		yourself! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:32'!blockFromTuple: tuple receiver: scriptOwner	"Answer a new block for the given tuple."	| k spec blockColor block argCount arg argBlock |	k := tuple first.	(#(readVariable changeVariable) includes: k)		ifTrue: [ ^ self variableBlockFromTuple: tuple receiver: scriptOwner ].	(#(EventHatMorph SubHatMorph) includes: k)		ifTrue: [ block := self hatBlockFromTuple: tuple receiver: scriptOwner.			^ block ].	"#scratchComment = k		ifTrue: [ block := ScratchCommentMorph new.			tuple size > 1				ifTrue: [ block commentMorph contents: (tuple at: 2) ].			tuple size > 2				ifTrue: [ (tuple at: 3)						ifFalse: [ block toggleShowing ] ].			tuple size > 3				ifTrue: [ block width: (tuple at: 4) ].			tuple size > 4				ifTrue: [ block anchor: (self blockWithID: (tuple at: 5)) ].			^ block ].	#comment: = k		ifTrue: [ block := CommentBlockMorph new.			tuple size > 1				ifTrue: [ block comment: (tuple at: 2) ].			tuple size > 2				ifTrue: [ (tuple at: 3)						ifFalse: [ block toggleShowing ] ].			block color: (Color r: 0.8 g: 0 b: 0).			^ block ]."	spec := self class blockSpecAt: k.	spec		ifNil: [ ^ scriptOwner				blockFromSpec: #('obsolete!!' - yourself)				color: Color red ].	blockColor := self class blockColorAt: k.	block := scriptOwner blockFromSpec: spec color: blockColor.	block isCommandBlock		ifTrue: [ argCount := block argumentCount min: tuple size - 1.			1 to: argCount do: [ :i | 				arg := tuple at: i + 1.				arg isArray					ifTrue: [ "argument is a block"						(arg size = 1 and: [ arg first isArray ])							ifTrue: [ arg := arg first ].						argBlock := self blockFromTuple: arg receiver: scriptOwner.						block replaceArgMorph: (block argumentAt: i) by: argBlock ]					ifFalse: [ "argument is a value" (block argumentAt: i) defaultValue: arg ] ].			block isCBlock				ifTrue: [ tuple last isArray						ifTrue: [ block								firstBlockList: (self stackFromTupleList: tuple last receiver: scriptOwner) ] ].			block isIfElseBlock				ifTrue: [ arg := tuple at: tuple size - 1.					arg isArray						ifTrue: [ block								trueBlock: (self stackFromTupleList: arg receiver: scriptOwner) ].					arg := tuple at: tuple size.					arg isArray						ifTrue: [ block								falseBlock: (self stackFromTupleList: arg receiver: scriptOwner) ] ].			block isReporter				ifTrue: [ ((spec at: 2) includes: $b)						ifTrue: [ block isBoolean: true ] ] ].	^ block! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/25/2019 20:48'!blockIDOf: aMorph	| list |	list := blocksBin allMorphs select: [ :each | each isBlockMorph ].	^ list indexOf: aMorph! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:32'!blocksBin	^ blocksBin! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:32'!blocksFor: aCategory	| blockColor blocksList category b |	blockColor := self class blockColorFor: aCategory.	blocksList := OrderedCollection new.	category := nil.	self class blockSpecs		do: [ :spec | 			(spec isString and: [ spec ~= #- and: [ spec ~= #~ ] ])				ifTrue: [ category := spec ]				ifFalse: [ category = aCategory						ifTrue: [ spec = #- | (spec = #~)								ifTrue: [ blocksList addLast: spec ]								ifFalse: [ (b := self blockFromSpec: spec color: blockColor)										ifNotNil: [ blocksList addLast: b ] ] ] ] ].	^ blocksList asArray! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:32'!cleanUp	blocksBin cleanUp! !!ScratchScript methodsFor: 'object i/o' stamp: 'EiichiroIto 11/23/2019 21:32'!convertStacksToTuples	"Convert my blocks bin from a morph containing block stack into a collection of (<point>, <tuple>) pairs the represent the same stacks in compact, language-independent form."	| stacks blocks comments |	blocksBin isArray		ifTrue: [ ^ self ].	stacks := blocksBin submorphs		select: [ :m | m respondsTo: #tupleSequence ].	blocks := stacks select: [ :m | m isBlockMorph ].	comments := stacks select: [ :m | m isCommentMorph ].	blocks := blocks		collect: [ :blockM | 			Array				with: blockM position - blocksBin position				with: blockM tupleSequence ].	comments := comments		collect: [ :blockM | 			Array				with: blockM position - blocksBin position				with: blockM tupleSequence ].	blocksBin := blocks , comments! !!ScratchScript methodsFor: 'object i/o' stamp: 'EiichiroIto 11/23/2019 21:32'!convertTuplesToStacks	| tuplesList stack |	blocksBin isArray		ifFalse: [ ^ self ].	tuplesList := blocksBin.	blocksBin := ScratchScriptsMorph new.	tuplesList		do: [ :pair | 			stack := self stackFromTupleList: pair second receiver: self.			stack position: pair first.			blocksBin addMorph: stack ]! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:33'!createBlock: block atPosition: pos onPage: page	"Creates a block on the given page. If the block is one that can become a watcher, then a toggle button is created as well."	| x y changingX toggleButton yOffset |	x := pos x.	y := pos y.	changingX := x.	block canBecomeWatcher		ifTrue: [ toggleButton := self createToggleButtonFor: block.			yOffset := (block fullBounds height				- toggleButton fullBounds height) // 2.			page addMorphBack: (toggleButton position: x @ (y + yOffset)).			changingX := x + toggleButton fullBounds width + 4 ].	block		fixBlockLayout;		position: changingX @ y.	page addMorphBack: block.	^ y + block height + 3! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:33'!createToggleButtonFor: block	| toggleButton |	toggleButton := ToggleButton		onForm: (ScratchTheme formAt: #watcherButtonPressed)		offForm: (ScratchTheme formAt: #watcherButton).	toggleButton		target: self;		actionSelector: #toggleWatcher:for:;		arguments:			{toggleButton.			block};		borderWidth: 0;		setProperty: #balloonText toValue: 'View on stage' localized.	self updateWatcher: toggleButton for: block.	^ toggleButton! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:33'!defaultArgsFor: blockSpec	| defaultArgs sel |	defaultArgs := blockSpec copyFrom: 4 to: blockSpec size.	sel := (blockSpec at: 3) asSymbol.	(#(broadcast: doBroadcastAndWait) includes: sel)		ifTrue: [ defaultArgs := Array with: project defaultEventName ].	^ defaultArgs! !!ScratchScript methodsFor: 'program' stamp: 'EiichiroIto 11/23/2019 21:33'!eventBlocks	^ blocksBin submorphs select: [:m | m class = EventHatMorph]! !!ScratchScript methodsFor: 'object i/o' stamp: 'EiichiroIto 11/23/2019 21:35'!fieldsVersion	^ 1! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:33'!hatBlockFromTuple: tuple receiver: scriptOwner	| blockClass block eventName |	blockClass := Smalltalk at: tuple first.	block := blockClass new scriptOwner: scriptOwner.	blockClass = EventHatMorph		ifTrue: [ eventName := tuple at: 2.			eventName = 'startup'				ifTrue: [ block						forStartupEvent;						scriptOwner: scriptOwner.					^ block ].			eventName = 'setup'				ifTrue: [ block						forSetupEvent;						scriptOwner: scriptOwner.					^ block ].			eventName = 'loop'				ifTrue: [ block						forLoopEvent;						scriptOwner: scriptOwner.					^ block ].			block eventName: eventName.			^ block ].	blockClass = SubHatMorph		ifTrue: [ block				subName: (tuple at: 2);				scriptOwner: scriptOwner.			^ block ].	^ block! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:33'!hatBlockType: blockType	| evtName subName |	'E' = blockType		ifTrue: [ evtName := ''.			evtName := project defaultEventName.			^ EventHatMorph new				scriptOwner: self;				eventName: evtName ].	'S' = blockType		ifTrue: [ ^ EventHatMorph new forSetupEvent scriptOwner: self ].	'T' = blockType		ifTrue: [ ^ EventHatMorph new forStartupEvent scriptOwner: self ].	'L' = blockType		ifTrue: [ ^ EventHatMorph new forLoopEvent scriptOwner: self ].	'C' = blockType		ifTrue: [ subName := ''.			subName := project defaultSubName.			^ SubHatMorph new				scriptOwner: self;				subName: subName ]! !!ScratchScript methodsFor: 'object i/o' stamp: 'EiichiroIto 11/23/2019 21:34'!initFieldsFrom: anObjStream version: classVersion	self		initFieldsNamed: #(blocksBin project)		from: anObjStream! !!ScratchScript methodsFor: 'initialization' stamp: 'EiichiroIto 11/23/2019 21:34'!initialize	blocksBin := ScratchScriptsMorph new! !!ScratchScript methodsFor: 'testing' stamp: 'EiichiroIto 11/23/2019 21:34'!isScriptable	^ true! !!ScratchScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/25/2019 16:30'!listVarNames	self subclassResponsibility! !!ScratchScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/23/2019 21:36'!mathFunctionNames	^ #('abs' 'sqrt' 'sin' 'cos' 'tan' 'asin' 'acos' 'atan' 'ln' 'log' 'e ^' '10 ^')! !!ScratchScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:36'!meOrOwnerThatIsA: aMorph	self flag: #ToBeRemove.	^ project application! !!ScratchScript methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 21:36'!newBlockPaletteMorph	^ ScratchBlockPaletteMorph new		project: project;		yourself! !!ScratchScript methodsFor: 'instance creation' stamp: 'EiichiroIto 11/23/2019 21:36'!newCode	self subclassResponsibility! !!ScratchScript methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 21:37'!newSubMorph	^ SubHatMorph new		newScriptOwner: self;		yourself! !!ScratchScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:37'!objName	self subclassResponsibility! !!ScratchScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:37'!project	^ project! !!ScratchScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 21:37'!project: aProject	project := aProject.	blocksBin project: project! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:37'!scripts	^ blocksBin submorphs select: [ :m | m isHatBlock ]! !!ScratchScript methodsFor: 'program' stamp: 'EiichiroIto 11/23/2019 21:45'!setupProgram: aProgram events: aDictionary	| subTable |	subTable := Dictionary new.	self subBlocks		do: [ :each | 			self				setupSub: each				program: aProgram				table: subTable ].	self eventBlocks		do: [ :each | 			self				setupEvent: each				program: aProgram				table: subTable				events: aDictionary ].! !!ScratchScript methodsFor: 'object i/o' stamp: 'EiichiroIto 11/23/2019 21:36'!stackFromTupleList: tupleList receiver: scriptOwner	| stackTop previousBlock block |	stackTop := previousBlock := nil.	tupleList		do: [ :tuple | 			block := self blockFromTuple: tuple receiver: scriptOwner.			previousBlock				ifNil: [ stackTop := block ]				ifNotNil: [ previousBlock nextBlock: block ].			previousBlock := block ].	^ stackTop! !!ScratchScript methodsFor: 'object i/o' stamp: 'EiichiroIto 11/23/2019 21:35'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(blocksBin project) on: anObjStream.! !!ScratchScript methodsFor: 'program' stamp: 'EiichiroIto 11/23/2019 21:45'!subBlocks	^ blocksBin submorphs select: [:m | m class = SubHatMorph]! !!ScratchScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/23/2019 21:45'!subNames	^ (self subBlocks collect: #subName) asSet asArray sort! !!ScratchScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 19:29'!toggleWatcher: aToggleButton for: aBlockMorph	self subclassResponsibility! !!ScratchScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/24/2019 22:40'!uncoloredArgMorphFor: specString	self subclassResponsibility! !!ScratchScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 19:29'!updateWatcher: aToggleButton for: aBlockMorph	self subclassResponsibility! !!ScratchScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/25/2019 16:36'!varNames	self subclassResponsibility! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:46'!variableBlockFromTuple: tuple receiver: scriptOwner	"Answer a new block for the given variable reference tuple."	| varName rcvr selector block arg argBlock |	varName := tuple at: 2.	rcvr := scriptOwner.	(scriptOwner varNames includes: varName)		ifFalse: [ scriptOwner addVariable: varName ].	tuple first = #readVariable		ifTrue: [ ^ VariableBlockMorph new				commandSpec: varName;				receiver: rcvr ].	tuple first = #changeVariable		ifTrue: [ selector := tuple at: 3.			"update selector if necessary (backward compatibility):"			selector = #set:to:				ifTrue: [ selector := #setVar:to: ].			block := SetterBlockMorph new receiver: rcvr.			selector = #setVar:to:				ifTrue: [ block initSetterForVar: varName ]				ifFalse: [ block initChangerForVar: varName ].			arg := tuple at: 4.			arg isArray				ifTrue: [ "argument is a block"					(arg size = 1 and: [ arg first isArray ])						ifTrue: [ arg := arg first ].					argBlock := self blockFromTuple: arg receiver: scriptOwner.					block replaceArgMorph: block expressionArg by: argBlock ]				ifFalse: [ "argument is a value" block expressionArg defaultValue: arg ].			^ block ].	self error: 'unknown variable spec'! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:46'!variablesPage	| page addButton deleteButton x y maxX |	page := self newBlockPaletteMorph		isForScript: true;		color: (Color r: 0.8 g: 0.8 b: 1.0);		borderWidth: 0.	addButton := ScratchTheme		buttonLabel: 'Make a variable' localized		selector: #addVariable:.	deleteButton := ScratchTheme		buttonLabel: 'Delete a variable' localized		selector: #deleteVariable:.	x := 13.	page		addMorph:			(addButton				target: self project application;				arguments: { self };				position: x @ 7).	y := addButton bottom + 3.	self varNames notEmpty		ifTrue: [ page				addMorph:					(deleteButton						target: self;						position: x @ y).			y := deleteButton bottom + 10.			y := self addVariableReportersTo: page x: x y: y.			y := y + 12.			y := self addGenericVariableBlocksTo: page x: x y: y ].	self addGenericListBlocksTo: page y: y.	maxX := page submorphs inject: 0 into: [ :t :m | t max: m right ].	page extent: (maxX + 10) @ y.	^ page! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:46'!viewerPageForCategory: aCategoryName	| bin x y |	aCategoryName = 'variables'		ifTrue: [ ^ self variablesPage ].	aCategoryName = 'sensing'		ifTrue: [ ^ self viewerPageForSensing ].	bin := self newBlockPaletteMorph isForScript: true; yourself.	x := 12.	y := 10.	(self blocksFor: aCategoryName)		do: [ :blockOrSym | 			blockOrSym = #- | (blockOrSym = #~)				ifTrue: [ "insert a half space"					blockOrSym = #-						ifTrue: [ y := y + 15 ].	"insert a full space"					blockOrSym = #~						ifTrue: [ y := y + 5 ] ]				ifFalse: [ y := self createBlock: blockOrSym atPosition: x @ y onPage: bin ] ].	^ bin! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 11/23/2019 21:46'!viewerPageForSensing	| bin x y |	bin := self newBlockPaletteMorph isForScript: true; yourself.	x := 12.	y := 10.	(self blocksFor: 'sensing')		do: [ :blockOrSym | 			blockOrSym = #- | (blockOrSym = #~)				ifTrue: [ blockOrSym = #-						ifTrue: [ y := y + 15 ].					blockOrSym = #~						ifTrue: [ y := y + 7.							bin								addMorph:									((ImageMorph new form: (ScratchTheme formAt: #connector))										position: x @ y).							y := y + 20 ] ]				ifFalse: [ y := self createBlock: blockOrSym atPosition: x @ y onPage: bin ] ].	^ bin! !!ScratchScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 19:25'!watcherSelectors	^ #()! !!ScratchSexpGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 8/2/2019 12:20'!argString: anArgMorph 	| v |	^ anArgMorph labelMorph		ifNil: [self error: 'nil arg']		ifNotNil: 			[v := anArgMorph evaluate.			self literalStringFrom: v]! !!ScratchSexpGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 8/6/2019 17:15'!eventTitleString: aString	^ aString! !!ScratchSexpGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 8/2/2019 14:45'!expressionArgWithMenuString: aMorph	^ aMorph evaluate! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 8/6/2019 12:26'!generateBegin: aSymbol morph: aMorph	stream nextPut: $(.	stream nextPutAll: aSymbol.	aMorph blockArgs		do: [ :each | 			stream nextPut: Character space.			stream nextPutAll: (each argString: parser) asString ].	self generateLineFeed.	stream nextPut: $(.! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 15:02'!generateCenter: aSymbol morph: aMorph	stream nextPut: $).	self generateLineFeed.	stream nextPut: $(.! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 15:02'!generateCode: aSymbol morph: aBlockMorph	stream nextPut: $(.	stream nextPutAll: aSymbol.	aBlockMorph blockArgs		do: [ :each | 			stream nextPut: Character space.			stream nextPutAll: (each argString: parser) asString ].	stream nextPut: $).	self generateLineFeed.! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 15:02'!generateEnd: aSymbol morph: aMorph	stream nextPutAll: '))'.	self generateLineFeed.! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 9/11/2019 21:42'!generateEventFooter: aString	stream nextPutAll: '))'.! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 9/11/2019 21:43'!generateEventHeader: aString	self generateLineFeed.	stream		nextPutAll: '(when ';		nextPutAll: aString.	self generateLineFeed.	stream nextPut: $(.! !!ScratchSexpGenerator methodsFor: 'private' stamp: 'EiichiroIto 8/6/2019 17:40'!generateIndent: anInteger 	"do nothing"! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 15:01'!generateLineFeed	stream nextPut: Character lf.! !!ScratchSexpGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 8/2/2019 12:34'!generateReporter: aSymbol morph: aReporterMorph	| out |	out := WriteStream on: String new.	out nextPut: $(.	out nextPutAll: aSymbol.	aReporterMorph blockArgs		do: [ :each | 			out nextPut: Character space.			out nextPutAll: (each argString: parser) asString ].	out nextPut: $).	^ out contents! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 9/12/2019 13:07'!generateSubFooter: aString	stream nextPutAll: '))'.! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 9/12/2019 13:07'!generateSubHeader: aString	self generateLineFeed.	stream		nextPutAll: '(sub ';		nextPutAll: aString.	self generateLineFeed.	stream nextPut: $(.! !!ScratchSexpGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 8/2/2019 14:13'!indentLevelFor: aString	^ 2! !!ScratchSexpGenerator methodsFor: 'initialization' stamp: 'EiichiroIto 10/19/2019 19:05'!initialize	super initialize.	parser := ScratchBlockParser codeGenerator: self.	stream := WriteStream on: String new.! !!ScratchSexpGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 8/6/2019 17:30'!literalStringFrom: anObject	anObject isString		ifTrue: [ ^ (SexpLexer quotedString: anObject) ].	anObject isNumber		ifTrue: [ ^ anObject ].	self error.! !!ScratchSexpGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 8/2/2019 12:23'!parse: aTopBlock target: aMorph	targetMorph := aMorph.	parser parseBlock: aTopBlock.	^ stream contents! !!ScratchSexpGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 8/2/2019 14:32'!spriteArgString: aMorph	aMorph ifNil: [ self error ].	^ aMorph objName! !!ScratchSexpGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 8/6/2019 17:30'!variableArgString: aString	^ '(getVar ' , (SexpLexer quotedString: aString) , ')'! !!ScratchTheme class methodsFor: 'fonts' stamp: 'EiichiroIto 11/19/2019 21:26'!argFont	^ self fontAt: #Arg! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 21:28'!blockArgColor	^ self colorAt: #blockArgColor! !!ScratchTheme class methodsFor: 'instance creation' stamp: 'EiichiroIto 11/19/2019 20:50'!buildDarkTheme	| obj |	obj := self newThemeNamed: 'darkTheme'.	obj colorAt: #blockArgColor put: (Color gray: 0.2).	obj colorAt: #categoryOnColor put: Color black.	obj colorAt: #categoryOffColor put: (Color gray: 0.8).	obj colorAt: #dialogBoxTextColor put: (Color gray: 0.8).	obj colorAt: #dialogBoxTitleColor put: (Color gray: 0.4).	obj colorAt: #fieldColor put: (Color gray: 0.2).	obj colorAt: #folderHighlightColor put: (Color r: (96/255) g: (136/255) b: (182/255)).	obj colorAt: #labelOnColor put: Color black.	obj colorAt: #labelOffColor put: (Color gray: 0.8).	obj colorAt: #libraryColor put: (Color gray: 0.2).	obj colorAt: #listColor put: (Color r: (193/255) g: (196/255) b: (199/255)).	obj colorAt: #listBlockColor put: (Color r: 0.85 g: 0.303 b: 0.068).	obj colorAt: #menuNormalColor put: (Color gray: 0.8).	obj colorAt: #menuHighlightColor put: Color white.	obj colorAt: #palettePaneColor put: (Color gray: 0.2).	obj colorAt: #readoutColor put: (Color gray: 0.2).	obj colorAt: #scriptsPaneColor put: (Color gray: 0.2).	obj colorAt: #sensorBoardColor put: (Color r: (193/255) g: (196/255) b: (199/255)).	obj colorAt: #textColor put: (Color gray: 0.8).	obj colorAt: #textSelectionColor put: (Color r: 0.353 g: 0.607 b: 0.788).	obj colorAt: #thumbnailDirectionColor put: (Color gray: 0.8).	obj colorAt: #viewerPaneColor put: (Color gray: 0.2).	obj colorAt: #watcherColor put: (Color r: (193/255) g: (196/255) b: (199/255)).	obj colorAt: #watcherBorderColor put: (Color r: (148/255) g: (145/255) b: (145/255)).	^ obj! !!ScratchTheme class methodsFor: 'instance creation' stamp: 'EiichiroIto 11/19/2019 20:50'!buildScratch14Theme	| obj |	obj := self newThemeNamed: 'scratch14Theme'.	obj colorAt: #blockArgColor put: (Color gray: 0.95).	obj colorAt: #categoryOnColor put: Color white.	obj colorAt: #categoryOffColor put: Color white.	obj colorAt: #dialogBoxTextColor put: Color black.	obj colorAt: #dialogBoxTitleColor put: Color white.	obj colorAt: #fieldColor put: (Color r: (211/255) g: (214/255) b: (216/255)).	obj colorAt: #folderHighlightColor put: (Color r: (96/255) g: (136/255) b: (182/255)).	obj colorAt: #labelOnColor put: Color black.	obj colorAt: #labelOffColor put: (Color r: (78/255) g: (82/255) b: (82/255)).	obj colorAt: #libraryColor put: Color gray.	obj colorAt: #listColor put: (Color r: (193/255) g: (196/255) b: (199/255)).	obj colorAt: #listBlockColor put: (Color r: 0.85 g: 0.303 b: 0.068).	obj colorAt: #menuNormalColor put: (Color gray: 0.3).	obj colorAt: #menuHighlightColor put: Color white.	obj colorAt: #palettePaneColor put: (Color r: 124 g: 128 b: 131 range: 255).	obj colorAt: #readoutColor put: (Color r: 0.753 g: 0.764 b: 0.776).	obj colorAt: #scriptsPaneColor put: (Color r: (149/255) g: (154/255) b: (159/255)).	obj colorAt: #sensorBoardColor put: (Color r: (193/255) g: (196/255) b: (199/255)).	obj colorAt: #textColor put: Color white.	obj colorAt: #textSelectionColor put: (Color r: 0.353 g: 0.607 b: 0.788).	obj colorAt: #thumbnailDirectionColor put: Color blue.	obj colorAt: #viewerPaneColor put: (Color r: 0.584 g: 0.603 b: 0.623).	obj colorAt: #watcherColor put: (Color r: (193/255) g: (196/255) b: (199/255)).	obj colorAt: #watcherBorderColor put: (Color r: (148/255) g: (145/255) b: (145/255)).	^ obj! !!ScratchTheme class methodsFor: 'instance creation' stamp: 'EiichiroIto 11/19/2019 20:50'!buildScratch30Theme	| obj |	obj := self newThemeNamed: 'scratch30Theme'.	obj colorAt: #blockArgColor put: (Color gray: 0.95).	obj colorAt: #categoryOnColor put: Color black.	obj colorAt: #categoryOffColor put: (Color r: (78/255) g: (82/255) b: (82/255)).	obj colorAt: #dialogBoxTextColor put: Color black.	obj colorAt: #dialogBoxTitleColor put: Color white.	obj colorAt: #fieldColor put: Color white.	obj colorAt: #folderHighlightColor put: (Color fromString: '#4c97ff').	obj colorAt: #labelOnColor put: Color black.	obj colorAt: #labelOffColor put: (Color r: (78/255) g: (82/255) b: (82/255)).	obj colorAt: #libraryColor put: Color white.	obj colorAt: #listColor put: Color white.	obj colorAt: #listBlockColor put: (Color r: 0.85 g: 0.303 b: 0.068).	obj colorAt: #menuNormalColor put: Color white.	obj colorAt: #menuHighlightColor put: (Color gray: 0.3).	obj colorAt: #palettePaneColor put: Color white.	obj colorAt: #readoutColor put: Color white.	obj colorAt: #scriptsPaneColor put: Color white.	obj colorAt: #sensorBoardColor put: Color white.	obj colorAt: #textColor put: Color black.	obj colorAt: #textSelectionColor put: Color green.	obj colorAt: #thumbnailDirectionColor put: Color blue.	obj colorAt: #viewerPaneColor put: Color white.	obj colorAt: #watcherColor put: Color white.	obj colorAt: #watcherBorderColor put: Color black.	^ obj! !!ScratchTheme class methodsFor: 'fonts' stamp: 'EiichiroIto 11/19/2019 21:30'!buttonFont	^ self fontAt: #Button! !!ScratchTheme class methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 21:31'!buttonLabel: aString selector: aSymbolOrNil	"Answer a big button with the given label."	| button |	button := ResizableToggleButton2 new		offForm: (self formAt: #btn) onForm: (self formAt: #btnPressed);		label: aString font: self buttonFont;		actionSelector: aSymbolOrNil;		labelColorOn: self labelOnColor			labelColorOff: self labelOffColor			labelColorOver: self labelOnColor.	^ button! !!ScratchTheme class methodsFor: 'accessing' stamp: 'EiichiroIto 7/29/2018 12:13'!changeTheme: aSymbol	CurrentTheme := AvailableThemes at: aSymbol! !!ScratchTheme class methodsFor: 'accessing' stamp: 'EiichiroIto 7/29/2018 16:03'!colorAt: aSymbol	^ self current colorAt: aSymbol! !!ScratchTheme class methodsFor: 'fonts' stamp: 'EiichiroIto 11/19/2019 21:40'!commentFont	^ self fontAt: #CommentBlock! !!ScratchTheme class methodsFor: 'accessing' stamp: 'EiichiroIto 7/29/2018 12:34'!current	^ CurrentTheme! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 22:05'!dialogBoxTextColor	^ self colorAt: #dialogBoxTextColor! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 22:05'!fieldColor	^ self colorAt: #fieldColor! !!ScratchTheme class methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 20:52'!fontAt: aSymbol	^ self current fontAt: aSymbol! !!ScratchTheme class methodsFor: 'accessing' stamp: 'EiichiroIto 11/16/2019 19:12'!formAt: aSymbolOrString	^ self formAt: aSymbolOrString ifAbsent: [ self error ]! !!ScratchTheme class methodsFor: 'accessing' stamp: 'EiichiroIto 7/29/2018 15:56'!formAt: aString ifAbsent: aBlock	^ self current formAt: aString ifAbsent: aBlock! !!ScratchTheme class methodsFor: 'private' stamp: 'EiichiroIto 6/30/2019 16:15'!getThemes	| response ref |	response := ZnEasy get: self themesURL.	response isSuccess		ifFalse: [ self error: 'Cannot get Themes.zip' ].	ref := 'Themes.zip' asFileReference.	ref binaryWriteStream		nextPutAll: response contents;		close.	(ZipArchive new readFrom: ref fullName) extractAllTo: FileLocator workingDirectory.! !!ScratchTheme class methodsFor: 'initialization' stamp: 'EiichiroIto 6/30/2019 15:46'!initialize	"ScratchTheme initialize."	| dict theme |	self themeIsInstalled		ifFalse: [ self getThemes ].	dict := Dictionary new.	('Themes' asFileReference directoryNames copyWithout: 'common')		do: [ :each | 			theme := self perform: ('build' , each asCamelCase) asSymbol.			dict at: each asSymbol put: theme ].	AvailableThemes := dict.	self changeTheme: AvailableThemes keys anyOne! !!ScratchTheme class methodsFor: 'fonts' stamp: 'EiichiroIto 11/19/2019 21:27'!labelFont	^ self fontAt: #Label! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 21:31'!labelOffColor	^ self colorAt: #labelOffColor! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 21:30'!labelOnColor	^ self colorAt: #labelOnColor! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 21:32'!listBlockColor	^ self colorAt: #listBlockColor! !!ScratchTheme class methodsFor: 'instance creation' stamp: 'EiichiroIto 11/19/2019 20:50'!newThemeNamed: aString	| obj |	obj := ScratchTheme new.	self setupFont: obj.	self readForms: aString to: obj.	^ obj! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 22:00'!palettePaneColor	^ self colorAt: #palettePaneColor! !!ScratchTheme class methodsFor: 'private' stamp: 'EiichiroIto 9/5/2018 21:27'!readForms: aString to: aTheme 	| base dir |	base := 'Themes' asFileReference.	base exists		ifFalse: [self error: 'Themes directory not found'].	dir := base / 'common'.	dir isDirectory		ifFalse: [self error: 'common directory not found'].	aTheme readFormsFrom: dir.	dir := base / aString.	dir isDirectory		ifFalse: [self error: aString , ' directory not found'].	aTheme readFormsFrom: dir.! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 22:00'!scriptsPaneColor	^ self colorAt: #scriptsPaneColor! !!ScratchTheme class methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 20:47'!setupFont: aTheme	aTheme fontAt: #Arg name: 'Verdana' size: 10.	aTheme fontAt: #Label name: 'VerdanaBoldNarrowSpace' size: 10.	aTheme fontAt: #MenuTitle name: 'VerdanaBold' size: 14.	aTheme fontAt: #Button name: 'VerdanaBold' size: 10.	aTheme fontAt: #Category name: 'VerdanaBold' size: 10.	aTheme fontAt: #Tab name: 'VerdanaBold' size: 11.	aTheme fontAt: #CommentBlock name: 'Verdana' size: 10.	aTheme fontAt: #TalkBubble name: 'VerdanaBold' size: 12.	aTheme fontAt: #ToolTip name: 'Verdana' size: 13.	aTheme fontAt: #ReporterToolTip name: 'Verdana' size: 14.	aTheme fontAt: #XYReadout name: 'Verdana' size: 10.	aTheme fontAt: #XYReadoutBold name: 'VerdanaBold' size: 10.	aTheme fontAt: #CostumesPage name: 'VerdanaBold' size: 11.	aTheme fontAt: #SoundsPage name: 'VerdanaBold' size: 11.	aTheme fontAt: #ViewerPage name: 'VerdanaBold' size: 11.	aTheme fontAt: #UpdatingStringField name: 'VerdanaBold' size: 11.	aTheme fontAt: #Watcher name: 'VerdanaBold' size: 10.	aTheme fontAt: #WatcherLarge name: 'VerdanaBold' size: 14.	aTheme fontAt: #PaintUtilityButton name: 'VerdanaBold' size: 10.	aTheme fontAt: #PaintSetRotationCenter name: 'VerdanaBold' size: 11.	aTheme fontAt: #LibraryItemName name: 'VerdanaBold' size: 9	.	aTheme fontAt: #LibraryItemInfo name: 'Verdana' size: 6	.	aTheme fontAt: #MediaItemInfo name: 'Verdana' size: 9	.	aTheme fontAt: #DialogBoxTitle name: 'VerdanaBold' size: 14.	aTheme fontAt: #DialogBoxMessage name: 'VerdanaBold' size: 13.	aTheme fontAt: #DialogBoxButton name: 'VerdanaBold' size: 11.	aTheme fontAt: #ProjectNotes name: 'Verdana' size: 10.	aTheme fontAt: #LinkMorphDefault name: 'VerdanaBold' size: 10.	aTheme fontAt: #ShareLink name: 'VerdanaBold' size: 13.	aTheme fontAt: #SoundRecorderButton name: 'VerdanaBold' size: 13.	aTheme fontAt: #SoundRecorderTimer name: 'NewYorkBold' size: 10.	aTheme fontAt: #StringDialogTypeIn name: 'Verdana' size: 12.	aTheme fontAt: #NewVariableDialogBox name: 'Verdana' size: 11.	aTheme fontAt: #AboutScratch name: 'VerdanaBold' size: 11.	aTheme fontAt: #UploadTagLabel name: 'VerdanaBold' size: 10.	aTheme fontAt: #UploadTag name: 'Verdana' size: 10.	aTheme fontAt: #UploadDialogLabel name: 'VerdanaBold' size: 10.	aTheme fontAt: #UploadDialogContents name: 'Verdana' size: 10.	aTheme fontAt: #UploadDialogComment name: 'Verdana' size: 10.	aTheme fontAt: #FolderShortcut name: 'Verdana' size: 11.	aTheme fontAt: #FileChooserNewFileTitle name: 'VerdanaBold' size: 10.	aTheme fontAt: #FileChooserNewFilename name: 'Verdana' size: 10.	aTheme fontAt: #FileChooserLabel name: 'VerdanaBold' size: 10.	aTheme fontAt: #FileChooserContents name: 'Verdana' size: 12.	aTheme fontAt: #FileChooserComment name: 'Verdana' size: 10.	aTheme fontAt: #FilePickerDirectoryName name: 'VerdanaBold' size: 9	.	aTheme fontAt: #FilePickerEntry name: 'Verdana' size: 11.	aTheme fontAt: #FilePickerEntryHighlighted name: 'VerdanaBold' size: 11.	aTheme fontAt: #FrameMorphProjectTitle name: 'VerdanaBold' size: 13! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 22:11'!textColor	^ self colorAt: #textColor! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 22:06'!textSelectionColor	^ self colorAt: #textSelectionColor! !!ScratchTheme class methodsFor: 'testing' stamp: 'EiichiroIto 6/30/2019 15:25'!themeIsInstalled	^ 'Themes' asFileReference in: [ :ref | ref isDirectory and: [ ref entries notEmpty ] ]! !!ScratchTheme class methodsFor: 'accessing' stamp: 'EiichiroIto 7/29/2018 12:14'!themeNames	^ AvailableThemes keys! !!ScratchTheme class methodsFor: 'private' stamp: 'EiichiroIto 6/30/2019 15:28'!themesURL	^ 'https://github.com/EiichiroIto/Stelo/raw/master/misc/Themes.zip'! !!ScratchTheme class methodsFor: 'private' stamp: 'EiichiroIto 7/29/2018 18:00'!updateDarkTheme	"ScratchTheme updateDarkTheme."	AvailableThemes at: #darkTheme put: self buildDarkTheme.	self changeTheme: #darkTheme.! !!ScratchTheme class methodsFor: 'colors' stamp: 'EiichiroIto 11/19/2019 21:18'!variableBlockColor	^ Color h: 25 s: 0.88 v: 0.95! !!ScratchTheme methodsFor: 'accessing' stamp: 'EiichiroIto 8/1/2018 19:19'!colorAt: aSymbol	^ colors at: aSymbol asSymbol! !!ScratchTheme methodsFor: 'accessing' stamp: 'EiichiroIto 8/1/2018 19:19'!colorAt: aSymbol put: aColor	colors at: aSymbol asSymbol put: aColor! !!ScratchTheme methodsFor: 'private' stamp: 'EiichiroIto 7/29/2018 11:59'!colors	^ colors copy! !!ScratchTheme methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 20:51'!fontAt: aSymbol	^ fonts at: aSymbol! !!ScratchTheme methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 20:44'!fontAt: aSymbol name: aString size: anInteger	| font |	font := StrikeFont fontName: aString size: anInteger.	fonts at: aSymbol put: font! !!ScratchTheme methodsFor: 'accessing' stamp: 'EiichiroIto 8/1/2018 19:19'!formAt: aSymbol	^ forms at: aSymbol asSymbol! !!ScratchTheme methodsFor: 'accessing' stamp: 'EiichiroIto 8/1/2018 19:19'!formAt: aSymbol ifAbsent: aBlock	^ forms at: aSymbol asSymbol ifAbsent: aBlock! !!ScratchTheme methodsFor: 'accessing' stamp: 'EiichiroIto 8/1/2018 19:19'!formAt: aSymbol put: aForm	forms at: aSymbol asSymbol put: aForm! !!ScratchTheme methodsFor: 'private' stamp: 'EiichiroIto 7/29/2018 11:59'!forms	^ forms copy! !!ScratchTheme methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 20:44'!initialize	colors := Dictionary new.	forms := Dictionary new.	fonts := Dictionary new! !!ScratchTheme methodsFor: 'file read' stamp: 'EiichiroIto 9/5/2018 21:48'!readFormsFrom: aFileReference	| img fn |	aFileReference files		do: [ :entry | 			fn := entry fullName.			Cursor read showWhile: [ img := [ Form fromFileNamed: fn ] ifError: [ self error	"nil" ] ].			img ifNotNil: [ self formAt: entry base asSymbol put: img ] ].! !!ScratchTranslator class methodsFor: 'Unicode rendering' stamp: 'ee 6/29/2008 13:33'!centerOffsetForButtonWithFont: aStrikeFont	"Answer the vertical offset above the center of a button for the given font. If the translator has provided a render hint string, return an offset that will center the first character of that string. Otherwise, return an offset that will center a lowercase 'x'."	"[self centerOffsetForFont: (StrikeFont fontName: 'VerdanaBold' size: 10)] msecs"	| f r vOffset |	(RenderCenterOffsetCache includesKey: aStrikeFont) ifTrue: [		^ RenderCenterOffsetCache at: aStrikeFont].	f := (StringMorph contents: self renderHintString font: aStrikeFont) imageForm.	r := f rectangleEnclosingPixelsNotOfColor: Color transparent.	vOffset := r top + (r height // 2).  "offset of string morph above the centerline of a button to center the given letter"	r height = 0 ifTrue: [vOffset := f height // 2].	RenderCenterOffsetCache at: aStrikeFont put: vOffset.	^ vOffset! !!ScratchTranslator class methodsFor: 'language translation' stamp: 'EiichiroIto 11/22/2019 15:34'!ellipsesSuffix	"Answer an ellipses suffix (three periods). If the current language is RTL, then include the Unicode RTL mark after the colon."	^ '...'! !!ScratchTranslator class methodsFor: 'import/export' stamp: 'EiichiroIto 9/27/2016 10:54'!parseCommandSpec: aCommandSpec	"Answer an array of token strings containing my keywords and argument specs."	"self parseCommandSpec: '%a of %m'"	| result len i j spec |	result := OrderedCollection new.	spec := aCommandSpec.	"(spec isKindOf: UTF8) ifTrue: [spec := String withAll: spec]."	len := aCommandSpec size.	i := 1.	[(i < len) and: [(spec at: i) isSeparator]] whileTrue: [i := i + 1].	[i <= len] whileTrue: [		j := spec indexOf: $% startingAt: i.		j > 0			ifTrue: [				j > i ifTrue: [result addLast: (spec copyFrom: i to: j - 1)].				j < len					ifTrue: [result addLast: (spec copyFrom: j to: j + 1)]					ifFalse: [result addLast: '%'].				i := j + 2]			ifFalse: [				result addLast: (spec copyFrom: i to: len).				i := len + 1]].	^ result asArray collect: [:s | s trimBoth]! !!ScratchTranslator class methodsFor: 'Unicode rendering' stamp: 'EiichiroIto 11/22/2019 16:36'!renderHintString	"Answer a string to be used as an example button lable to adjust button size and label centering."	"self renderHintString"	"self showHintString"	| stream |	stream := WriteStream on: String new.	#('New' 'Open' 'Save' 'Save As' 'Share!!' 'Undo' 'Language' 'Extras' 'Want Help?' 'motion' 'looks' 'sound' 'pen' 'control' 'sensing' 'operators' 'variables')		do: [ :each | stream nextPutAll: each ].	^ stream contents! !!ScratchTranslator class methodsFor: 'Unicode rendering' stamp: 'EiichiroIto 9/27/2016 16:16'!stringExtent: aString font: aStrikeFont	"Answer the extent of the given string using my font under the current font rendering system."	"self stringExtent: 'Hello, Scratch!!' font: (StrikeFont fontName: 'Verdana' size: 18)"	^ (aStrikeFont widthOfString: aString asString) @ aStrikeFont height! !!ScratchTranslator class methodsFor: 'Unicode copy/paste' stamp: 'EiichiroIto 9/26/2016 20:57'!unicodeClipboard	^ Clipboard clipboardText asString! !!ScratchTranslator class methodsFor: 'Unicode copy/paste' stamp: 'EiichiroIto 9/26/2016 20:58'!unicodeClipboardPut: unicodeOrString	Clipboard clipboardText: unicodeOrString! !!ScratchTranslator class methodsFor: 'Unicode rendering' stamp: 'jm 7/1/2008 10:32'!verticalTrimForFont: aStrikeFont	"Answer the number of pixels to trim from a button labeled with the given font. Some rendering systems (e.g. Pango on Mac OS), add excess space below the lowest extent of a font in some languages. This method computes the actual space needed by from the render hints string. It is the translator's responsibility to provide a render hints string that includes the tallest character and the the character with the maximum descent."	"[self verticalTrimForFont: (StrikeFont fontName: 'VerdanaBold' size: 10)] msecs"	| f r extra |	(RenderVerticalTrimCache includesKey: aStrikeFont) ifTrue: [		^ RenderVerticalTrimCache at: aStrikeFont].	f := (StringMorph contents: self renderHintString font: aStrikeFont) imageForm.	r := f rectangleEnclosingPixelsNotOfColor: (f colorAt: 0@0).	extra := (f height - r height - 2) max: 0.	RenderVerticalTrimCache at: aStrikeFont put: extra.	^ extra! !!SexpLexer class methodsFor: 'acccessing' stamp: 'EiichiroIto 8/6/2019 17:29'!quotedString: aString	^ (aString includes: Character space)		ifTrue: [ '"' , aString , '"' ]		ifFalse: [ aString ]! !!SexpLexer methodsFor: 'private' stamp: 'EiichiroIto 8/6/2019 17:30'!delimiters	^ '!!@#$%^&*()_+`~=[]{}\|;'',<>/?', self whiteSpaces! !!SexpLexer methodsFor: 'acccessing' stamp: 'EiichiroIto 8/6/2019 17:36'!read: aString	| in out c token |	in := ReadStream on: aString.	out := WriteStream on: OrderedCollection new.	[ in atEnd ]		whileFalse: [ c := in peek.			c = $"				ifTrue: [ in next.					token := in upTo: $".					out nextPut: token ]				ifFalse: [ (self delimiters includes: c)						ifTrue: [ in next.							(self whiteSpaces includes: c)								ifFalse: [ out nextPut: c ] ]						ifFalse: [ token := in upToAny: self delimiters.							in back.							out nextPut: token ] ] ].	^ out contents! !!SexpLexer methodsFor: 'private' stamp: 'EiichiroIto 8/2/2019 10:50'!whiteSpaces	^ String cr, String lf, String space, String tab! !!SexpParser methodsFor: 'accessing' stamp: 'EiichiroIto 8/2/2019 11:13'!parse: aCollection	| in |	in := ReadStream on: aCollection.	^ self parseItem: in! !!SexpParser methodsFor: 'private' stamp: 'EiichiroIto 8/2/2019 11:29'!parseItem: aStream	| token list |	aStream atEnd		ifTrue: [ ^ nil ].	token := aStream next.	token = $(		ifTrue: [ list := OrderedCollection new.			self parseItems: aStream to: list.			^ list asArray ].	^ token! !!SexpParser methodsFor: 'private' stamp: 'EiichiroIto 8/2/2019 11:26'!parseItems: aStream to: aCollection	| item |	[ item := self parseItem: aStream.	item notNil ]		whileTrue: [ item = $)				ifTrue: [ ^ self ].			aCollection add: item ].	self error! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 07:31'!add: aString className: aSymbol	| id |	self setupVarNames.	id := (self includes: aString)		ifTrue: [ self varNoFor: aString ]		ifFalse: [ varNames := varNames copyWith: aString.			varNames size ].	classNames at: id put: aSymbol.	^ id! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/26/2019 22:15'!addComputedVariable: aString varNo: anInteger	^ self addReserved: aString varNo: anInteger className: nil! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/26/2019 08:07'!addList: aString	^ self add: aString className: #Array! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 08:55'!addReserved: aString varNo: anInteger className: aSymbol	classNames at: anInteger put: aSymbol.	reservedVarNames size < anInteger		ifTrue: [ reservedVarNames := reservedVarNames				forceTo: anInteger				paddingWith: nil ].	reservedVarNames at: anInteger put: aString.	^ anInteger! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/26/2019 22:15'!addReservedVariable: aString varNo: anInteger	^ self addReserved: aString varNo: anInteger className: #FloatArray! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/26/2019 11:14'!addVariable: aString	^ self add: aString className: #FloatArray! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/26/2019 08:04'!allVarNames	| list |	list := classNames keys		select: [ :each | (classNames at: each) notNil ].	^ list collect: [ :each | varNames at: each ]! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 9/24/2019 21:49'!classFor: aString	| vno className |	vno := self varNoFor: aString.	className := self classNameForVarNo: vno.	className ifNil: [ ^ nil ].	^ LazyArray className: className! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/26/2019 08:04'!classNameForVarNo: anInteger	^ classNames at: anInteger! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/27/2019 07:39'!delete: aString	| vno |	(self includes: aString)		ifFalse: [ self error: 'cannot delete not existing var' ].	(self isReserved: aString)		ifTrue: [ self error: 'cannot delete reserved var' ].	vno := self varNoFor: aString.	varNames := varNames copyWithout: aString.	classNames removeKey: vno! !!VarDef methodsFor: 'object i/o' stamp: 'EiichiroIto 9/13/2018 20:49'!fieldsVersion	^ 1! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/26/2019 19:24'!fixVars	varNames := varNames asOrderedCollection removeDuplicates.	self regularize! !!VarDef methodsFor: 'testing' stamp: 'EiichiroIto 9/8/2018 19:23'!includes: aString	^ varNames includes: aString! !!VarDef methodsFor: 'object i/o' stamp: 'EiichiroIto 11/28/2019 20:48'!initFieldsFrom: anObjStream version: classVersion	self initFieldsNamed: #(varNames classNames) from: anObjStream.	varNames ifNotNil: [ self regularize ]! !!VarDef methodsFor: 'initialization' stamp: 'EiichiroIto 11/27/2019 18:21'!initialize	super initialize.	varNames := nil.	reservedVarNames := Array new.	classNames := Dictionary new.	self setupReservedVarNames! !!VarDef methodsFor: 'testing' stamp: 'EiichiroIto 11/26/2019 21:50'!isReserved: aString	^ reservedVarNames includes: aString! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/26/2019 08:05'!listNames	| list |	list := classNames keys		select: [ :each | (classNames at: each) notNil ].	list := list select: [ :each | (classNames at: each) = #Array ].	^ list collect: [ :each | varNames at: each ]! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 11/26/2019 08:04'!privClassNames	^ classNames! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 11/26/2019 21:27'!privReservedVarNames	^ reservedVarNames! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 11/26/2019 21:28'!privReservedVarNames: aCollection	reservedVarNames := aCollection! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 9/8/2018 19:16'!privVarNames	^ varNames! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 9/8/2018 19:17'!privVarNames: anObject	varNames := anObject.! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 9/29/2019 17:10'!realVarNames	^ self varNames		withIndexSelect: [ :each :index | (self classNameForVarNo: index) notNil ]! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 21:24'!regularize	varNames := varNames copyWithoutAll: reservedVarNames.	varNames := reservedVarNames , varNames.	varNames := varNames asArray! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 11/26/2019 21:48'!reservedNo	^ reservedVarNames size! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 08:52'!setupReservedVarNames	"do nothing"! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 07:31'!setupVarNames	varNames ifNotNil: [ ^ self ].	reservedVarNames		do: [ :each | each ifNil: [ self error: 'reservedVarNames has nil' ] ].	varNames := reservedVarNames copy! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 9/10/2018 19:18'!size	^ varNames size! !!VarDef methodsFor: 'object i/o' stamp: 'EiichiroIto 11/27/2019 08:49'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(varNames classNames) on: anObjStream.! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/27/2019 07:50'!userDefinedVarNames	^ self varNames reject: [ :each | reservedVarNames includes: each ]! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 11/27/2019 07:45'!userDefinedVarNoAndNames	^ self userDefinedVarNames		collect: [ :each | 			{(self varNoFor: each).			each} ]! !!VarDef methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 07:50'!varNames	^ varNames ifNil: [ #() ]! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:47'!varNoFor: aString	(self includes: aString)		ifFalse: [ ^ NotFound signalFor: self ].	^ varNames indexOf: aString! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/22/2019 19:51'!clear	vars ifNil: [ ^ self ].	vars do: [ :each | each ifNotNil: #reset ].! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 9/28/2019 19:17'!clearVarNo: anInteger	(self varAt: anInteger) reset.! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 3/18/2019 16:13'!copyElementFrom: anInteger1 to: anInteger2	vars do: [ :each | each at: anInteger2 put: (each at: anInteger1) ].! !!Variables methodsFor: 'object i/o' stamp: 'EiichiroIto 9/13/2018 20:50'!fieldsVersion	^ 1! !!Variables methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 21:10'!fixVars: varId	| desirableClass |	self updateVarDef: varId.	vars		withIndexDo: [ :each :index | 			each				ifNotNil: [ desirableClass := varId classNameForVarNo: index.					desirableClass						ifNil: [ vars at: index put: nil ]						ifNotNil: [ each className ~= desirableClass								ifTrue: [ self error. vars at: index put: (each className: desirableClass) ] ] ] ]! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 9/23/2019 22:18'!forceSize: anInteger	vars		withIndexDo: [ :each :index | each ifNotNil: [ each forceSize: anInteger ] ]! !!Variables methodsFor: 'object i/o' stamp: 'EiichiroIto 9/13/2018 21:33'!initFieldsFrom: anObjStream version: classVersion	self initFieldsNamed: #(vars varNames) from: anObjStream.! !!Variables methodsFor: 'initialization' stamp: 'EiichiroIto 9/23/2019 21:12'!initialize	varNames := #().	vars := nil.! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 9/23/2019 21:09'!max	^ (vars collect: #size) max! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/29/2019 14:27'!multiply: vno by: aNumber	vno = 0		ifTrue: [ ^ self ].	^ (self varAt: vno) multiplyBy: aNumber! !!Variables methodsFor: 'private' stamp: 'EiichiroIto 9/8/2018 20:17'!privVarNames	^ varNames! !!Variables methodsFor: 'private' stamp: 'EiichiroIto 9/8/2018 20:17'!privVarNames: aCollection	varNames := aCollection.! !!Variables methodsFor: 'private' stamp: 'EiichiroIto 9/8/2018 19:52'!privVars	^ vars! !!Variables methodsFor: 'private' stamp: 'EiichiroIto 9/8/2018 19:52'!privVars: aCollection	vars := aCollection! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 9/28/2019 19:10'!realArrayAt: anInteger	^ (self varAt: anInteger) array! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 9/28/2019 19:17'!setVar: anInteger toAll: anObject	(self varAt: anInteger asInteger)		in:			[ :variable | 1 to: variable size do: [ :each | variable at: each put: anObject ] ]! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 9/28/2019 19:20'!setVar: anInteger toArray: aCollection	(self varAt: anInteger) setArray: aCollection.! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/18/2019 18:39'!size	^ self max! !!Variables methodsFor: 'object i/o' stamp: 'EiichiroIto 9/13/2018 21:33'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(vars varNames) on: anObjStream.! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 21:33'!updateVarDef: aVarId	| newVarNames newVars index class size |	size := nil.	newVarNames := aVarId varNames asArray.	varNames = newVarNames		ifTrue: [ ^ self ].	newVars := newVarNames		collect: [ :each | 			index := varNames indexOf: each.			index = 0				ifTrue: [ class := aVarId classFor: each.					(class notNil and: [ size notNil ])						ifTrue: [ class forceSize: size ] ]				ifFalse: [ class := vars at: index.					(class notNil and: [ class isFixed ])						ifTrue: [ size := class fixedSize ] ].			class ].	vars := newVars.	varNames := newVarNames! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 9/28/2019 19:08'!var: anInteger at: id	id = 0		ifTrue: [ ^ 0 ].	^ (self varAt: anInteger asInteger) at: id! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 9/28/2019 19:08'!var: anInteger at: id put: anObject	id = 0		ifTrue: [ ^ self ].	(self varAt: anInteger asInteger) at: id put: anObject.! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:39'!var: anInteger list: id add: anObject	(self varAt: anInteger asInteger) list: id add: anObject! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:39'!var: anInteger list: id at: anInteger2	^ (self varAt: anInteger asInteger) list: id at: anInteger2! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:39'!var: anInteger list: id at: anInteger2 put: aNumber	(self varAt: anInteger asInteger) list: id at: anInteger2 put: aNumber! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:39'!var: anInteger list: id contains: anInteger2	^ (self varAt: anInteger asInteger) list: id contains: anInteger2! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:39'!var: anInteger list: id remove: anObject	(self varAt: anInteger asInteger) list: id remove: anObject! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:39'!var: anInteger list: id set: aCollection	(self varAt: anInteger asInteger) list: id set: aCollection! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 10/28/2019 20:39'!var: anInteger listSizeOf: id	^ (self varAt: anInteger asInteger) listSizeOf: id! !!Variables methodsFor: 'accessing' stamp: 'EiichiroIto 9/28/2019 19:07'!varAt: anInteger	^ vars at: anInteger! !!Number methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 22:26'!asNumberNoError	^ self! !!Number methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/29/2016 20:18'!hhmmss	^ self rounded hhmmss! !!Number methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/29/2016 06:45'!localized	^ self! !!ColorForm methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/27/2016 21:46'!privateColors	^ colors! !!ColorForm methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/14/2018 08:43'!privateColors: anObject	colors := anObject.	cachedDepth := nil.	cachedColormap := nil! !!ArgMorph class methodsFor: 'class initialization' stamp: 'jm 6/22/2007 12:49'!initialize	"self initialize"	DropDownMenuForm := Form		extent: 7@4		depth: 1		fromArray: #(4261412864 2080374784 939524096 268435456)		offset: 0@0.	DropDownMenuForm := DropDownMenuForm colorReduced.  "become a ColorForm"	DropDownMenuForm colors:		(Array with: Color transparent with: (Color gray: 0.25)).! !!ArgMorph methodsFor: 'other' stamp: 'jm 7/7/2004 00:23'!acceptsDroppedReporters	"Answer true if I accept dropped reporter blocks. Answer false by default."	^ false! !!ArgMorph methodsFor: 'other' stamp: 'jm 3/28/2005 19:18'!acceptsTypeOf: aBlockMorph	"Answer true if I can accept a dropped reporter of the given type. Answer false by default."	^ false! !!ArgMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator argString: self.! !!ArgMorph methodsFor: 'other' stamp: 'jm 3/28/2005 15:12'!defaultValue: anObject	"Set my default value. This default implementation does nothing."! !!ArgMorph methodsFor: 'drawing' stamp: 'jm 3/28/2005 16:00'!drawHLineFrom: startX to: endX y: yOffset color: c on: aCanvas	| y |	y := self top + yOffset.	aCanvas		fillRectangle: ((self left + startX)@y corner: (self left + endX)@(y + 1))		color: c.! !!ArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:25'!fieldsVersion	^ 1! !!ArgMorph methodsFor: 'other' stamp: 'jm 8/24/2003 16:57'!fixArgLayout	"Fix my layout. This default implementation does nothing."! !!ArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:25'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		labelMorph	) from: anObjStream.! !!ArgMorph methodsFor: 'other' stamp: 'jm 12/9/2008 17:31'!isArgMorph	"True only for ArgMorphs."	^ true! !!ArgMorph methodsFor: 'other' stamp: 'jm 3/15/2003 12:21'!isReporter	"Answer true since every ArgMorph reports a value."	^ true! !!ArgMorph methodsFor: 'other' stamp: 'jm 10/21/2003 12:32'!labelMorph	^ labelMorph! !!ArgMorph methodsFor: 'other' stamp: 'jm 3/14/2009 14:08'!printArgOn: aStream	"Print this argument morph on the given stream."	| v |	self labelMorph ifNotNil: [		v := self evaluate.		(v isKindOf: String)			ifTrue: [aStream nextPutAll: '"', v, '"']			ifFalse: [aStream nextPutAll: v asString]].! !!ArgMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/20/2019 06:17'!project	^ owner ifNotNil: [ owner project ]! !!ArgMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/21/2019 17:53'!rootMorph	owner ifNil: [ ^ self ].	^ self rootMorph! !!ArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:33'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		labelMorph	) on: anObjStream.! !!BooleanArgMorph methodsFor: 'other' stamp: 'jm 7/7/2004 00:24'!acceptsDroppedReporters	^ true! !!BooleanArgMorph methodsFor: 'other' stamp: 'jm 3/28/2005 19:15'!acceptsTypeOf: aBlockMorph	"Answer true if I can accept a dropped reporter of the givent type."	^ aBlockMorph isBooleanReporter! !!BooleanArgMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator booleanArgString: self.! !!BooleanArgMorph methodsFor: 'drawing' stamp: 'jm 3/28/2005 16:42'!drawOn: aCanvas 	| h s v darkerC lighterC right topY bottomY xInset c |	h := color hue.	s := color saturation.	v := color brightness.	darkerC := Color h: h s: (s - 0.3) v: (v - 0.3).	lighterC := Color h: h s: (s - 0.2) v: (v + 0.2).	right := self width.	topY := bottomY := self height // 2.	self height even ifTrue: [topY := bottomY - 1].	xInset := 0.	[topY >= 0] whileTrue: [		self drawHLineFrom: xInset to: (xInset + 2) y: topY color: darkerC on: aCanvas.		c := (topY <= 1) ifTrue: [darkerC] ifFalse: [color].		self drawHLineFrom: xInset + 2 to: right - (xInset + 1) y: topY color: c on: aCanvas.		self drawHLineFrom: (right - (xInset + 1)) to: (right - xInset) y: topY color: darkerC on: aCanvas.		self drawHLineFrom: xInset to: (xInset + 1) y: bottomY color: lighterC on: aCanvas.		c := (bottomY >= (self height - 2)) ifTrue: [lighterC] ifFalse: [color].		self drawHLineFrom: xInset + 1 to: right - (xInset + 1) y: bottomY color: c on: aCanvas.		self drawHLineFrom: (right - (xInset + 2)) to: (right - xInset) y: bottomY color: lighterC on: aCanvas.		xInset := xInset + 1.			bottomY := bottomY + 1.		topY := topY - 1].! !!BooleanArgMorph methodsFor: 'evaluation' stamp: 'jm 7/1/2004 11:32'!evaluate	"Answer false by default."	^ false! !!BooleanArgMorph methodsFor: 'other' stamp: 'jm 4/1/2005 20:38'!fixArgLayout	"Set my color to my owner's color."	self color: (owner color mixed: 0.7 with: (Color gray: 0.4)).! !!BooleanArgMorph methodsFor: 'initialization' stamp: 'jm 3/28/2005 16:33'!initialize	super initialize.	self color: (Color r: 0.451 g: 0.866 b: 0.109).	self extent: 25@13.! !!BooleanArgMorph methodsFor: 'drawing' stamp: 'jm 3/28/2005 16:03'!isRectangular	^ false! !!BooleanArgMorph methodsFor: 'other' stamp: 'jm 8/31/2006 09:17'!printArgOn: aStream	"Print this argument morph on the given stream."	aStream nextPutAll: 'false'.! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 18:26'!choice	^ choice! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 16:36'!choice: aSymbol	"Update the toggle button when an argument is changed within a block."	| block doLocalization label |	"frame := self meOrOwnerThatIsA: ScratchFrameMorph."	"((#soundNames = getOptionsSelector) and:	 [aSymbol = ('record' localized, ScratchTranslator ellipsesSuffix)]) ifTrue: [		frame ifNotNil: [^ frame newSound]]."	"((#sceneNames = getOptionsSelector) and:	 [aSymbol = ('record' localized, ScratchTranslator ellipsesSuffix)]) ifTrue: [		frame ifNotNil: [^ frame workPane newScene]]."	"((#sceneNames = getOptionsSelector) and:	 [aSymbol = ('re-record' localized, ScratchTranslator ellipsesSuffix)]) ifTrue: [		frame ifNotNil: [^ frame workPane rerecordScene]]."	choice := label := aSymbol.	(label isKindOf: String) ifFalse: [label := label asString].	doLocalization := (#( varNames ) includes: getOptionsSelector) not.	doLocalization		ifTrue:[labelMorph contents: label localized]		ifFalse:[labelMorph contents: label].	labelMorph position: self position + borderWidth + (3 @ -1).	labelMorph layoutChanged; changed.	self extent: (labelMorph extent + (16@2) + borderWidth).	menuIconMorph position: (self right - borderWidth - 10)@(self top + borderWidth + 4).	(block := self meOrOwnerThatIsA: HatBlockMorph) ifNotNil: [		block fixBlockLayout].	"(palette := self meOrOwnerThatIsA: ScratchBlockPaletteMorph) ifNil: [^ self].	(block := self meOrOwnerThatIsA: BlockMorph) ifNil: [^ self]."	"block isReporter ifTrue: [palette updateWatcherButtonsForFrame: frame]."! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'jm 3/28/2005 15:13'!defaultValue: aString	"Set my default value."	self choice: aString.! !!ChoiceArgMorph methodsFor: 'other' stamp: 'jm 8/24/2003 18:33'!evaluate	"Answer my value."	isBoolean ifTrue: [^ 'true' = choice].	^ choice! !!ChoiceArgMorph methodsFor: 'object i/o' stamp: 'jm 5/14/2004 11:39'!fieldsVersion	^ 2! !!ChoiceArgMorph methodsFor: 'other' stamp: 'jm 4/1/2005 20:33'!fixArgLayout	"Set my color to my owner's color."	self color: (owner color mixed: 0.75 with: (Color gray: 0.45)).! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'jm 8/6/2008 20:54'!getOptionsSelector	^ getOptionsSelector! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'jm 5/14/2004 11:50'!getOptionsSelector: aSymbolOrString	"Set a selector that is used to get a set of options from my command block's receiver. This is used when the options can change over time, such as selecting from a list of available sounds or costumes in the objects media library."	getOptionsSelector := aSymbolOrString asSymbol.! !!ChoiceArgMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/3/2019 21:26'!handlesMouseDown: evt	^ "evt hand toolType isNil and:		["		(self topRight - (14@0) corner: self bottomRight) containsPoint: evt cursorPoint		"]"! !!ChoiceArgMorph methodsFor: 'object i/o' stamp: 'jm 5/14/2004 11:54'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		isBoolean		options		choice	) from: anObjStream.	classVersion = 1 ifTrue: [^ self].	"fields added in version 2"	self initFieldsNamed: #(		getOptionsSelector	) from: anObjStream.! !!ChoiceArgMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 21:27'!initialize	super initialize.	self borderInset.	self borderWidth: 1.	self color: Color brown.	labelMorph := StringMorph new		font: (ScratchTheme argFont);		color: Color white.	self addMorph: labelMorph.	menuIconMorph := ImageMorph new form: DropDownMenuForm.	self addMorphFront: menuIconMorph.	isBoolean := false.	options := #(a b c d).	self choice: #a.! !!ChoiceArgMorph methodsFor: 'event handling' stamp: 'jm 12/13/2006 21:35'!mouseDown: evt	self presentMenu.! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'jm 6/10/2004 10:49'!options	"Answer my set of options. If getOptionsSelector is not nil and I'm in a CommandBlock with a non-nil receiver, fetch my set of options by sending getOptionsSelector to that receiver."	(getOptionsSelector notNil and:	 [(owner respondsTo: #receiver) and:	 [owner receiver notNil]]) ifTrue: [		^ owner receiver perform: getOptionsSelector].	^ options! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 18:32'!options: stringList	options := stringList asArray.	(options includes: choice) ifFalse: [self choice: options first].! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 16:36'!presentMenu	"Pop up a menu of choices."	| optionList doLocalization menu selection option |	optionList := self options.	optionList size = 0		ifTrue: [ ^ self ].	doLocalization := (#(varNames ) includes: getOptionsSelector) not.	menu := MenuMorph new.	menu target: [ :v | selection := v ].	optionList		do: [ :sym | 			'-' = sym				ifTrue: [ menu addLine ]				ifFalse: [ doLocalization						ifTrue: [ option := sym localized ]						ifFalse: [ option := sym ].					menu add: option selector: #value: argument: sym ] ].	menu invokeAt: ActiveHand position in: self world.	selection ifNotNil: [ self choice: selection ].! !!ChoiceArgMorph methodsFor: 'other' stamp: 'jm 10/30/2005 08:32'!printArgOn: aStream	"Print this argument morph on the given stream."	aStream nextPutAll: '"', self labelMorph contents, '"'.! !!ChoiceArgMorph methodsFor: 'object i/o' stamp: 'jm 5/14/2004 11:54'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		isBoolean		options		choice		getOptionsSelector	) on: anObjStream.! !!ChoiceArgMorph methodsFor: 'event handling' stamp: 'jm 12/14/2004 11:51'!wantsKeyboardFocusFor: aSubmorph	"Don't allow shift-click editing of block labels."	^ false! !!ChoiceOrExpressionArgMorph methodsFor: 'queries' stamp: 'jm 11/28/2006 13:19'!acceptsDroppedReporters	^ true! !!ChoiceOrExpressionArgMorph methodsFor: 'queries' stamp: 'jm 11/28/2006 13:19'!acceptsTypeOf: aBlockMorph	"Answer true if I can accept a dropped reporter of the given type."	aBlockMorph isReporter ifFalse: [^ false].	^ aBlockMorph isBooleanReporter not  "must be a number"! !!ColorArgMorph class methodsFor: 'class initialization' stamp: 'jm 6/25/2004 13:54'!colorPaletteExtent: extent	"Answer a form containing a palette of colors sorted horizontally by hue and vertically by lightness."	"(self colorPaletteExtent: 180@100) display"	| palette grayWidth startHue vSteps hSteps x basicHue y c |	palette := Form extent: extent depth: 32.	grayWidth := 10.	startHue := 338.0.	vSteps := palette height // 2.	hSteps := palette width - grayWidth.	x := 0.	startHue to: startHue + 360.0 by: 360.0 / hSteps do: [:h |		basicHue := Color h: h asFloat s: 1.0 v: 1.0.		y := 1.		0 to: vSteps do: [:n | 			c := basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		1 to: vSteps do: [:n | 			c := Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		x := x + 1].	y := 1.	1 to: vSteps * 2 do: [:n | 		c := Color black mixed: (n asFloat / (2 * vSteps) asFloat) with: Color white.		palette fill: (x@y extent: 10@1) fillColor: c.		y := y + 1].	^ palette! !!ColorArgMorph class methodsFor: 'class initialization' stamp: 'jm 6/28/2004 10:41'!initialize	"self initialize. ColorPalette display"	ColorPalette := self colorPaletteExtent: 150@100.! !!ColorArgMorph methodsFor: 'other' stamp: 'jm 3/23/2005 18:12'!defaultValue: aColor	self setColor: aColor.! !!ColorArgMorph methodsFor: 'other' stamp: 'DaveF 7/11/2003 18:37'!evaluate	"Answer my color."	^ color! !!ColorArgMorph methodsFor: 'object i/o' stamp: 'jm 3/14/2004 13:08'!fieldsVersion	^ 1! !!ColorArgMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/3/2019 21:26'!handlesMouseDown: evt	^ true "evt hand toolType isNil"! !!ColorArgMorph methodsFor: 'other' stamp: 'jm 10/30/2005 09:01'!hexFor: aNumber	"Answer a string representing the given number, rounded, in hexadecimal."	| s |	s := (255.0 * aNumber) rounded hex.	s := s copyFrom: 4 to: s size.	s := (String new: 2 - s size withAll: $0), s.  "pad to two digits"	^ s! !!ColorArgMorph methodsFor: 'initialization' stamp: 'jm 3/28/2005 18:15'!initialize	super initialize.	self borderColor: (Color gray: 0.4).	self borderWidth: 1.	self extent: 13@13.	showPalette := true.! !!ColorArgMorph methodsFor: 'event handling' stamp: 'EiichiroIto 10/3/2016 10:23'!mouseUp: evt	| w palette |	showPalette ifNil: [showPalette := true].	(w := self world) ifNil: [^ self].	showPalette ifTrue: [		palette := ImageMorph new form: ColorPalette.		palette position: self bounds bottomLeft + (0@5).		w addMorph: palette.		w displayWorldSafely].	self pickColor.	palette ifNotNil: [palette delete].! !!ColorArgMorph methodsFor: 'private' stamp: 'EiichiroIto 10/3/2016 10:41'!pickColor	"Pick a colour from the screen."	| position c hand |	hand := self activeHand.	hand showTemporaryCursor: Cursor eyeDropper.	hand		captureEventsUntil: [ :evt | 			evt isMove				ifTrue: [ 					position := evt position.					c := Color colorFromPixelValue: ((Display pixelValueAt: position) bitOr: 16rFF000000) depth: 32.					hand position: position.					self color: c.					owner invalidRect: self bounds ].			hand anyButtonPressed ].	hand showTemporaryCursor: nil! !!ColorArgMorph methodsFor: 'other' stamp: 'jm 10/30/2005 09:07'!printArgOn: aStream	"Print this argument morph on the given stream."	aStream nextPutAll: 'c[',		(self hexFor: color red),		(self hexFor: color green),		(self hexFor: color blue),		']'.! !!ColorArgMorph methodsFor: 'other' stamp: 'jm 3/11/2004 14:21'!setColor: aColor	"Make sure the color is not translucent."	self color: (aColor alpha: 1.0).! !!ColorArgMorph methodsFor: 'other' stamp: 'jm 3/11/2004 11:55'!showPalette: aBoolean	showPalette := aBoolean.! !!EventTitleMorph methodsFor: 'queries' stamp: 'jm 5/15/2008 13:44'!acceptsDroppedReporters	"Accept reporter blocks in broadcast blocks but not in 'when I receive' hat block."	^ owner isKindOf: CommandBlockMorph! !!EventTitleMorph methodsFor: 'queries' stamp: 'jm 5/15/2008 13:40'!acceptsTypeOf: aBlockMorph	"Answer true if I can accept a dropped reporter of the given type."	aBlockMorph isReporter ifFalse: [^ false].	^ aBlockMorph isBooleanReporter not! !!EventTitleMorph methodsFor: 'code generation' stamp: 'EiichiroIto 10/9/2018 17:00'!argString: aGenerator	^ aGenerator eventTitleArgString: self! !!EventTitleMorph methodsFor: 'accessing' stamp: 'jm 3/28/2005 15:21'!defaultValue: aString	self eventName: aString.! !!EventTitleMorph methodsFor: 'accessing' stamp: 'jm 12/17/2004 17:01'!evaluate	^ self eventName! !!EventTitleMorph methodsFor: 'accessing' stamp: 'jm 8/11/2004 18:42'!eventName	^ labelMorph contents! !!EventTitleMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/29/2016 17:36'!eventName: aString	| block |	labelMorph contents: aString asString.	labelMorph position: self position + borderWidth + (3 @ -1).	self extent: (labelMorph extent + (16@2) + borderWidth).	menuIconMorph position: (self right - borderWidth - 10)@(self top + borderWidth + 4).	(block := self meOrOwnerThatIsA: HatBlockMorph) ifNotNil: [		block fixBlockLayout].! !!EventTitleMorph methodsFor: 'object i/o' stamp: 'jm 5/11/2005 10:49'!fieldsVersion	^ super fieldsVersion! !!EventTitleMorph methodsFor: 'accessing' stamp: 'jm 4/1/2005 20:34'!fixArgLayout	"Set my color to my owner's color."	self color: (owner color mixed: 0.75 with: (Color gray: 0.4)).! !!EventTitleMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/3/2019 21:26'!handlesMouseDown: evt	^ "evt hand toolType isNil and:		["		(self topRight - (14@0) corner: self bottomRight) containsPoint: evt cursorPoint		"]"! !!EventTitleMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 21:27'!initialize	super initialize.	self borderInset.	self borderWidth: 1.	self color: Color brown.	menuIconMorph := ImageMorph new form: DropDownMenuForm.	self addMorphFront: menuIconMorph.	labelMorph := StringMorph new		font: (ScratchTheme argFont);		color: Color white.	self addMorph: labelMorph.	self eventName: ''.! !!EventTitleMorph methodsFor: 'event handling' stamp: 'jm 12/13/2006 21:33'!mouseDown: evt	self presentMenu.! !!EventTitleMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/20/2019 07:21'!presentMenu	"Pop up a menu of choices."	| eventNames project menu choice s |	eventNames := #().	(project := self project)		ifNotNil: [ eventNames := project allEventNames ].	menu := MenuMorph new.	menu target: [ :v | choice := v ].	eventNames		do: [ :n | menu add: n selector: #value: argument: n asString ].	menu addLine.	menu		add: 'new' localized , ScratchTranslator ellipsesSuffix		selector: #value:		argument: #newEvent.	menu invokeAt: ActiveHand position in: self world.	choice ifNil: [ ^ self ].	choice == #newEvent		ifTrue: [ s := UIManager default request: 'Message name:'.			(s isNil or: [ s isEmpty ])				ifTrue: [ ^ self ].			^ self eventName: s ].	self eventName: choice! !!EventTitleMorph methodsFor: 'accessing' stamp: 'jm 10/30/2005 08:40'!printArgOn: aStream	"Print this argument morph on the given stream."	aStream nextPut: $".	aStream nextPutAll: self labelMorph contents.	aStream nextPut: $".! !!EventTitleMorph methodsFor: 'event handling' stamp: 'jm 12/14/2004 11:53'!wantsKeyboardFocusFor: aSubmorph	"Don't allow shift-click editing of block labels."	^ false! !!ExpressionArgMorph methodsFor: 'queries' stamp: 'jm 7/7/2004 00:24'!acceptsDroppedReporters	^ true! !!ExpressionArgMorph methodsFor: 'queries' stamp: 'jm 11/28/2006 13:14'!acceptsTypeOf: aBlockMorph	"Answer true if I can accept a dropped reporter of the given type."	aBlockMorph isReporter ifFalse: [^ false].	^ isNumber not or: [aBlockMorph isBooleanReporter not]! !!ExpressionArgMorph methodsFor: 'accessing' stamp: 'jm 5/7/2009 13:29'!defaultValue: anObject	anObject isNumber ifTrue: [self numExpression: anObject].	(anObject isKindOf: String) ifTrue: [self stringExpression: anObject].! !!ExpressionArgMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/25/2016 22:56'!defaultValueFromSpec: anObject	"Like defaultValue:, but '-' in a block spec creates an empty number expression."	self defaultValue: anObject.	'-' = anObject ifTrue: [self numExpression: ' '].  "empty, evaluates to zero"! !!ExpressionArgMorph methodsFor: 'drawing' stamp: 'EiichiroIto 9/5/2018 22:10'!drawOn: aCanvas 	| darkerC right topY bottomY radius xInset c c2 |	isNumber ifFalse: [^ super drawOn: aCanvas].	c2 := self color.	darkerC := c2 darker.	right := self width.	topY := bottomY := radius := self height // 2.	self height even ifTrue: [topY := bottomY - 1].	[topY >= 0] whileTrue: [		xInset := radius - (radius squared - (radius - topY - 1) squared) sqrt rounded.		self drawHLineFrom: xInset to: (xInset + 1) y: topY color: darkerC on: aCanvas.		c := (topY < 1) ifTrue: [darkerC] ifFalse: [c2].		self drawHLineFrom: xInset + 1 to: right - (xInset + 1) y: topY color: c on: aCanvas.		self drawHLineFrom: (right - (xInset + 1)) to: (right - xInset) y: topY color: darkerC on: aCanvas.		self drawHLineFrom: xInset to: right - xInset y: bottomY color: c2 on: aCanvas.		xInset = 0 ifTrue: [			self drawHLineFrom: xInset + 1 to: xInset + 2 y: topY color: c2 on: aCanvas.			self drawHLineFrom: xInset to: xInset + 1 y: bottomY color: darkerC on: aCanvas.			self drawHLineFrom: (right - (xInset + 1)) to: (right - xInset) y: bottomY color: darkerC on: aCanvas].		bottomY := bottomY + 1.		topY := topY - 1].! !!ExpressionArgMorph methodsFor: 'evaluation' stamp: 'EiichiroIto 9/26/2016 13:44'!evaluate	"Answer the result of evaluating my expression in the context of the given ScratchProcess."	| expr |	expr := labelMorph savedContents.	isNumber		ifTrue: [^ expr asNumberNoError]		ifFalse: [^ expr].  "string"! !!ExpressionArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:19'!fieldsVersion	^ 1! !!ExpressionArgMorph methodsFor: 'private' stamp: 'EiichiroIto 11/22/2019 15:14'!fixArgLayout	| top xInset extraW |	top := self top.	isNumber		ifTrue: [ self extent: labelMorph extent + (5 @ 0).			"tiny vertical adjustment to account for differences in string rendering"			"Smalltalk isWindows ifFalse: ["			top := top + 1.	"]"			"for tall fonts, add extra width"			extraW := self height - (1.3 * self width) rounded max: 0.			extraW > 0				ifTrue: [ self width: self width + extraW ].			xInset := 4 + (extraW // 2) ]		ifFalse: [ self extent: labelMorph extent + (2 @ 0).			xInset := 3 ].	labelMorph position: (self left + xInset) @ top! !!ExpressionArgMorph methodsFor: 'object i/o' stamp: 'jm 6/21/2004 17:57'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		isNumber	) from: anObjStream.! !!ExpressionArgMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 21:28'!initialize	super initialize.	isNumber := true.	self borderWidth: 1.	self borderInset.	self color: ScratchTheme blockArgColor.	self extent: 25 @ 12.	"To allow for editing in place."	labelMorph := StringFieldMorph new		forExpressionArg;		doResizing: true;		font: (ScratchTheme argFont);		color: Color transparent.	self addMorph: labelMorph.	self numExpression: '10'.! !!ExpressionArgMorph methodsFor: 'drawing' stamp: 'jm 5/8/2008 12:14'!isNumberExpression	^ isNumber! !!ExpressionArgMorph methodsFor: 'drawing' stamp: 'jm 3/28/2005 17:12'!isRectangular	^ isNumber not! !!ExpressionArgMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/15/2016 17:21'!numExpression: aNumber	isNumber := true.	labelMorph isNumeric: true.	aNumber isFloat		ifTrue: [labelMorph contents: aNumber printString]		ifFalse: [labelMorph contents: aNumber asString].	self fixArgLayout.! !!ExpressionArgMorph methodsFor: 'object i/o' stamp: 'jm 6/21/2004 17:57'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		isNumber	) on: anObjStream.! !!ExpressionArgMorph methodsFor: 'accessing' stamp: 'jm 7/1/2008 11:45'!stringExpression: aString	isNumber := false.	labelMorph isNumeric: false.	labelMorph contents: aString.	self fixArgLayout.! !!ExpressionArgMorphWithMenu class methodsFor: 'class initialization' stamp: 'jm 3/29/2005 20:43'!initialize	"self initialize"	DropDownMenuForm := Form		extent: 7@4		depth: 1		fromArray: #(4261412864 2080374784 939524096 268435456)		offset: 0@0.	DropDownMenuForm := DropDownMenuForm colorReduced.  "become a ColorForm"	DropDownMenuForm colors:		(Array with: Color transparent with: (Color gray: 0.25)).! !!ExpressionArgMorphWithMenu methodsFor: 'code generation' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator expressionArgWithMenuString: self.! !!ExpressionArgMorphWithMenu methodsFor: 'accessing' stamp: 'EiichiroIto 10/5/2018 22:07'!defaultValue: anObject	(anObject isKindOf: String)		ifTrue: [self specialValue: anObject]		ifFalse: [super defaultValue: anObject].! !!ExpressionArgMorphWithMenu methodsFor: 'evaluation' stamp: 'jm 5/6/2008 18:57'!evaluate	"Answer the result of evaluating my expression in the context of the given ScratchProcess."	specialValue ifNotNil: [^ specialValue].	^ super evaluate! !!ExpressionArgMorphWithMenu methodsFor: 'object i/o' stamp: 'jm 5/6/2008 19:21'!fieldsVersion	^ 2! !!ExpressionArgMorphWithMenu methodsFor: 'private' stamp: 'jm 7/4/2008 17:27'!fixArgLayout	| dx |	dx := 9.	super fixArgLayout.	menuMorph ifNil: [^ self].	self width: self width + dx.	menuMorph position: (self right - dx - 2)@(self top + (self height // 3)).	(thisContext sender receiver isKindOf: StringFieldMorph) ifTrue: [		"clear only when user edit my label, but not on other arg layout changes"		specialValue := nil].! !!ExpressionArgMorphWithMenu methodsFor: 'event handling' stamp: 'jm 1/23/2007 12:37'!handlesMouseDown: evt	^ menuMorph notNil! !!ExpressionArgMorphWithMenu methodsFor: 'object i/o' stamp: 'jm 5/6/2008 19:23'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		menuMorph		getMenuSelector	) from: anObjStream.	classVersion = 1 ifTrue: [^ self].	"field added in version 2"	self initFieldsNamed: #(		specialValue	) from: anObjStream.! !!ExpressionArgMorphWithMenu methodsFor: 'accessing' stamp: 'jm 5/8/2008 12:08'!menuSelector	^ getMenuSelector! !!ExpressionArgMorphWithMenu methodsFor: 'accessing' stamp: 'jm 12/17/2004 12:54'!menuSelector: menuSelector	"Add a drop-down menu button with the given selector. The selector should result in a menu whose action items are values that can be put into this type argument, typically numbers or strings."	menuMorph := ImageMorph new form: DropDownMenuForm.	getMenuSelector := menuSelector.	self addMorphFront: menuMorph.	self fixArgLayout.! !!ExpressionArgMorphWithMenu methodsFor: 'event handling' stamp: 'EiichiroIto 10/5/2018 22:07'!mouseDown: evt	| rcvr menu choice ret |	menuMorph ifNil: [ ^ super mouseDown: evt ].	evt cursorPoint x < (menuMorph left - 1)		ifTrue: [ ^ super mouseDown: evt ].	(getMenuSelector notNil		and: [ (owner isKindOf: BlockMorph) and: [ (rcvr := owner receiver) notNil ] ])		ifFalse: [ ^ self beep ].	menu := MenuMorph new.	menu target: [ :v | choice := v ].	(rcvr perform: getMenuSelector)		do: [ :each | menu add: each first selector: #value: argument: each second ].	menu invokeAt: ActiveHand position in: self world.	choice ifNil: [ ^ self ].	evt hand newKeyboardFocus: nil.	"close mini-editor, if any"	"(#(listIndexMenu listIndexForDeleteMenu) includes: getMenuSelector)		ifTrue: [ ^ self specialValue: choice ]."	isNumber		ifTrue: [ self numExpression: choice ]		ifFalse: [ self stringExpression: choice ].! !!ExpressionArgMorphWithMenu methodsFor: 'code generation' stamp: 'EiichiroIto 6/17/2018 16:31'!ownerSelector	^ owner selector! !!ExpressionArgMorphWithMenu methodsFor: 'code generation' stamp: 'EiichiroIto 6/17/2018 16:09'!specialValue	^ specialValue! !!ExpressionArgMorphWithMenu methodsFor: 'accessing' stamp: 'jm 8/4/2008 09:06'!specialValue: aString	"A special value is a menu selection such as 'last' for a list index that appears as a string in a number if field. If the user edits the field, then it only accepts numeric input. The argumet is retained in the specialValue instance variable."	isNumber := true.	labelMorph contents: aString localized.	labelMorph		isNumeric: true;		position: self position + (0@1).	self fixArgLayout.	specialValue := aString.! !!ExpressionArgMorphWithMenu methodsFor: 'object i/o' stamp: 'jm 5/6/2008 19:22'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		menuMorph		getMenuSelector		specialValue	) on: anObjStream.! !!SpriteArgMorph methodsFor: 'other' stamp: 'jm 3/27/2009 07:47'!acceptsDroppedReporters	^ true! !!SpriteArgMorph methodsFor: 'other' stamp: 'jm 3/27/2009 07:48'!acceptsTypeOf: aBlockMorph	"Answer true if I can accept a dropped reporter of the given type."	aBlockMorph isReporter ifFalse: [^ false].	^ aBlockMorph isBooleanReporter not! !!SpriteArgMorph methodsFor: 'code generation' stamp: 'EiichiroIto 9/12/2018 13:27'!argString: aGenerator	^ aGenerator spriteArgString: self.! !!SpriteArgMorph methodsFor: 'other' stamp: 'EiichiroIto 10/19/2019 17:52'!checkForDeletedMorph	"If I refer to a Sprite that has been deleted, nil out my morph field. Do nothing if my morph is a SteloStageMorph"	(morph isKindOf: Morph) ifFalse: [^ self].	morph owner ifNotNil: [^ self].	(morph isStageMorph) ifTrue: [^ self].	morph := nil.  "nil out reference to deleted sprite"! !!SpriteArgMorph methodsFor: 'other' stamp: 'jm 12/10/2004 14:11'!clearMorphReference	"Clear my morph reference."	(morph isKindOf: Morph) ifFalse: [^ self].	morph := nil.	self updateLabel.! !!SpriteArgMorph methodsFor: 'other' stamp: 'EiichiroIto 11/29/2019 20:39'!defaultValue: anObject	morph := anObject! !!SpriteArgMorph methodsFor: 'other' stamp: 'EiichiroIto 11/29/2019 20:37'!evaluate	"Answer either nil, the symbol #mouse, or a Scratch sprite object."	self checkForDeletedMorph.	morph isString		ifTrue: [ morph := owner script project findObjName: morph ].	^ morph! !!SpriteArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:34'!fieldsVersion	^ 1! !!SpriteArgMorph methodsFor: 'other' stamp: 'jm 3/28/2005 17:03'!fixArgLayout	"Set my color to my owner's color."	self color: (owner color mixed: 0.7 with: (Color gray: 0.3)).! !!SpriteArgMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/3/2019 21:27'!handlesMouseDown: evt	^ "evt hand toolType isNil and:		["		(self topRight - (14@0) corner: self bottomRight) containsPoint: evt cursorPoint		"]"! !!SpriteArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:35'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		morph	) from: anObjStream.! !!SpriteArgMorph methodsFor: 'initialize' stamp: 'EiichiroIto 11/19/2019 22:01'!initialize	super initialize.	self borderInset.	self borderWidth: 1.	self color: Color white.	labelMorph := StringMorph new		font: (ScratchTheme argFont);		color: Color white.	self addMorph: labelMorph.	((labelMorph extent y) > 15)		ifTrue: [ self extent: 20@((labelMorph extent y) + 3) ]		ifFalse: [ self extent: 20@15 ].	menuIconMorph := ImageMorph new form: DropDownMenuForm.	self addMorphFront: menuIconMorph.	morph := nil.	self updateLabel.! !!SpriteArgMorph methodsFor: 'event handling' stamp: 'jm 12/13/2006 21:28'!mouseDown: evt	self presentMenu.! !!SpriteArgMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/23/2019 21:14'!presentMenu	"Let the user select a Scratch object or the special value #mouse."	| project objList menu choice |	(project := self project) ifNil: [^ self].	"(owner isKindOf: CommandBlockMorph) ifTrue: [sel := owner selector]."	objList := project scripts.	objList sort: [:obj1 :obj2 | obj1 objName asLowercase < obj2 objName asLowercase].	menu := MenuMorph new.	menu target: [ :v | choice := v ].	"sel = #getAttribute:of:		ifTrue: [			menu add: ('Stage' localized) selector: #value: argument: frame workPane]		ifFalse: [			menu add: 'mouse-pointer' localized selector: #value: argument: #mouse.			sel = #touching: ifTrue: [menu add: 'edge' localized selector: #value: argument: #edge].			objList := objList copyWithout: owner receiver]."	objList size > 0 ifTrue: [menu addLine].	objList do: [:obj | menu add: obj objName selector: #value: argument: obj].	menu invokeAt: ActiveHand position in: self world.	choice ifNil: [^ self].	morph := choice.	"self fixGetAttribueBlock."	self updateLabel.! !!SpriteArgMorph methodsFor: 'other' stamp: 'jm 3/14/2009 13:53'!printArgOn: aStream	"Print this argument morph on the given stream."	aStream nextPutAll: 's['.	aStream nextPutAll: self labelMorph contents.	aStream nextPut: $].! !!SpriteArgMorph methodsFor: 'stepping' stamp: 'jm 9/5/2006 11:20'!step	self updateLabel.! !!SpriteArgMorph methodsFor: 'stepping' stamp: 'jm 12/9/2008 16:29'!stepTime	^ 500! !!SpriteArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:39'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		morph	) on: anObjStream.! !!SpriteArgMorph methodsFor: 'stepping' stamp: 'EiichiroIto 11/24/2019 15:33'!updateLabel	"Update my label string."	| s |	self checkForDeletedMorph.	s := ' '.	morph		ifNotNil: [ morph isScriptable				ifTrue: [ s := morph objName ].			morph isString				ifTrue: [ s := morph localized.					morph = #mouse						ifTrue: [ s := 'mouse-pointer' localized ] ] ].	labelMorph contents = s		ifFalse: [ labelMorph contents: ''.			labelMorph contents: s.			labelMorph position: self position + borderWidth + (3 @ -1).			self extent: labelMorph extent + (16 @ 2) + borderWidth.			menuIconMorph				position: (self right - borderWidth - 10) @ (self top + borderWidth + 4).			(self meOrOwnerThatIsA: ScratchBlockPaletteMorph)				ifNotNil: [ (self meOrOwnerThatIsA: ScratchBlockPaletteMorph) fixLayout ] ]! !!SpriteArgMorph methodsFor: 'event handling' stamp: 'jm 12/14/2004 11:55'!wantsKeyboardFocusFor: aSubmorph	"Don't allow shift-click editing of block labels."	^ false! !!BorderedMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 11:42'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		borderWidth		borderColor	) from: anObjStream.! !!BorderedMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 19:56'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		borderWidth		borderColor	) on: anObjStream.! !!MultilineStringMorph class methodsFor: 'instance creation' stamp: 'jm 9/16/2005 10:18'!includeInNewMorphMenu	^ true! !!MultilineStringMorph class methodsFor: 'class initialization' stamp: 'jm 7/5/2008 10:31'!initialize	"self initialize"	CR := 13.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 12/9/2006 20:52'!backspaceChar	"If there is a selection, delete it. Otherwise delete the character just before the insertion point (i.e. backspace)."	selectionStart = selectionEnd ifFalse: [^ self deleteSelection].	selectionStart > 1 ifTrue: [		selectionEnd := selectionStart.		selectionStart := selectionStart - 1.		self deleteSelection].! !!MultilineStringMorph methodsFor: 'private' stamp: 'EiichiroIto 9/26/2016 19:55'!breakLine: lineIndex	"Break the given line by moving some of it down to the following line. Answer true if the line was broken, false otherwise. (This may cause the next line to become too long, thus propaging the need to word-wrap.)	Try the following strategies, in order:		a. break at an embedded if that leaves the line short enough		b. break at the last space character before a word that hits the edge		c. break a word that hits the edge if there is no space before that word"	| line breakIndex i lineUpToBreak lineAfterBreak |	line := lines at: lineIndex.	breakIndex := nil.	(self fits: line) ifTrue: [^ false].  "line already fits"	(i := line indexOf: Character cr) ~= 0 ifTrue: [		(self fits: (line copyFrom: 1 to: i - 1))			ifTrue: [breakIndex := i]].	breakIndex ifNil: [		i := line indexOfSeparatorStartingAt: 1.		[i <= line size] whileTrue: [			(self fits: (line copyFrom: 1 to: i - 1))				ifTrue: [					breakIndex := i.					i := line indexOfSeparatorStartingAt: i + 1]				ifFalse: [i := line size + 1]]].	breakIndex ifNil: [		i := line size.		[i > 1 and:		 [(self fits: (line copyFrom: 1 to: i)) not]]			whileTrue: [i := i - 1].		breakIndex := i].	lineUpToBreak := line copyFrom: 1 to: breakIndex.	lineAfterBreak := line copyFrom: breakIndex + 1 to: line size.	lineIndex = lines size ifTrue: [lines := lines copyWith: self emptyLine].  "make sure there is a next line"	lines at: lineIndex put: lineUpToBreak.	lines at: lineIndex + 1 put: lineAfterBreak, (lines at: lineIndex + 1).	^ true! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 8/2/2008 14:24'!centerText: aBoolean	centerText := aBoolean.! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 12/8/2006 19:35'!charCount	| result |	result := 0.	lines do: [:s | result := result + s size].	^ result! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/26/2016 19:35'!contents	"Answer my contents as a string."	| sz result i |	sz := 0.	lines do: [:s | sz := sz + s size].	result := String new: sz.	i := 1.	lines do: [:s |		sz := s size.		result replaceFrom: i to: i + sz - 1 with: s startingAt: 1.		i := i + sz].	^ result! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/26/2016 12:27'!contents: aStringOrText	"Set my contents to the given String or Text. Break into lines, emove non-printing characters, and replace tabs with sequences of spaces."	lines := Array with: (self replaceTabs: aStringOrText).	self lineWrapFrom: 1.! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 6/12/2008 19:45'!contents: aString font: aStrikeFont	"Set my contents to the given String, UTF8, or Text and set my font. Remove non-printing characters, and replace tabs with sequences of spaces, and word-wrap."	lines := Array with: (self replaceTabs: aString).	self font: aStrikeFont.! !!MultilineStringMorph methodsFor: 'copying' stamp: 'jm 7/25/2006 10:22'!copy	"Return a copy with a copy of my lines array."	^ super copy setLines: lines copy! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 8/10/2008 20:18'!copySelection	"Record the current selection in the clipboard."	ScratchTranslator unicodeClipboardPut: self currentSelection.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'EiichiroIto 9/26/2016 19:55'!currentSelection	"Answer the current selection as a string."	| line result start end startLineNum endLineNum |	self ensureSelectionStartPrecedesEnd.	start := self lineAndIndexFor: selectionStart.	end := self lineAndIndexFor: selectionEnd.	startLineNum := start first.	endLineNum := end first.	startLineNum = endLineNum ifTrue: [		line := lines at: startLineNum.		^ line copyFrom: start second to: end second - 1].	result := WriteStream on: (String new: 1000).	line := lines at: startLineNum.	result nextPutAll: (line copyFrom: start second to: line size).	startLineNum + 1 to: endLineNum - 1 do: [:i |		result nextPutAll: (lines at: i)].	line := lines at: endLineNum.	result nextPutAll: (line copyFrom: 1 to: end second - 1).	^ result contents! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'jm 7/6/2008 17:46'!cursorKey: evt	"Handle the given cursor control key."	| ch pair lineNum line |	ch := evt keyValue.	selectionStart = selectionEnd ifTrue: [startLoc := selectionStart].	ch = 28 ifTrue: [ "left"		evt shiftPressed			ifTrue: [				selectionEnd > startLoc					ifTrue: [selectionEnd := selectionEnd - 1]					ifFalse: [selectionStart := selectionStart - 1]]			ifFalse: [				selectionStart := selectionEnd := selectionStart - 1]].	ch = 29 ifTrue: [ "right"		evt shiftPressed			ifTrue: [				selectionStart < startLoc					ifTrue: [selectionStart := selectionStart + 1]					ifFalse: [selectionEnd := selectionEnd + 1]]			ifFalse: [				selectionStart := selectionEnd := selectionStart + 1]].	ch = 30 ifTrue: [  "up"		pair := self lineAndIndexFor: selectionStart.			lineNum := (pair first - 1) max: 1.		line := lines at: lineNum.		selectionStart := (self startOfLine: lineNum) + (pair second min: line size).		evt shiftPressed ifFalse: [selectionEnd := selectionStart]].	ch = 31 ifTrue: [  "down"		pair := self lineAndIndexFor: selectionEnd.			lineNum := (pair first + 1) min: lines size.		line := lines at: lineNum.		selectionEnd := (self startOfLine: lineNum) + (pair second min: line size).		evt shiftPressed ifFalse: [selectionStart := selectionEnd]].	blinkState := true.	self ensureSelectionStartPrecedesEnd.	self changed.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 9/17/2005 13:41'!cutSelection	"Record the current selection in the clipboard, then delete it."	selectionStart = selectionEnd ifTrue: [^ self].  "no selection"	self copySelection.	self deleteSelection.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 12/9/2006 20:53'!deleteNextChar	"If there is a selection, delete it. Otherwise delete the character just after the insertion point (i.e. delete)."	selectionStart = selectionEnd ifFalse: [^ self deleteSelection].	selectionEnd := selectionStart + 1.	self deleteSelection.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 12/12/2006 19:39'!deleteSelection	"Delete the current selection."	| start end startLineNum endLineNum s1 s2 mergedLine remainingLines |	self ensureSelectionStartPrecedesEnd.	selectionStart = selectionEnd ifTrue: [^ self].  "no selection"	start := self lineAndIndexFor: selectionStart.	end := self lineAndIndexFor: selectionEnd.	startLineNum := start first.	endLineNum := end first.	"merge the partial lines before and after the selection"	s1 := lines at: startLineNum.	s2 := lines at: endLineNum.	mergedLine := (s1 copyFrom: 1 to: start second - 1), (s2 copyFrom: end second to: s2 size).	"combine with following line, if any"	endLineNum < lines size ifTrue: [		mergedLine := mergedLine, (lines at: endLineNum + 1).		remainingLines := lines copyFrom: endLineNum + 2 to: lines size].	"update lines"	lines := (lines copyFrom: 1 to: startLineNum - 1) copyWith: mergedLine.	remainingLines ifNotNil: [lines := lines, remainingLines].	selectionEnd := selectionStart.	self lineWrapFrom: startLineNum.! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'jm 12/18/2006 12:59'!doubleClick: evt	"Select a word."	| lineAndIndex lineNum s index wordStart wordEnd lineStart |	lines size = 0 ifTrue: [^ self].	lineAndIndex := self lineAndIndexFor: (self indexForPoint: evt cursorPoint).	lineNum := lineAndIndex first.	s := lines at: lineNum.	s size = 0 ifTrue: [^ self].  "empty line"	index := lineAndIndex second.	index > s size ifTrue: [index := s size].  "at end of line; try one char back"	(s at: index) isSeparator ifTrue: [^ self].  "on separator; do nothing"	wordStart := index.	[(wordStart >= 1) and: [(s at: wordStart) isSeparator not]]		whileTrue: [wordStart := wordStart - 1].	wordEnd := index.	[(wordEnd < s size) and: [(s at: wordEnd) isSeparator not]]		whileTrue: [wordEnd := wordEnd + 1].	(s at: wordEnd) isSeparator ifTrue: [wordEnd := wordEnd - 1].	lineStart := self startOfLine: lineNum.	selectionStart := lineStart + (wordStart + 1).	selectionEnd := lineStart + (wordEnd + 1).	startLoc := selectionStart.	self changed.! !!MultilineStringMorph methodsFor: 'drawing' stamp: 'EiichiroIto 11/22/2019 15:16'!drawCursor: charIndex line: lineIndex on: aCanvas	"Draw a cursor at the given character index on the given line."	| line pair x p |	line := lines at: lineIndex.	line size = 0		ifTrue: [ pair := #(0 0) ]		ifFalse: [ pair := (renderer xRangesFor: line)				at: (charIndex min: line size max: 1) ].	x := charIndex > line size		ifTrue: [ pair max ]		ifFalse: [ pair min ].	p := self offsetForLine: lineIndex.	aCanvas		fillRectangle: (p + (x @ 0) extent: 2 @ lineHeight)		color: selectionColor! !!MultilineStringMorph methodsFor: 'drawing' stamp: 'jm 7/19/2008 10:18'!drawOn: aCanvas	| clipC |	super drawOn: aCanvas.	lineHeight ifNil: [self font: font].	clipC := aCanvas		copyOffset: bounds origin		clipRect: (bounds insetBy: borderWidth).	(hasFocus | owner isNil) ifTrue: [self drawSelectionOn: clipC].	self drawTextOn: clipC.! !!MultilineStringMorph methodsFor: 'drawing' stamp: 'EiichiroIto 9/25/2016 20:36'!drawSelectionFrom: startIndex to: endIndex line: lineIndex on: aCanvas	"Draw the selection for the given character range of the given line on the given canvas."	| line xRanges p pair w |	line := lines at: lineIndex.	xRanges := renderer xRangesFor: line.	p := self offsetForLine: lineIndex.	startIndex to: endIndex - 1 do: [:i |		pair := xRanges at: (i min: line size max: 1).		w := (pair last - pair first) abs.		aCanvas fillRectangle: ((p + (pair first@0)) extent: w@lineHeight) color: selectionColor].! !!MultilineStringMorph methodsFor: 'drawing' stamp: 'jm 7/11/2008 18:11'!drawSelectionLine: lineIndex on: aCanvas	"Draw the selection for the entire line with the given index on the given canvas."	| p w |	p := self offsetForLine: lineIndex.	w := renderer stringWidth: (lines at: lineIndex).	aCanvas fillRectangle: (p extent: w@lineHeight) color: selectionColor.! !!MultilineStringMorph methodsFor: 'drawing' stamp: 'jm 8/8/2008 21:22'!drawSelectionOn: aCanvas	"Draw my selection onto the given canvas. The canvas has been offset to my origin."	| start end startLine endLine startIndex endIndex |	lines size = 0 ifTrue: [^ self].	self ensureSelectionStartPrecedesEnd.	start := self lineAndIndexFor: selectionStart.	end := self lineAndIndexFor: selectionEnd.	startLine := start first.	endLine := end first.	startIndex := start last.	endIndex := end last.	startLine = endLine ifTrue: [		startIndex = endIndex			ifTrue: [				blinkState ifTrue: [					self drawCursor: startIndex line: startLine on: aCanvas]]			ifFalse: [				self drawSelectionFrom: startIndex to: endIndex line: startLine on: aCanvas].		^ self].	self drawSelectionFrom: startIndex to: (lines at: startLine) size + 1 line: startLine on: aCanvas.	startLine + 1 to: endLine - 1 do: [:i | self drawSelectionLine: i on: aCanvas].	self drawSelectionFrom: 1 to: endIndex line: endLine on: aCanvas.! !!MultilineStringMorph methodsFor: 'drawing' stamp: 'EiichiroIto 9/27/2016 16:13'!drawString: aString at: aPoint on: aCanvas	| s |	s := aString.	suppressAntiAliasing ifNil: [ suppressAntiAliasing := false ].	renderWithSqueak ifNil: [ renderWithSqueak := false ].	aCanvas		drawString: s		in: (aPoint extent: 10000 @ 10000)		font: font		color: textColor! !!MultilineStringMorph methodsFor: 'drawing' stamp: 'EiichiroIto 11/22/2019 15:16'!drawTextOn: aCanvas	| hInset x y |	hInset := self insetX.	y := self insetY.	centerText ifNil: [ centerText := false ].	lines		do: [ :s | 			x := hInset.			centerText				ifTrue: [ x := (self width - hInset - (renderer stringWidth: s)) // 2 ].			self drawString: s at: x @ y on: aCanvas.			y := y + lineHeight ]! !!MultilineStringMorph methodsFor: 'private' stamp: 'EiichiroIto 9/26/2016 19:54'!emptyLine	^ ''! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 8/25/2008 19:27'!ensureOSFont	font isOSFont ifFalse: [		self font: (StrikeFont osFontName: 'Helvetica Bold' size: font pointSize)].! !!MultilineStringMorph methodsFor: 'private' stamp: 'EiichiroIto 9/25/2016 20:36'!ensureSelectionStartPrecedesEnd	"If selectionEnd is before selectionStart, swap them."	| lastIndex tmp |	lastIndex := self charCount + 1.	selectionStart := selectionStart min: lastIndex max: 1.	selectionEnd := selectionEnd min: lastIndex max: 1.	selectionEnd < selectionStart ifTrue: [		tmp := selectionEnd.		selectionEnd := selectionStart.		selectionStart := tmp].! !!MultilineStringMorph methodsFor: 'geometry' stamp: 'jm 7/30/2008 16:33'!extent: aPoint	| oldWidth |	oldWidth := self width.	super extent: (aPoint max: ((2 * borderWidth) + inset + 10)).	self width ~= oldWidth ifTrue: [self wordWrapAll].! !!MultilineStringMorph methodsFor: 'object i/o' stamp: 'jm 9/16/2005 10:18'!fieldsVersion	^ 1! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 8/11/2008 18:01'!fitContents	"Set my extent to just fit around my contents."	| w |	w := 10.	lines do: [:s | w := w max: (self widthWithContents: s)].	super extent: (w@(lines size * lineHeight)) + (9@7).! !!MultilineStringMorph methodsFor: 'private' stamp: 'EiichiroIto 9/26/2016 19:55'!fits: aString	"Answer true if the given string fits within my width."	| i |	i := aString indexOf: Character cr.	((i > 0) and: [i < aString size]) ifTrue: [^ false].  "line includes an embedded CR; needs to be broken"	aString size > 500 ifTrue: [^ false].	^ (renderer stringWidth: aString) < (self width - (self insetX + borderWidth + 2))! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 9/16/2005 10:18'!font	^ font! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 7/10/2008 12:09'!font: aFont	font := aFont.	renderer := StringMorph new font: aFont.	lineHeight := renderer stringHeight: ScratchTranslator renderHintString, 'Ag'.	self wordWrapAll.! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 9/28/2007 15:46'!growWithText: aBoolean	growWithText := aBoolean.! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/26/2016 19:59'!handlesKeyboard: evt	^ true! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'jm 8/9/2008 18:07'!handlesMouseDown: evt	^ self isEditable! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 9/16/2005 11:27'!hasFocus	^ hasFocus! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 7/11/2008 19:19'!indexForPoint: aPoint	"Answer the character index for the given point in screen coordinates."	"Note: This could be speeded up by doing a binary search for the character index, but it seems fast enough."	| y lineNum x lineStart line xRanges pair |	lines size = 0 ifTrue: [^ 1].	y := aPoint y - (self top + self insetY).	lineNum := ((y // lineHeight) + 1) max: 1.	lineNum > lines size ifTrue: [^ (self startOfLine: lineNum) + 1].	x := (aPoint x - self left - (self offsetForLine: lineNum) x) min: self width.	x < 0 ifTrue: [  "start of a line"		lineNum = 1 ifTrue: [^ 1] ifFalse: [^ self startOfLine: lineNum]].	"search for character index"	lineStart := self startOfLine: lineNum.	line := lines at: lineNum.	xRanges := renderer xRangesFor: line.	1 to: line size do: [:i |		pair := xRanges at: i.		(x between: pair first and: pair second) ifTrue: [^ lineStart + i]].	"end of line"	lineNum = lines size		ifTrue: [^ lineStart + line size + 1]		ifFalse: [^ lineStart + line size].! !!MultilineStringMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 9/14/2018 07:40'!initFieldsFrom: anObjStream version: classVersion	| fontSpec |	super initFieldsFrom: anObjStream version: classVersion.	fontSpec := anObjStream nextField.	self font: (StrikeFont fontName: fontSpec first size: fontSpec second).	self initFieldsNamed: #(		textColor		selectionColor		lines	) from: anObjStream! !!MultilineStringMorph methodsFor: 'initialization' stamp: 'jm 8/11/2008 07:36'!initialize	super initialize.	color := Color transparent.	textColor := Color black.	selectionColor := Color r: 0.353 g: 0.607 b: 0.788.	lines := Array with: self emptyLine.	isEditable := true.	centerText := false.	hasFocus := false.	selectionStart := selectionEnd := 1.	blinkState := true.	growWithText := false.	inset := 5@3.	suppressAntiAliasing := false.	renderWithSqueak := false.	self font: TextStyle defaultFont.	super extent: 90@25.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 7/6/2008 17:46'!insertString: aString	"Insert the given string at selectionStart."	| start lineNum line prefix postfix |	selectionStart = selectionEnd ifFalse: [self cutSelection].	start := self lineAndIndexFor: selectionStart.	lineNum := start first.	line := lines at: lineNum.	prefix := line copyFrom: 1 to: start second - 1.	postfix := line copyFrom: start second to: line size.	lines at: lineNum put: (prefix, (self replaceTabs: aString), postfix).	selectionEnd := selectionStart := selectionStart + aString size.	self lineWrapFrom: lineNum.! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 7/6/2008 16:10'!insetX	^ borderWidth + inset x! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 7/6/2008 16:10'!insetY	^ borderWidth + inset y! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 7/10/2008 14:19'!isEditable	isEditable ifNil: [isEditable := true].	^ isEditable! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 7/10/2008 14:19'!isEditable: aBoolean	isEditable := aBoolean.! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 9/26/2005 19:41'!isEmpty	"Answer true if my contents is empty."	^ lines size = 0 or: [lines size = 1 and: [lines first size = 0]]! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/16/2019 17:39'!keyStroke: evt	| ch m |	ch := evt keyCharacter charCode.	ch = 0 ifTrue: [ch := evt keyValue].	evt commandKeyPressed ifTrue: [ch := ch \\ 32].	"map cmd/alt keys to control keys"	(ch = 3) & (evt buttons = 0) ifTrue: [ch := 13].	"map enter key to cr"	ch = 9 ifTrue: [  "tab"		"(m := self meOrOwnerThatIsA: DialogBoxMorph) ifNotNil: [m tabToNextField: evt]."		^ self].	ch = 27 ifTrue: [  "escape key"		"(m := self meOrOwnerThatIsA: DialogBoxMorph) ifNotNil: [m escapeKeyPressed: evt]."		^ self].	evt controlKeyPressed | evt commandKeyPressed ifTrue: [	"ctrl (or alt) is pressed"		ch = 1 ifTrue: [^ self selectAll].			"ctrl-a"		ch = 3 ifTrue: [^ self copySelection].		"ctrl-c"		ch = 22 ifTrue: [^ self paste].			"ctrl-v"		ch = 24 ifTrue: [^ self cutSelection]].		"ctrl-x"	evt shiftPressed ifTrue: [ "shift is pressed"		ch = 1 ifTrue: [^ self moveCursorHomeAndSelect: true].		"home"		ch = 4 ifTrue: [^ self moveCursorEndAndSelect: true].			"end"		ch = 11 ifTrue: [^ self moveCursorPageUpAndSelect: true].		"page up"		ch = 12 ifTrue: [^ self moveCursorPageDownAndSelect: true]].	"page down"	evt buttons = 0 ifTrue: [ "no modifier keys"		ch = 8 ifTrue: [^ self backspaceChar].						"backspace"		ch = 127 ifTrue: [^ self deleteNextChar].						"delete"		ch = 1 ifTrue: [^ self moveCursorHomeAndSelect: false].		"home"		ch = 4 ifTrue: [^ self moveCursorEndAndSelect: false].		"end"		ch = 11 ifTrue: [^ self moveCursorPageUpAndSelect: false].	"page up"		ch = 12 ifTrue: [^ self moveCursorPageDownAndSelect: false]]."page down"	(ch between: 28 and: 31) ifTrue: [^ self cursorKey: evt].  "arrow keys"	"not a special character--just insert it"	self insertString: evt keyCharacter asString! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'jm 5/15/2008 14:05'!keyboardFocusChange: aBoolean	hasFocus = aBoolean ifTrue: [^ self].	self changed.	aBoolean		ifTrue: [			self selectAll.			self startStepping]		ifFalse: [			self stopStepping].	hasFocus := aBoolean.! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 12/8/2006 11:33'!lineAndIndexFor: charPos	"Answer an Array containing the line number and the character index within that line for the given character position in my text."	| count line |	charPos < 1 ifTrue: [^ Array with: 1 with: 1].	count := 0.	1 to: lines size do: [:lineNum |		line := lines at: lineNum.		(charPos between: count + 1 and: count + line size)			ifTrue: [^ Array with: lineNum with: charPos - count].		count := count + line size].		^ Array with: lines size with: ((lines at: lines size) size + 1)! !!MultilineStringMorph methodsFor: 'private' stamp: 'EiichiroIto 9/26/2016 19:56'!lineWrapFrom: startLine	"Fix line wrapping starting at the given line."	| lineIndex newH |	lineIndex := startLine.	[lineIndex <= lines size and: [self breakLine: lineIndex]]		whileTrue: [lineIndex := lineIndex + 1].	"if the last line ends with a CR, add a blank line after it"	(lines last size > 0 and: [lines last last = Character cr])		ifTrue: [lines := lines copyWith: self emptyLine].	growWithText ifTrue: [		newH := ((lines size max: 1) * lineHeight) + (2 * self insetY).		bounds height ~= newH ifTrue: [self height: newH]].	self changed.! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 12/8/2006 11:16'!lines	^ lines! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'jm 7/10/2008 14:20'!mouseDown: evt	self isEditable ifFalse: [^ self].	evt hand newKeyboardFocus: self.	startLoc := self indexForPoint: evt cursorPoint.	selectionStart := selectionEnd := startLoc.	evt hand waitForClicksOrDrag: self event: evt.	self changed.! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'jm 8/9/2008 18:17'!mouseMove: evt	| newLoc |	self isEditable ifFalse: [^ self].	newLoc := self indexForPoint: evt cursorPoint.	startLoc ifNil: [startLoc := newLoc].	newLoc < startLoc		ifTrue: [selectionStart := newLoc. selectionEnd := startLoc]		ifFalse: [selectionStart := startLoc. selectionEnd := newLoc].	self changed.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 12/12/2006 19:22'!moveCursorContentsEnd	"Position the cursor at the end of my contents (i.e. at very end, not the end of the current line)."	selectionStart := selectionEnd := self charCount + 1.	self changed.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 7/6/2008 17:46'!moveCursorEndAndSelect: selectFlag	| lineNum line |	lineNum := (self lineAndIndexFor: selectionStart) first.	line := lines at: lineNum.	selectionEnd := (self startOfLine: lineNum) + line size.	lineNum = lines size ifTrue: [selectionEnd := selectionEnd + 1].	selectFlag ifFalse: [selectionStart := selectionEnd].	startLoc := selectionStart.	self changed.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 12/18/2006 12:57'!moveCursorHomeAndSelect: selectFlag	selectionStart := (self startOfLine: (self lineAndIndexFor: selectionStart) first) + 1.	selectFlag ifFalse: [selectionEnd := selectionStart].	startLoc := selectionEnd.	self changed.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 7/6/2008 17:46'!moveCursorPageDownAndSelect: selectFlag	| i lastLine |	i := (self lineAndIndexFor: selectionStart) second.	lastLine := lines at: lines size.	selectionEnd := (self startOfLine: lines size) + (i min: lastLine size + 1).	selectFlag ifFalse: [selectionStart := selectionEnd].	startLoc := selectionStart.	self changed.! !!MultilineStringMorph methodsFor: 'editing' stamp: 'EiichiroIto 9/25/2016 20:37'!moveCursorPageUpAndSelect: selectFlag	| i |	i := (self lineAndIndexFor: selectionStart) second.	selectionStart := i min: (lines at: 1) size max: 1.	selectFlag ifFalse: [selectionEnd := selectionStart].	startLoc := selectionEnd.	self changed.! !!MultilineStringMorph methodsFor: 'private' stamp: 'EiichiroIto 11/22/2019 15:17'!offsetForLine: lineIndex	"Answer the offset from my origin to the start of the line with the given index, taking RTL into account."	| top |	top := self insetY + (lineHeight * (lineIndex - 1)).	^ self insetX @ top! !!MultilineStringMorph methodsFor: 'editing' stamp: 'EiichiroIto 11/22/2019 16:24'!paste	"Paste the last cut or copied text over the current selection."	| s |	s := ScratchTranslator unicodeClipboard.	s isEmpty		ifTrue: [ ^ self ].	self deleteSelection.	self insertString: s! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 8/11/2008 07:44'!renderWithSqueak: aBoolean	"If true, then if my font is a StrikeFont render my contents using that font and the Squeak rendering system. Note that it will only be able to render MacRoman text. This flag allows the text layer from old costumes to be edited in it's original Squeak font."	renderWithSqueak := aBoolean.! !!MultilineStringMorph methodsFor: 'private' stamp: 'EiichiroIto 9/26/2016 12:26'!replaceTabs: aString	"Answer a copy of the given UTF32 with each tab replaced by four spaces and all non-printing characters except spaces and line ends removed. Covert LF's to CR's."	| s tab lf cr space result |	s := aString.	tab := Character tab.	lf := Character lf.	cr := Character cr.	space := Character space.	result := WriteStream on: (String new: s size * 4).	s do: [:ch |		ch < space			ifTrue: [ "non-printing"				ch = tab ifTrue: [result nextPutAll: '    '].				(ch = cr) | (ch = lf) ifTrue: [result nextPut: cr]]			ifFalse: [				result nextPut: ch]].	^ result contents! !!MultilineStringMorph methodsFor: 'editing' stamp: 'jm 12/9/2006 20:18'!selectAll	"Select all of my text."	selectionStart := 1.	selectionEnd := self charCount + 1.	self changed.! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 9/23/2005 10:38'!selectionColor: aColor	selectionColor := aColor.! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 7/25/2006 10:07'!setLines: anArray	"Private!! Used when copying."	lines := anArray.! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'jm 1/5/2006 10:23'!startDrag: evt	"Do nothing."! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 12/15/2006 13:43'!startOfLine: lineIndex	"Answer the character index for the start of the line with the given index. If the line is out of range treat it as if it were the first or last line."	| result |	lineIndex < 1 ifTrue: [^ 1].	result := 0.	1 to: ((lineIndex - 1) min: lines size) do: [:i | result := result + (lines at: i) size].	^ result! !!MultilineStringMorph methodsFor: 'stepping' stamp: 'jm 7/6/2008 17:47'!step	blinkState := blinkState not.	selectionStart = selectionEnd ifTrue: [self changed].! !!MultilineStringMorph methodsFor: 'stepping' stamp: 'jm 12/20/2006 16:14'!stepTime	^ 600! !!MultilineStringMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 9/14/2018 07:39'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	anObjStream putField: {font familyName. font pointSize}.  "font spec"	self storeFieldsNamed: #(		textColor		selectionColor		lines	) on: anObjStream.! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 7/9/2008 08:08'!stringWidth: aString	"Answer the width of the givne string."	^ renderer stringWidth: aString! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 7/9/2008 19:30'!suppressAntiAliasing: aBoolean	suppressAntiAliasing := aBoolean.! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 12/9/2005 16:51'!textColor	^ textColor! !!MultilineStringMorph methodsFor: 'accessing' stamp: 'jm 9/23/2005 10:37'!textColor: aColor	textColor := aColor.! !!MultilineStringMorph methodsFor: 'stepping' stamp: 'jm 5/15/2008 14:02'!wantsSteps	^ hasFocus! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 7/9/2008 08:20'!widthWithContents: aString	"Answer how wide I would need to be to fit the given string on a single line."	^ (renderer stringWidth: aString) + self insetX + borderWidth + 3! !!MultilineStringMorph methodsFor: 'private' stamp: 'jm 5/14/2008 13:53'!wordWrapAll	"Redo my wordwrap."	((lines size > 1) or: [lines first size > 0]) ifTrue: [		self contents: self contents].! !!MultilineStringMorph methodsFor: 'event handling' stamp: 'jm 7/10/2008 14:20'!wouldAcceptKeyboardFocus	^ self isEditable! !!ScratchBlockPaletteMorph methodsFor: 'other' stamp: 'EiichiroIto 11/22/2019 15:19'!fixLayout	"Right align the blocks in the palette if RTL is set to true. The watcher toggle checkbox buttons are assumed to be about 18 pixels wide."	| offset r |	owner ifNil: [ ^ self ].	offset := self topLeft negated.	r := 0 @ 0 extent: 1 @ 1.	self		submorphsDo:			[ :m | r := r quickMerge: (m fullBounds translateBy: offset) truncated ].	self width: (r width max: owner width)! !!ScratchBlockPaletteMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/21/2019 08:32'!initialize	super initialize.	borderWidth := 0.	isForScript := false! !!ScratchBlockPaletteMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 07:23'!isBlockPalette	^ true! !!ScratchBlockPaletteMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 08:31'!isForScript	^ isForScript! !!ScratchBlockPaletteMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 08:31'!isForScript: aBoolean	isForScript := aBoolean! !!ScratchBlockPaletteMorph methodsFor: 'dropping/grabbing' stamp: 'jm 7/1/2004 23:15'!isPartsBin	^ true! !!ScratchBlockPaletteMorph methodsFor: 'acessing' stamp: 'EiichiroIto 11/21/2019 08:31'!project	^ project! !!ScratchBlockPaletteMorph methodsFor: 'acessing' stamp: 'EiichiroIto 11/21/2019 08:31'!project: aProject	project := aProject! !!ScratchBlockPaletteMorph methodsFor: 'dropping/grabbing' stamp: 'jm 7/1/2004 23:21'!rootForGrabOf: aMorph	"I act like a parts bin; answer a new copy of the morph being extracted."	| root |	root := aMorph.	(root isKindOf: BlockMorph) ifFalse: [^ nil].	[root = self] whileFalse: [		root owner == self ifTrue: [^ root fullCopy].		root := root owner].	^ super rootForGrabOf: aMorph! !!ScratchBlockPaletteMorph methodsFor: 'dropping/grabbing' stamp: 'EiichiroIto 11/23/2019 15:38'!wantsDroppedMorph: aMorph event: evt	^ aMorph isBlockMorph! !!ScrollFrameMorph methodsFor: 'accessing' stamp: 'jm 8/2/2003 14:34'!contents	"Answer my contents morph."	^ contents! !!ScrollFrameMorph methodsFor: 'accessing' stamp: 'jm 8/3/2003 10:48'!contents: aMorph	"Replace my contents morph. The argument can be any morph. Typically it is a BorderedMorph or a PasteUpMorph."	contents ifNotNil: [contents delete].	contents := aMorph.	contents position: self topLeft + borderWidth.	self addMorphBack: contents.	self extent: self extent.! !!ScrollFrameMorph methodsFor: 'private' stamp: 'jm 8/2/2003 20:02'!contentsBounds	"Answer a rectangle that encloses the bounds of all my submorphs."	| offset r |	offset := contents topLeft negated.	r := 0@0 extent: 1@1.	contents submorphsDo: [:m |		r := r quickMerge: (m fullBounds translateBy: offset) truncated].	^ r! !!ScrollFrameMorph methodsFor: 'drawing' stamp: 'jm 2/1/2005 12:01'!drawSubmorphsOn: aCanvas	"If my contents has changed, fix it's extent and update my scrollbar ranges. Clip submorph drawing to my bounds."	contentsChanged ifTrue: [		self updateContentsExtent.		self updateScrollbars.		contentsChanged := false].	super drawSubmorphsOn: (aCanvas copyClipRect: self innerBounds).! !!ScrollFrameMorph methodsFor: 'geometry' stamp: 'jm 2/23/2005 17:48'!extent: aPoint	"After setting my size, position and size my scrollbars and grow box. Also update my contents and scrollbar ranges."	| inner w h |	super extent: (aPoint truncated max: self minWidth@self minHeight).	inner := self innerBounds.	w := inner width.	vScrollbar owner = self ifTrue: [w := w - vbarInset].	hScrollbar position: inner left@(inner bottom - hbarInset).	hScrollbar extent: w@hbarInset.	h := inner height.	hScrollbar owner = self ifTrue: [h := h - hbarInset].	vScrollbar position: (inner right - vbarInset)@inner top.	vScrollbar extent: vbarInset@h.	cornerMorph position: (inner bottomRight - (vbarInset@hbarInset)).	cornerMorph extent: vbarInset@hbarInset.	self updateContentsExtent.	self updateScrollbars.! !!ScrollFrameMorph methodsFor: 'geometry' stamp: 'jm 7/24/2003 18:15'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	^ bounds! !!ScrollFrameMorph methodsFor: 'accessing' stamp: 'jm 3/3/2008 22:32'!growthFraction: aNumber	"Set the amount to grow when contents do not fit, expressed as a fraction of the current size. For example, 0.5 makes the contains pane 50% larger if any submorph extends over the edge."	growthFraction := aNumber max: 0.0.! !!ScrollFrameMorph methodsFor: 'accessing' stamp: 'ee 5/1/2008 10:20'!hBarInset: anInteger	hbarInset := anInteger.! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 8/2/2003 14:26'!hResizing	^ #spaceFill! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 9/9/2003 10:52'!hScrollPixels	"Answer the current horizontal scroll offset in pixels."	^ (self left + borderWidth) - contents left! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 9/10/2003 11:58'!hScrollPixels: hOffset	"Scroll to the given horizontal offset in pixels. Zero is scrolled to the left and increasing values scroll right."	| delta maxOffset |	delta := (hOffset asInteger min: self maxScroll x) max: 0.	contents left: ((self left + borderWidth) - delta) truncated.	maxOffset := self maxScroll x.	maxOffset > 0 ifTrue: [hScrollbar value: self hScrollPixels / maxOffset].! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 8/2/2003 20:25'!hScrollRelative: aFloat	"Sent by the horizontal scrollbar. Scroll to the given relative postion between 0.0 and 1.0."	self hScrollPixels: aFloat * self maxScroll x.! !!ScrollFrameMorph methodsFor: 'initialization' stamp: 'EiichiroIto 9/15/2016 10:24'!initialize	super initialize.	self color: Color red.	hbarInset := 12.	vbarInset := 12.	contentsChanged := false.	growthFraction := 0.6.  "amount to grow when contents do not fit as a fraction of the current size"	contents := PasteUpMorph new		color: Color red;		borderWidth: 0;		enableDragNDrop: true.	hScrollbar := ScrollBar new		model: self;		setValueSelector: #hScrollRelative:";		hasMenuButton: false".	vScrollbar := ScrollBar new		model: self;		setValueSelector: #vScrollRelative:";		hasMenuButton: false".	cornerMorph := BorderedMorph new		borderRaised; borderWidth: 2; color: hScrollbar color.	contents position: self position + borderWidth.	self addMorph: contents.	self addMorph: hScrollbar.	self addMorph: vScrollbar.	self addMorph: cornerMorph.	self extent: 160@120.! !!ScrollFrameMorph methodsFor: 'geometry' stamp: 'jm 8/3/2003 09:11'!invalidRect: damageRect	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	| r |	r := damageRect intersect: self bounds.	(r width > 0 and: [r height > 0]) ifTrue: [super invalidRect: r].! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 8/2/2003 14:24'!isAlignmentMorph	"Answer true, since I can be laid out as if I were an AlignmentMorph. I pretend to be an AlignmentMorph so that I can be resized when I'm inside another AlignmentMorph."	^ true! !!ScrollFrameMorph methodsFor: 'geometry' stamp: 'jm 8/2/2003 14:31'!layoutChanged	"If my contents morph's layout has changed, record that fact."	super layoutChanged.	contents mayNeedLayout ifTrue: [contentsChanged := true].! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 8/2/2003 14:22'!layoutInWidth: w height: h	"Resize myself to the given width and height. Called during when I am in an AlignmentMorph."	self extent: w@h.! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 8/2/2003 20:25'!maxScroll	"Answer a point representing the maximum horizontal and vertical scroll offsets in pixels."	^ contents extent - self visibleExtent! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 7/21/2003 21:06'!minHeight	^ 45! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 7/21/2003 21:06'!minWidth	^ 60! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 6/23/2005 16:47'!scrollSubmorphIntoView: aMorph	| offset |	(contents submorphs includes: aMorph) ifFalse: [^ self].	(self bounds containsRect: aMorph fullBounds) ifTrue: [^ self].	(aMorph fullBounds bottom > self bottom) ifTrue: [		offset := aMorph fullBounds bottom - contents top.		contents top: (self bottom - 3) - offset].	(aMorph fullBounds top < self top) ifTrue: [		offset := aMorph fullBounds top - contents top.		contents top: (self top + 3) - offset].	self updateScrollbars.! !!ScrollFrameMorph methodsFor: 'scrollbar visibility' stamp: 'jm 8/2/2003 14:52'!showHorizontalScrollbar: aBoolean	"Show or hide my horizontal scrollbar."	aBoolean		ifTrue: [			self addMorph: hScrollbar.			vScrollbar owner = self ifTrue: [self addMorph: cornerMorph]]		ifFalse: [			hScrollbar delete.			cornerMorph delete].	self extent: self extent.! !!ScrollFrameMorph methodsFor: 'scrollbar visibility' stamp: 'jm 8/2/2003 14:52'!showVerticalScrollbar: aBoolean	"Show or hide my vertical scrollbar."	aBoolean		ifTrue: [			self addMorph: vScrollbar.			hScrollbar owner = self ifTrue: [self addMorph: cornerMorph]]		ifFalse: [			vScrollbar delete.			cornerMorph delete].	self extent: self extent.! !!ScrollFrameMorph methodsFor: 'private' stamp: 'ee 3/8/2008 16:28'!updateContentsExtent	"Make sure my content morph is large enough to both enclose all it's submorphs and to fill me. Adjust the scroll offsets if my bounds have shrunk."	| r delta scrolledOff w h visible |	r := self contentsBounds.	((r left < 0) or: [r top < 0]) ifTrue: [		"contents has morphs that stick out over its top or left edge"		delta := (r topLeft truncated min: (0@0)) negated.		contents submorphsDo: [:m | m position: m position + delta]].  "move all submorphs by delta"	visible := self visibleExtent - (8@20).	w := visible x. r width > w ifTrue: [w := (r width + (growthFraction * visible x)) rounded].	h := visible y. r height > h ifTrue: [h := (r height + (growthFraction * visible y))  rounded].	scrolledOff := ((self topLeft + borderWidth) - contents position) max: 0@0.	contents extent: ((w@h) max: (self visibleExtent + scrolledOff)).	contentsChanged := false.! !!ScrollFrameMorph methodsFor: 'private' stamp: 'EiichiroIto 9/15/2016 10:29'!updateScrollbars	"Update my scrollbars based on my current contents."	| visibleExtent currentScroll maxScroll |	contents ifNil: [^ self].  "not fully initialized yet"	visibleExtent := self visibleExtent.	"hScrollbar percentVisible: (visibleExtent x asFloat / contents width).	vScrollbar percentVisible: (visibleExtent y asFloat / contents height)."	currentScroll := (self topLeft + borderWidth) - contents position.	contents width > visibleExtent x		ifTrue: [			maxScroll := contents width - visibleExtent x.			self showHorizontalScrollbar: true.			hScrollbar				scrollDelta: 4 / maxScroll asFloat 				pageDelta: (visibleExtent x - 40) / maxScroll asFloat.			hScrollbar value: currentScroll x / maxScroll]		ifFalse: [			self showHorizontalScrollbar: false.			hScrollbar value: 0].	contents height > visibleExtent y		ifTrue: [			maxScroll := contents height - visibleExtent y.			self showVerticalScrollbar: true.			vScrollbar				scrollDelta: 4.0 / maxScroll asFloat 				pageDelta: (visibleExtent y - 40) / maxScroll asFloat.			vScrollbar value: currentScroll y / maxScroll]		ifFalse: [			self showVerticalScrollbar: false.			vScrollbar value: 0].! !!ScrollFrameMorph methodsFor: 'accessing' stamp: 'ee 5/1/2008 10:19'!vBarInset: anInteger	vbarInset := anInteger.! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 8/2/2003 14:26'!vResizing	^ #spaceFill! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 9/9/2003 10:52'!vScrollPixels	"Answer the current vertical scroll offset in pixels."	^ (self top + borderWidth) - contents top! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 9/10/2003 11:58'!vScrollPixels: vOffset	"Scroll to the given vertical offset in pixels. Zero is scrolled to the top and increasing values scroll down."	| delta maxOffset |	delta := (vOffset asInteger min: self maxScroll y) max: 0.	contents top: ((self top + borderWidth) - delta) truncated.	maxOffset := self maxScroll y.	maxOffset > 0 ifTrue: [vScrollbar value: self vScrollPixels / maxOffset].! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 8/2/2003 15:25'!vScrollRelative: aFloat	"Sent by the vertical scrollbar. Scroll to the given relative postion between 0.0 and 1.0."	self vScrollPixels: aFloat * self maxScroll y.! !!ScrollFrameMorph methodsFor: 'private' stamp: 'jm 4/6/2005 11:48'!visibleExtent	"Answer the extent of my visible area. That is, the area within my borders minus the space used for scrollbars."	| clipToScrollBarEdge visibleW visibleH |	clipToScrollBarEdge := false.	clipToScrollBarEdge ifFalse: [^ self extent - (2 * borderWidth)].	visibleW := self width - (2 * borderWidth).	vScrollbar owner = self ifTrue: [visibleW := visibleW - vbarInset].	visibleH := self height - (2 * borderWidth).	hScrollbar owner = self ifTrue: [visibleH := visibleH - hbarInset].	^ visibleW@visibleH! !!ScrollFrameMorph2 methodsFor: 'drawing' stamp: 'EiichiroIto 9/29/2016 11:01'!drawSubmorphsOn: aCanvas	"If my contents has changed, fix it's extent and update my scrollbar ranges. Clip submorph drawing to my bounds."	| clipR |	contentsChanged ifTrue: [		self updateContentsExtent.		self updateScrollbars.		contentsChanged := false].	"draw my contents morph clipped to my visible extent"	aCanvas isShadowDrawing ifFalse: [ 	clipR := self innerBounds topLeft extent: self visibleExtent.	(aCanvas copyClipRect: clipR) fullDrawMorph: contents].	"draw all my submorphs other than my contents"	submorphs reverseDo:[:m |		(m ~~ contents) ifTrue: [aCanvas fullDrawMorph: m]].! !!ScrollFrameMorph2 methodsFor: 'geometry' stamp: 'EiichiroIto 11/22/2019 15:22'!extent: aPoint	"After setting my size, position and size my scrollbars and grow box. Also update my contents and scrollbar ranges."	| inner w h |	super extent: (aPoint truncated max: self minWidth @ self minHeight).	scrollBarStartInset		ifNil: [ scrollBarStartInset := scrollBarEndInset := 0 ].	"needed during initialization"	inner := self innerBounds.	w := inner width - scrollBarStartInset.	vScrollbar owner = self		ifTrue: [ w := w - vbarInset ]		ifFalse: [ w := w - scrollBarEndInset ].	hScrollbar		position: (inner left + scrollBarStartInset) @ (inner bottom - hbarInset).	hScrollbar width: w.	h := inner height - scrollBarStartInset.	hScrollbar owner = self		ifTrue: [ h := h - hbarInset ]		ifFalse: [ h := h - scrollBarEndInset ].	vScrollbar		position: (inner right - vbarInset) @ (inner top + scrollBarStartInset).	vScrollbar height: h.	self updateContentsExtent.	self updateScrollbars! !!ScrollFrameMorph2 methodsFor: 'initialization' stamp: 'jm 5/26/2005 18:22'!initialize	super initialize.	self borderWidth: 0.	self removeAllMorphs.	self color: Color blue.	hbarInset := 30.	vbarInset := 25.	scrollBarStartInset := 10.	scrollBarEndInset := 14.	contentsChanged := false.	contents := PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		enableDragNDrop: true.	hScrollbar := ScratchScrollBar newHorizontal		target: self;		selector: #hScrollRelative:.	vScrollbar := ScratchScrollBar newVertical		target: self;		selector: #vScrollRelative:.	contents position: self position + borderWidth.	self addMorph: contents.	self addMorph: hScrollbar.	self addMorph: vScrollbar.	self extent: 160@120.! !!ScrollFrameMorph2 methodsFor: 'scrolling' stamp: 'ee 10/24/2007 19:45'!scrollMorphIntoView: aMorph	| offset |	(self bounds containsRect: aMorph fullBounds) ifTrue: [^ self].	((aMorph fullBounds top < self top) and: [(aMorph fullBounds top < contents top) not]) ifTrue: [		offset := aMorph fullBounds top - contents top.		contents top: (self top + 3) - offset].	((aMorph fullBounds left < self left) and: [(aMorph fullBounds left < contents left) not]) ifTrue: [		offset := aMorph fullBounds left - contents left.		contents left: (self left + 3) - offset].	(aMorph fullBounds right > self right) ifTrue: [		offset := aMorph fullBounds right - contents left.		contents left: (self right - 3) - offset].	(aMorph fullBounds bottom > self bottom) ifTrue: [		offset := aMorph fullBounds bottom - contents top.		contents top: (self bottom - 3) - offset].	self updateContentsExtent.	self updateScrollbars.! !!ScrollFrameMorph2 methodsFor: 'geometry' stamp: 'jm 6/28/2008 12:35'!scrollbarStartInset: startInset endInset: endInset	scrollBarStartInset := startInset.	scrollBarEndInset := endInset.! !!ScrollFrameMorph2 methodsFor: 'scrollbar visibility' stamp: 'jm 4/6/2005 17:07'!showHorizontalScrollbar: aBoolean	"Show or hide my horizontal scrollbar."	aBoolean = (hScrollbar owner = self) ifTrue: [^ self].	aBoolean		ifTrue: [self addMorph: hScrollbar]		ifFalse: [hScrollbar delete].	self extent: self extent.! !!ScrollFrameMorph2 methodsFor: 'scrollbar visibility' stamp: 'jm 4/6/2005 17:07'!showVerticalScrollbar: aBoolean	"Show or hide my vertical scrollbar."	aBoolean = (vScrollbar owner = self) ifTrue: [^ self].	aBoolean		ifTrue: [self addMorph: vScrollbar]		ifFalse: [vScrollbar delete].	self extent: self extent.! !!StringFieldMorph methodsFor: 'private' stamp: 'tis 12/18/2006 15:43'!acceptEdits	"Tell the client to accept edits."	client ifNil: [^ self].	(client respondsTo: #accept) ifTrue: [client accept].	(client respondsTo: #acceptContents) ifTrue: [client acceptContents].	(client respondsTo: #yes) ifTrue: [client yes].! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 4/4/2005 08:13'!acceptWhenFocusLost: aBoolean	"If true, then accept my contents (as if the user hit the enter key) I lose the keyboard focus lost."	acceptWhenFocusLost := aBoolean.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'jm 7/3/2008 11:06'!backspace	"Delete the current selection. If there is no selection, delete the character before the cursor."	| str newStr |	(self rightSelection - self leftSelection) > 0 ifTrue: [^ self removeSelection].	self leftSelection < 1 ifTrue: [^ self].	self recordUndoState.	str := stringMorph contents.	newStr :=		(str copyFrom: 1 to: self leftSelection - 1),		(str copyFrom: self leftSelection + 1 to: str size).	stringMorph contentsClipped: newStr.	selectionEnd := selectionStart := (self leftSelection - 1) max: 0.	self stringChanged.! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 7/4/2008 08:35'!borderWidth: aNumber	"Adjust the position of my stringMorph to the new border size."	super borderWidth: (aNumber asInteger max: 0).	stringMorph position: self position + borderWidth + (insetX@insetY).! !!StringFieldMorph methodsFor: 'private' stamp: 'jm 8/8/2008 14:54'!characterOffsetForXOffset: screenX	"Answer the character offset at the given width into the string."	| x xRanges p best isLTR |	stringMorph contents size = 0 ifTrue: [^ 0].	x := screenX - stringMorph leftMargin.  "x offset within the string"	xRanges := stringMorph xRangesFor: stringMorph stringToDisplay.	1 to: xRanges size do: [:i |		p := xRanges at: i.		(x between: p first and: p last) ifTrue: [			isLTR := self isLTRAt: i in: xRanges.			(x - p first) <= (p last - x)   "left half of character?"				ifTrue: [^ isLTR ifTrue: [i - 1] ifFalse: [i]]				ifFalse: [^ isLTR ifTrue: [i] ifFalse: [i - 1]]]].	"x is not within any x-range"	x < 0		ifTrue: [  "x is left of the entire string; find left-most char index"			best := 1.			1 to: xRanges size do: [:i |				p := xRanges at: i.				p first < (xRanges at: best) first ifTrue: [best := i]].			best = 1 ifTrue: [best := 0].			^ best]		ifFalse: [  "x is right of entire string; find right-most char index"			best := 1.			1 to: xRanges size do: [:i |				p := xRanges at: i.				p last > (xRanges at: best) last ifTrue: [best := i]].			best = 1 ifTrue: [best := 0].			^ best].! !!StringFieldMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/22/2016 22:20'!click: evt	| hadFocus |	hadFocus := isKeyboardFocus.	evt hand newKeyboardFocus: self.	hadFocus		ifTrue: [			selectionStart := self characterOffsetForXOffset: evt cursorPoint x.			selectionEnd := selectionStart]		ifFalse: [			self selectAll].	self stringChanged.! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 9/10/2004 18:59'!client: aMorphOrNil	client := aMorphOrNil.! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 7/4/2008 11:08'!color	frame ifNotNil: [^ frame color].	^ color = Color transparent		ifTrue: [owner color]		ifFalse: [color]! !!StringFieldMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/25/2016 23:00'!contents	^ stringMorph contents! !!StringFieldMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/15/2016 13:11'!contents: aString	doResizing		ifTrue: [stringMorph contents: aString "asUTF32"]		ifFalse: [stringMorph contentsClipped: aString "asUTF32"].	self stringChanged.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'EiichiroIto 11/22/2019 16:24'!copySelection	"Save the current selection in the clipboard."	| s |	s := stringMorph contents		copyFrom: self leftSelection + 1		to: self rightSelection.	s isEmpty		ifTrue: [ ^ self ].	ScratchTranslator unicodeClipboardPut: s! !!StringFieldMorph methodsFor: 'private' stamp: 'EiichiroIto 9/26/2016 22:02'!currsorOffsetFor: characterOffset	"Answer the insertion cursor x offset for the given character offset."	| s xRanges xPairChar0 xPairCharLast startsOnLeft r xPairCharOffset |	stringMorph contents size = 0 ifTrue: [^ 0].	s := stringMorph stringToDisplay.	xRanges := stringMorph xRangesFor: s.	xPairChar0 := xRanges at: 1.	xPairCharLast := xRanges last.	startsOnLeft := xPairChar0 first < xPairCharLast last.	"special case for a single character; double it to see if it is RTL"	xRanges size = 1 ifTrue: [		r := stringMorph xRangesFor: (s, s).		startsOnLeft := r first first < r last last].	"if string starts left-to-right, then put cursor on the left side left of first char, otherwise put it on the right side"	characterOffset < 1 ifTrue: [		startsOnLeft			ifTrue: [^ xPairChar0 first]			ifFalse: [^ xPairChar0 last - 1]].	xPairCharOffset := xRanges at: (characterOffset min: xRanges size).	"if string starts left-to-right, then put cursor on right size of character"	startsOnLeft		ifTrue: [^ xPairCharOffset last]		ifFalse: [^ xPairCharOffset first].! !!StringFieldMorph methodsFor: 'text editing' stamp: 'tis 3/2/2007 20:04'!cutSelection	"Cut the current selection."	selectionStart = selectionEnd ifTrue: [^ self].  "no selection; do nothing"	self copySelection.  "save the selection we're about to cut"	self removeSelection.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'jm 7/3/2008 11:06'!deleteSelection	"Delete the current selection. If there is no selection, delete the character after the cursor."	| str newStr |	str := stringMorph contents.	(self rightSelection - self leftSelection) > 0 ifTrue: [^ self removeSelection].	(self rightSelection >= str size) ifTrue: [^ self].	self recordUndoState.	newStr :=		(str copyFrom: 1 to: self leftSelection),		(str copyFrom: self leftSelection + 2 to: str size).	stringMorph contentsClipped: newStr.	selectionEnd := selectionStart := self leftSelection max: 0.	self stringChanged.! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 12/31/2005 09:23'!doResizing: aBoolean	"If true, resize myself to the size of the string."	doResizing := aBoolean.! !!StringFieldMorph methodsFor: 'event handling' stamp: 'jm 7/3/2008 10:58'!doubleClick: evt	"Select word or entire contents."	| xOffset i |	evt hand newKeyboardFocus: self.	xOffset := evt cursorPoint x - stringMorph left.	xOffset < 3 ifTrue: [^ self selectAll].	i := self characterOffsetForXOffset: evt cursorPoint x.	self selectWordOrAll: i + 1.! !!StringFieldMorph methodsFor: 'drawing' stamp: 'jm 7/4/2008 11:08'!drawOn: aCanvas	"Draw the background then the selection."	frame		ifNil: [			super drawOn: aCanvas]		ifNotNil: [			frame position: self topLeft; extent: self extent.			frame drawOn: aCanvas].	isKeyboardFocus ifTrue: [self drawSelectionOn: aCanvas].! !!StringFieldMorph methodsFor: 'drawing' stamp: 'jm 8/8/2008 14:48'!drawSelectionOn: aCanvas 	| xRanges clipC vInset offset selectionH rect pair start end |	xRanges := stringMorph xRangesFor: stringMorph stringToDisplay.	clipC := aCanvas copyClipRect: self innerBounds.	vInset := borderWidth + 2.	offset := stringMorph leftMargin@(self top + vInset).	selectionH := self height - (2 * vInset).	selectionStart = selectionEnd ifTrue: [		blinkState ifNil: [blinkState := true].		blinkState ifTrue: [			rect := ((self currsorOffsetFor: selectionStart) - 1)@0 extent: 2@selectionH.			clipC fillRectangle: (rect translateBy: offset) color: selectionColor].		^ self].	selectionStart < selectionEnd		ifTrue: [			start := selectionStart + 1.			end := selectionEnd]		ifFalse: [			start := selectionEnd + 1.			end := selectionStart].	start to: end do: [:i |		(i between: 1 and: xRanges size) ifTrue: [			pair := xRanges at: i.			rect := (pair first @ 0) corner: (pair second @ selectionH).			clipC fillRectangle: (rect translateBy: offset) color: selectionColor]].! !!StringFieldMorph methodsFor: 'drawing' stamp: 'jm 7/1/2008 10:16'!drawSubmorphsOn: aCanvas	"Clip submorph drawing to my bounds."	"stringMorph suppressAntiAliasing: isKeyboardFocus."	super drawSubmorphsOn: (aCanvas copyClipRect: self innerBounds).! !!StringFieldMorph methodsFor: 'geometry' stamp: 'jm 7/4/2008 09:13'!extent: aPoint	super extent: aPoint.	stringMorph width: ((self width - (2 * borderWidth) - insetX) max: 0).! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 7/2/2008 11:58'!font	^ stringMorph font! !!StringFieldMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/25/2016 23:00'!font: aFont	stringMorph font: aFont.	stringMorph height: (stringMorph stringHeight: ScratchTranslator renderHintString).	self height: stringMorph height + (2 * borderWidth) + heightPadding.	insetY := (self height // 2) - borderWidth - (ScratchTranslator centerOffsetForButtonWithFont: aFont).	insetY := insetY max: 1.	self borderWidth: borderWidth.  "re-position string"! !!StringFieldMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 22:01'!forExpressionArg	frame := nil.	borderColor := Color transparent.	borderWidth := 0.	insetX := 0.	heightPadding := 2.	self font: (ScratchTheme argFont).! !!StringFieldMorph methodsFor: 'geometry' stamp: 'jm 6/29/2008 14:44'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	fullBounds ifNil: [fullBounds := bounds].	^ bounds! !!StringFieldMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/22/2016 21:41'!handlesKeyboard: evt	^ true! !!StringFieldMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/3/2019 21:27'!handlesMouseDown: evt	^ self isEditable "& evt hand toolType isNil"! !!StringFieldMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 22:06'!initialize	super initialize.	stringMorph := StringMorph new		contents: '';		font: (StrikeFont fontName: 'Verdana' size: 12).	self addMorph: stringMorph.	color := ScratchTheme fieldColor.	self textColor: ScratchTheme dialogBoxTextColor.	doResizing := false.	isNumeric := false.	isEditable := true.	isKeyboardFocus := false.	acceptWhenFocusLost := false.	self keyboardFocusChange: false.	selectionColor := ScratchTheme textSelectionColor.	selectionStart := selectionEnd := 0.	self recordUndoState.	self borderInset; useNoFrame.	self width: 100.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'EiichiroIto 9/26/2016 22:02'!insertCharacter: unicodeChar	"Insert the given character at the cursor position."	| str newStr insertion |	isNumeric ifTrue: [		('-0123456789.,' asByteArray includes: unicodeChar)			ifFalse: [^ self beep]].	self recordUndoState.	str := stringMorph contents.	"insertion := UTF32 with: unicodeChar."	insertion := (Unicode charFromUnicode: unicodeChar) asString.	newStr :=		(str copyFrom: 1 to: self leftSelection),		insertion,		(str copyFrom: (self rightSelection + 1) to: str size).	selectionEnd := selectionStart := self leftSelection + 1.	stringMorph contentsClipped: newStr.	self stringChanged.! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 7/11/2008 06:53'!isEditable	"Answer true if I am editable."	isEditable ifNil: [isEditable := true].	^ isEditable! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 7/11/2008 06:53'!isEditable: aBoolean	isEditable := aBoolean.! !!StringFieldMorph methodsFor: 'private' stamp: 'jm 8/8/2008 14:44'!isLTRAt: index in: xRange	"True if the character at the given index in the given xRange is LTR."	"Note: we decide direction based on the following character if possible."	xRange size < 2 ifTrue: [^ true].  "can't tell direction from a single character; assume LTR"		index >= xRange size ifTrue: [		^ (xRange at: xRange size - 1) first < xRange last first]. "at end; compare to previous character"	^ (xRange at: index) first < (xRange at: index + 1) first! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 12/31/2005 10:15'!isNumeric: aBoolean	"If true, then only allow typing digits and decimal point."	isNumeric := aBoolean.! !!StringFieldMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/16/2019 17:40'!keyStroke: evt	| ch m |	ch := evt keyCharacter asUnicode.	ch = 0 ifTrue: [ch := evt keyValue].	evt buttons = 64 ifTrue: [ch := ch \\ 32].  "command (alt) key pressed; map to a control key"	(ch = 3) & (evt buttons = 0) ifTrue: [ch := 13].  "map enter key to cr"	ch = 9 ifTrue: [  "tab"		"(m := self meOrOwnerThatIsA: DialogBoxMorph) ifNotNil: [m tabToNextField: evt]."		(m := self meOrOwnerThatIsA: CommandBlockMorph) ifNotNil: [m tabToNextField: evt].		^ self].	(ch = 10) | (ch = 13) ifTrue: [  "cr, lf, or enter key"		"(m := self meOrOwnerThatIsA: DialogBoxMorph) ifNotNil: [^ m enterKeyPressed: evt]."		"(m := self meOrOwnerThatIsA: ScratchPrompterMorph) ifNotNil: [^ m enterKeyPressed]."		evt hand newKeyboardFocus: nil.		^ self].	ch = 27 ifTrue: [  "escape key"		"(m := self meOrOwnerThatIsA: DialogBoxMorph) ifNotNil: [m escapeKeyPressed: evt]."		^ self].	ch = 8 ifTrue: [^ self backspace].	ch = 127 ifTrue: [^ self deleteSelection].	(evt buttons = 64) | (evt buttons = 16) ifTrue: [	"ctrl (or alt) is pressed"		ch = 1 ifTrue: [self selectAll].		"ctrl-a"		ch = 3 ifTrue: [self copySelection]. 	"ctrl-c"		ch = 22 ifTrue: [self paste].			"ctrl-v"		ch = 24 ifTrue: [self cutSelection].	"ctrl-x"		ch = 26 ifTrue: [self undo]].			"ctrl-z"	evt buttons = 8 ifTrue: [ "shift is pressed"		ch = 28 ifTrue: [self moveCursorLeftAndSelect].  	"shift-left"		ch = 29 ifTrue: [self moveCursorRightAndSelect].	"shift-right"		ch = 1 ifTrue: [self moveCursorHomeAndSelect].	"home"		ch = 4 ifTrue: [self moveCursorEndAndSelect]].	"end"	evt buttons = 0 ifTrue: [		ch = 1 ifTrue: [self moveCursorHome].	"home"		ch = 4 ifTrue: [self moveCursorEnd].		"end"		ch = 28 ifTrue: [self moveCursorLeft].	"left"		ch = 29 ifTrue: [self moveCursorRight].	"right"		blinkState := true].	ch >= 32 ifTrue: [self insertCharacter: ch].! !!StringFieldMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/15/2016 17:22'!keyboardFocusChange: amGettingFocus	"Set my color to show whether I have focus."	(amGettingFocus and: [isKeyboardFocus not]) ifTrue: [		lastContents := stringMorph contents].	(isKeyboardFocus and: [amGettingFocus not]) ifTrue: [		lastContents := nil.		isNumeric ifTrue: [			self contents: stringMorph contents asNumberNoError printString].		acceptWhenFocusLost ifTrue: [self acceptEdits]].	isKeyboardFocus := amGettingFocus.	isKeyboardFocus ifTrue: [selectionStart := 0. selectionEnd := stringMorph contents size].	self changed.! !!StringFieldMorph methodsFor: 'private' stamp: 'tis 3/2/2007 19:46'!leftSelection	^ selectionStart min: selectionEnd! !!StringFieldMorph methodsFor: 'event handling' stamp: 'jm 7/3/2008 10:58'!mouseDown: evt	dragStartIndex := self characterOffsetForXOffset: evt cursorPoint x.	evt hand waitForClicksOrDrag: self event: evt.! !!StringFieldMorph methodsFor: 'event handling' stamp: 'jm 7/3/2008 10:58'!mouseMove: evt	| currIndex |	dragStartIndex ifNil: [dragStartIndex := 0].	currIndex := self characterOffsetForXOffset: evt cursorPoint x.	selectionStart := currIndex min: dragStartIndex.	selectionEnd := currIndex max: dragStartIndex.	self changed.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'tis 8/2/2006 15:14'!moveCursorEnd	"Move the cursor (selectionStart) to the end of the current line."	self moveCursorEndAndSelect.	selectionEnd := selectionStart.	self changed.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'tis 8/2/2006 15:15'!moveCursorEndAndSelect	"Move the cursor (selectionStart), and select contents, to the end of the current line."	self recordUndoState.	selectionStart := stringMorph contents size.	self changed.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'tis 8/2/2006 15:15'!moveCursorHome	"Move the cursor (selectionStart) to the beginning of the current line."	self moveCursorHomeAndSelect.	selectionEnd := selectionStart.	self changed.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'tis 8/2/2006 15:16'!moveCursorHomeAndSelect	"Move the cursor (selectionStart), and select contents, to the beginning of the current line."	self recordUndoState.	selectionStart := 0.	self changed.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'tis 8/1/2006 15:14'!moveCursorLeft	"Move the cursor (selectionStart) left by one character."	self moveCursorLeftAndSelect.	selectionEnd := selectionStart.	self changed.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'tis 8/2/2006 15:16'!moveCursorLeftAndSelect	"Move the cursor (selectionStart), and select, left by one character."	self recordUndoState.	selectionStart := (selectionStart - 1) max: 0.	self changed.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'tis 8/1/2006 15:13'!moveCursorRight	"Move the cursor (selectionStart) right by one character."	self moveCursorRightAndSelect.	selectionEnd := selectionStart.	self changed.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'tis 8/2/2006 15:16'!moveCursorRightAndSelect	"Move the cursor (selectionStart), and select, right by one character."	self recordUndoState.	selectionStart := (selectionStart + 1) min: stringMorph contents size.	self changed.! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 3/26/2008 12:29'!passwordMode: aBoolean	stringMorph passwordMode: aBoolean.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'EiichiroIto 11/22/2019 16:24'!paste	"Paste the last cut or copy over the current selection."	| strToInsert str newStr |	strToInsert := ScratchTranslator unicodeClipboard.	strToInsert isEmpty ifTrue: [^ self].	self recordUndoState.	str := stringMorph contents.	newStr :=		(str copyFrom: 1 to: self leftSelection),		strToInsert,		(str copyFrom: (self rightSelection + 1) to: str size).	selectionEnd := selectionStart := self leftSelection + strToInsert size.	stringMorph contentsClipped: newStr.	self stringChanged.! !!StringFieldMorph methodsFor: 'event handling' stamp: 'jm 9/10/2004 18:52'!preemptsMouseDown: evt	^ true! !!StringFieldMorph methodsFor: 'text editing' stamp: 'jm 9/14/2004 15:09'!recordUndoState	"Remember the current contents and selection to allow undo."	undoState := Array		with: stringMorph contents		with: selectionStart		with: selectionEnd.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'jm 7/3/2008 11:07'!removeSelection	"Cut the current selection."	| str newStr |	self recordUndoState.	str := stringMorph contents.	newStr := 		(str copyFrom: 1 to: self leftSelection), 		(str copyFrom: self rightSelection + 1 to: str size).	stringMorph contentsClipped: newStr.	selectionEnd := selectionStart := self leftSelection.	self stringChanged.! !!StringFieldMorph methodsFor: 'private' stamp: 'tis 3/2/2007 19:46'!rightSelection	^ selectionStart max: selectionEnd! !!StringFieldMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/25/2016 22:59'!savedContents	"If the user is editing, return the last contents before editing. Otherwise, return my contents."	(isKeyboardFocus and: [lastContents notNil]) ifTrue: [^ lastContents].	^ stringMorph contents! !!StringFieldMorph methodsFor: 'text editing' stamp: 'jm 9/14/2004 15:21'!selectAll	"Select my entire contents."	self recordUndoState.	selectionStart := 0.	selectionEnd := stringMorph contents size.	self changed.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'jm 9/14/2004 16:10'!selectWordOrAll: index	| str wordStart wordEnd |	str := stringMorph contents.	(index < 1) | (index > str size) ifTrue: [^ self selectAll].  "off end, select all"	(str at: index) isSeparator ifTrue: [^ self].  "on separator; do nothing"	self recordUndoState.	wordStart := index.	[(wordStart >= 1) and: [(str at: wordStart) isSeparator not]]		whileTrue: [wordStart := wordStart - 1].	wordEnd := index.	[(wordEnd < str size) and: [(str at: wordEnd) isSeparator not]]		whileTrue: [wordEnd := wordEnd + 1].	(str at: wordEnd) isSeparator ifTrue: [wordEnd := wordEnd - 1].	selectionStart := wordStart.	selectionEnd := wordEnd.	self changed.! !!StringFieldMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/29/2016 17:43'!startDrag: evt	"Do nothing if have keyboard focus. Otherwise, allow myself to be grabbed."	| myBlock |	isKeyboardFocus ifFalse: [		myBlock := self meOrOwnerThatIsA: BlockMorph.		myBlock			ifNil: [super startDrag: evt]			ifNotNil: [myBlock startDrag: evt]].! !!StringFieldMorph methodsFor: 'stepping' stamp: 'jm 11/28/2007 19:23'!step	isKeyboardFocus ifFalse: [^ self].	blinkState ifNil: [blinkState := false].	blinkState := blinkState not.	selectionStart = selectionEnd ifTrue: [self changed].! !!StringFieldMorph methodsFor: 'stepping' stamp: 'jm 11/28/2007 10:47'!stepTime	^ 600! !!StringFieldMorph methodsFor: 'private' stamp: 'jm 7/4/2008 13:43'!stringChanged	"My string has changed. Resize myself if necessary and report the change."	doResizing ifTrue: [		stringMorph fitContents.		self width: (stringMorph right - self left) + borderWidth + 3].	(owner respondsTo: #fixArgLayout) ifTrue: [owner fixArgLayout].	self changed.! !!StringFieldMorph methodsFor: 'accessing' stamp: 'jm 3/17/2005 12:16'!textColor: aColor	"Set the color of my text."	stringMorph color: aColor.! !!StringFieldMorph methodsFor: 'text editing' stamp: 'jm 7/3/2008 11:07'!undo	"Swap the undo buffer witht the current state. Doing this a second time will undo the undo operation."	| oldUndoState |	oldUndoState := undoState.	self recordUndoState.	stringMorph contentsClipped: (oldUndoState at: 1).	selectionStart := (oldUndoState at: 2).	selectionEnd := (oldUndoState at: 3).	self stringChanged.! !!StringFieldMorph methodsFor: 'initialization' stamp: 'jm 7/4/2008 11:39'!useNoFrame	frame := nil.	borderWidth := 2.	insetX := 2.	heightPadding := 3.	self font: stringMorph font.! !!StringFieldMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 22:06'!useStringFieldFrame	frame := ImageFrameMorph new initFromForm: (ScratchTheme formAt: #stringFieldFrame).	insetX := 3.	heightPadding := 9.	borderWidth := 5.	self font: stringMorph font.! !!StringFieldMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 22:06'!useTypeinFrame	frame := ImageFrameMorph new initFromForm: (ScratchTheme formAt: #typein).	insetX := 2.	heightPadding := 5.	borderWidth := 2.	self font: stringMorph font.! !!BaseIdTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 13:47'!newBaseId	^ BaseId new! !!BaseIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:48'!testInitialize	| e |	e := self newBaseId.	self assert: e privNextNo equals: e class defaultUserNo.! !!BaseIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:48'!testNewNo	| e |	e := self newBaseId.	self assert: e privNextNo equals: e class defaultUserNo.	e newNo.	self assert: e privNextNo equals: e class defaultUserNo + 1.	e newNo.	self assert: e privNextNo equals: e class defaultUserNo + 2.! !!BaseIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:48'!testPrivNextNo	| e |	e := self newBaseId.	e privNextNo: 10.	self assert: e privNextNo equals: 10.	e privNextNo: 20.	self assert: e privNextNo equals: 20.! !!BaseIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:48'!testRewind	| s |	s := self newBaseId.	self assert: s size equals: 0.	5 timesRepeat: [s newNo].	self assert: s size equals: 5.	s rewind.	self assert: s size equals: 0.! !!BaseIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:48'!testSize	| e |	e := self newBaseId.	self assert: e size equals: e class reservedNo.	e newNo.	self assert: e size equals: e class reservedNo + 1.! !!BaseIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:48'!testUserDefinedVarNos	| e |	e := self newBaseId.	self assertCollection: e userDefinedVarNos equals: #().	e newNo.	self assertCollection: e userDefinedVarNos equals: #(1).	e newNo.	self assertCollection: e userDefinedVarNos equals: #(1 2).! !!EventIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/17/2019 21:26'!testLoopEventNo	self assert: EventId loopEventNo equals: 3.! !!EventIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/17/2019 21:26'!testReservedNo	self assert: EventId reservedNo equals: EventId singleEventNo.! !!EventIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/17/2019 21:26'!testSetupEventNo	self assert: EventId setupEventNo equals: 2.! !!EventIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/17/2019 21:26'!testSingleEventNo	self assert: EventId singleEventNo equals: 4.! !!EventIdTest methodsFor: 'test' stamp: 'EiichiroIto 10/17/2019 21:26'!testStartupEventNo	self assert: EventId startupEventNo equals: 1.! !!LazyArrayTest methodsFor: 'instance creation' stamp: 'EiichiroIto 10/27/2019 12:34'!newArray: aSymbol	^ LazyArray className: aSymbol! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/24/2019 21:57'!testAllocateMore	| l |	l := LazyArray className: #FloatArray.	l allocateMore: 10.	self assert: (l privArray isKindOf: FloatArray).	self assert: l privArray size equals: l defaultAllocationSize.	l allocateMore: 10.	self assert: (l privArray isKindOf: FloatArray).	self assert: l privArray size equals: l defaultAllocationSize * 2.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/27/2019 16:48'!testArray	| a |	a := self newArray: #FloatArray.	self assert: a array class equals: FloatArray.	self assert: a array size equals: 0.	a at: 10 put: 1.	self assert: a array class equals: FloatArray.	self assert: a array size equals: 100.	self assert: (a array at: 10) equals: 1! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/22/2019 12:08'!testArrayClass	| l |	l := LazyArray basicNew.	l className: #FloatArray.	self assert: l arrayClass equals: FloatArray.	l := LazyArray basicNew.	l className: #ByteArray.	self assert: l arrayClass equals: ByteArray.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/27/2019 16:33'!testAssureExistsIndex	| a |	a := self newArray: #Array.	self assert: a privArray isNil.	a assureExistsIndex: 10.	a at: 9 put: 1.	a at: 10 put: 2.	self assert: a privArray isArray.	self assert: a privArray size equals: 100.	a assureExistsIndex: 20.	self assert: a privArray isArray.	self assert: a privArray size equals: 100.	self assert: (a at: 9) equals: 1.	self assert: (a at: 10) equals: 2.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/27/2019 16:37'!testAssureExistsIndexAnd	| a |	a := self newArray: #Array.	a defaultValue: 2.	self assert: a privArray isNil.	a assureExistsIndex: 10 and: 20.	self assert: a privArray isArray.	self assert: a privArray size equals: 100.	self assert: (a at: 10) isCollection.	self assert: (a at: 10) size equals: 20.	self assert: ((a at: 10) at: 1) equals: 2.	self assert: ((a at: 10) at: 20) equals: 2.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/21/2019 17:54'!testAt	| l a |	l := LazyArray basicNew.	self assert: (l at: 1) equals: 0.	a := FloatArray new: 5.	a at: 2 put: 3.	a at: 5 put: 9.	l privArray: a.	self assert: (l at: 1) equals: 0.0.	self assert: (l at: 2) equals: 3.0.	self assert: (l at: 3) equals: 0.0.	self assert: (l at: 4) equals: 0.0.	self assert: (l at: 5) equals: 9.0.	self assert: (l at: 6) equals: 0.0.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/24/2019 21:58'!testAtPut	| l |	l := LazyArray className: #FloatArray.	self assert: l privArray isNil.	l at: 1 put: 1.	self assert: l privArray size equals: l defaultAllocationSize.	self assert: (l at: 1) equals: 1.	l at: 2 put: 2.	l at: 3 put: 3.	self assert: (l at: 1) equals: 1.	self assert: (l at: 2) equals: 2.	self assert: (l at: 3) equals: 3.	l at: 103 put: 103.	self assert: l privArray size equals: l defaultAllocationSize * 2.	self assert: (l at: 1) equals: 1.	self assert: (l at: 2) equals: 2.	self assert: (l at: 3) equals: 3.	self assert: (l at: 103) equals: 103.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:32'!testClassName	| l |	l := LazyArray basicNew.	self assert: l className isNil.	l className: #FloatArray.	self assert: l className equals: #FloatArray! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/23/2019 22:11'!testDefaultAllocationSize	| l |	l := LazyArray basicNew.	self assert: l defaultAllocationSize equals: 100.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/27/2019 12:34'!testDefaultValue	| a |	a := self newArray: #FloatArray.	self assert: a defaultValue equals: 0.	a defaultValue: 12.	self assert: a defaultValue equals: 12.	self should: [ a defaultValue: 10 ] raise: Error! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/24/2019 22:11'!testFixedSize	self testPrivFixedSize.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/24/2019 22:03'!testForceSize	| l |	l := LazyArray className: #FloatArray.	self assert: l size equals: 0.	l at: 20 put: 1.	self assert: l size equals: l defaultAllocationSize.	l forceSize: 10.	self assert: l size equals: 10.	l forceSize: 20.	self assert: l size equals: 20.	l reset.	self should: [ l at: 30 put: 1 ] raise: Error.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/24/2019 22:05'!testIsEmpty	| l |	l := LazyArray className: #FloatArray.	self assert: l isEmpty.	l at: 1 put: 2.	self deny: l isEmpty.	l reset.	self assert: l isEmpty.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/24/2019 22:07'!testIsFixed	| l |	l := LazyArray className: #FloatArray.	self deny: l isFixed.	l at: 20 put: 1.	self deny: l isFixed.	l forceSize: 10.	self assert: l isFixed.	l reset.	self assert: l isFixed.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/28/2019 20:07'!testListAdd	| a |	a := self newArray: #Array.	a defaultValue: 0.	self assert: (a list: 5 at: 2) equals: 0.	a list: 5 add: 10.	a list: 5 add: 20.	self assert: (a list: 5 at: 1) equals: 10.	self assert: (a list: 5 at: 2) equals: 20.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/28/2019 20:08'!testListAt	| a |	a := self newArray: #Array.	a defaultValue: ''.	self assert: (a list: 5 at: 2) equals: ''.	self assert: a privArray size equals: 100.	self assert: a privArray first equals: nil.	self assert: a privArray fifth equals: nil.	a assureExistsIndex: 5 and: 3.	self assert: (a list: 5 at: 2) equals: ''.	self assert: a privArray fifth class equals: OrderedCollection.	self assert: a privArray fifth size equals: 3.	self assert: a privArray fifth first equals: ''.	self assert: a privArray fifth second equals: ''.	self assert: a privArray fifth third equals: ''.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 21:01'!testListAtPut	| a |	a := self newArray: #Array.	a defaultValue: ''.	self assert: (a list: 5 at: 2) equals: ''.	a list: 5 at: 2 put: 'a'.	a list: 5 at: 3 put: 'b'.	self assert: (a list: 5 at: 1) equals: ''.	self assert: (a list: 5 at: 2) equals: 'a'.	self assert: (a list: 5 at: 3) equals: 'b'! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/28/2019 20:08'!testListContains	| a |	a := self newArray: #Array.	a defaultValue: 0.	self assert: (a list: 5 at: 2) equals: 0.	a list: 5 add: 10.	a list: 5 add: 20.	a list: 5 add: 30.	self assert: (a list: 5 at: 1) equals: 10.	self assert: (a list: 5 at: 2) equals: 20.	self assert: (a list: 5 at: 3) equals: 30.	self assert: (a list: 5 contains: 10).	self assert: (a list: 5 contains: 20).	self assert: (a list: 5 contains: 30).	self deny: (a list: 5 contains: 0).	self deny: (a list: 5 contains: 40).! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/28/2019 20:10'!testListRemove	| a |	a := self newArray: #Array.	a defaultValue: 0.	self assert: (a list: 5 at: 2) equals: 0.	a list: 5 add: 10.	a list: 5 add: 20.	a list: 5 add: 30.	self assert: (a list: 5 at: 1) equals: 10.	self assert: (a list: 5 at: 2) equals: 20.	self assert: (a list: 5 at: 3) equals: 30.	a list: 5 remove: 2.	self assert: (a list: 5 at: 1) equals: 10.	self assert: (a list: 5 at: 2) equals: 30.	self assert: (a listSizeOf: 5) equals: 2.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/28/2019 20:15'!testListSet	| a |	a := self newArray: #Array.	a defaultValue: 0.	a list: 5 set: #(10 20 30).	self assert: (a list: 5 at: 1) equals: 10.	self assert: (a list: 5 at: 2) equals: 20.	self assert: (a list: 5 at: 3) equals: 30! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/28/2019 20:10'!testListSizeOf	| a |	a := self newArray: #Array.	a defaultValue: ''.	self assert: (a listSizeOf: 5) equals: 0.	a list: 5 at: 2 put: 'a'.	self assert: (a listSizeOf: 5) equals: 2.	a list: 5 at: 3 put: 'a'.	self assert: (a listSizeOf: 5) equals: 3.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/29/2019 14:25'!testMultiplyBy	| l |	l := LazyArray className: #FloatArray.	l at: 1 put: 10.	l at: 2 put: 20.	l at: 3 put: 30.	self assert: (l at: 1) equals: 10.	self assert: (l at: 2) equals: 20.	self assert: (l at: 3) equals: 30.	l multiplyBy: 2.	self assert: (l at: 1) equals: 20.	self assert: (l at: 2) equals: 40.	self assert: (l at: 3) equals: 60! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 10/27/2019 16:46'!testPrintOn	| a st |	a := self newArray: #FloatArray.	st := WriteStream on: ''.	a printOn: st.	self assert: st contents equals: 'LazyArray(FloatArray,0)'.	a at: 3 put: 10.	st := WriteStream on: ''.	a printOn: st.	self assert: st contents equals: 'LazyArray(FloatArray,100)'.	a forceSize: 10.	st := WriteStream on: ''.	a printOn: st.	self assert: st contents equals: 'LazyArray(FloatArray,*10)'.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/21/2019 17:51'!testPrivArray	| l a b |	l := LazyArray basicNew.	self assert: l privArray isNil.	a := #(1 2 3).	b := #(4 5 6).	l privArray: a.	self assertCollection: l privArray equals: a.	l privArray: b.	self assertCollection: l privArray equals: b.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/24/2019 22:11'!testPrivFixedSize	| l |	l := LazyArray className: #FloatArray.	self assert: l fixedSize isNil.	l privFixedSize: 10.	self assert: l fixedSize equals: 10.	l privFixedSize: 20.	self assert: l fixedSize equals: 20.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/23/2019 20:08'!testReset	| l |	l := LazyArray className: #FloatArray.	self assert: l privArray isNil.	l at: 1 put: 1.	self assert: l privArray notNil.	l reset.	self assert: l privArray isNil.	l at: 1 put: 1.	self assert: l privArray notNil.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/22/2019 19:53'!testSetArray	| l a b |	l := LazyArray className: #FloatArray.	self assert: l privArray isNil.	a := #(1 2 3) asFloatArray.	b := #(4 5 6) asFloatArray.	l privArray: a.	self assertCollection: l privArray equals: a.	l setArray: b.	self assertCollection: l privArray equals: b.	self should: [l setArray: #(4 5 6)] raise: Error.! !!LazyArrayTest methodsFor: 'test' stamp: 'EiichiroIto 9/21/2019 17:57'!testSize	| l a |	l := LazyArray basicNew.	self assert: l size equals: 0.	a := FloatArray new: 5.	a at: 2 put: 3.	a at: 5 put: 9.	l privArray: a.	self assert: l size equals: 5.! !!ObjStreamTest methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 16:12'!equalityTest: inObj	"For testing. Serialize and deserialize the given object and compare the result for equality with the original object."	| outObj |	outObj := self serializeAndDeserialize: inObj.	outObj class == inObj class		ifFalse: [ self error: 'output class is not equal to input class' ].	outObj = inObj		ifFalse: [ self error: 'output is not equal to input' ]! !!ObjStreamTest methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 16:13'!formEqualityTest: inForm	"For testing. Serialize and deserialize the given form and compare the result for equality with the original."	| outForm |	outForm := self serializeAndDeserialize: inForm.	outForm class == inForm class		ifFalse: [ self error: 'output class is not equal to input class' ].	outForm extent = inForm extent & (outForm depth = inForm depth)		& (outForm bits = inForm bits) & (outForm offset = inForm offset)		ifFalse: [ self error: 'output Form is not equal to input Form' ].	(inForm isKindOf: ColorForm)		ifTrue: [ inForm colors = outForm colors				ifFalse: [ self error: 'output colors are not equal to input colors' ] ]! !!ObjStreamTest methodsFor: 'instance creation' stamp: 'EiichiroIto 11/23/2019 16:09'!newObjStream	^ ObjStream new! !!ObjStreamTest methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 16:12'!serializeAndDeserialize: anObject	"For testing. Serialize and de-serialize the given object and answer the result."	| stream |	stream := WriteStream on: ByteArray new.	self newObjStream storeObj: anObject on: stream showProgress: false.	^ self newObjStream readObjFrom: (ReadStream on: stream contents)! !!ObjStreamTest methodsFor: 'tests' stamp: 'EiichiroIto 11/23/2019 16:14'!testFixedFormatClasses	| shared |	self equalityTest: #().	self equalityTest: #(1 2 3).	self equalityTest: (Array with: nil with: true with: false).	self equalityTest: #(123 -123 123456 -123456 1234567890 -1234567890 3.14159).	self equalityTest: 'hello'.	self equalityTest: 'hello' asSymbol.	self equalityTest: #(1 2 3) asByteArray.	"self equalityTest: (UTF8 withAll: 'hello')."	"self equalityTest: (SoundBuffer fromArray: #(1 2 3 4))."	self equalityTest: (Bitmap withAll: #(0 1 2 2147483647 2147483648 4294967295)).	self equalityTest: #(1 2 3) asOrderedCollection.	self equalityTest: #(1 2 3) asSet.	self equalityTest: (IdentitySet new addAll: #(1 2 3); yourself).	self equalityTest: (Dictionary new at: 1 put: 'a'; at: 'b' put: 2; yourself).	"self equalityTest: (IdentityDictionary new at: 1 put: 'a'; at: 'b' put: 2; yourself)."	self equalityTest: (Color gray: 0.3).	self equalityTest: (Color red alpha: 0.5).	self equalityTest: 2 @ 3.14159.	self equalityTest: (0@0 extent: 2.5 @ 2.5).	self formEqualityTest: (Form fromDisplay: (0@0 extent: 10@10)).	"self formEqualityTest: ((Form fromDisplay: (0@0 extent: 10@10)) colorReduced)."	shared := #Shared.	self equalityTest: (Point x: shared y: shared).	"self equalityTest: ((Point x: shared y: shared) corner: (Point x: shared y: shared))."	self equalityTest: (OrderedCollection with: shared with: shared).	self equalityTest: (Array with: shared with: (Set new add: shared; yourself)).	self equalityTest: (Dictionary new at: shared put: shared; at: 'b' put: shared; yourself).	"self equalityTest: (IdentityDictionary new at: shared put: shared; at: 'b' put: shared; yourself)."	self inform: 'Fixed-format tests passed.'.! !!ObjStreamTest methodsFor: 'tests' stamp: 'EiichiroIto 11/23/2019 16:48'!testUserClasses	"Test conversions for fixed-format objects."	| userClassList suspectClasses |	userClassList := self newObjStream class userClasses		collect: [ :rec | Smalltalk at: rec second ].	userClassList := userClassList		reject: [ :cl | (cl inheritsFrom: BlockMorph) | (cl inheritsFrom: ArgMorph) ].	userClassList do: [ :cl | self serializeAndDeserialize: cl new ].	suspectClasses := userClassList		select: [ :cl | 			(cl includesSelector: #fieldsVersion) not				and: [ cl instVarNames notEmpty ] ].	self assert: suspectClasses isEmpty! !!ObjStreamTest methodsFor: 'tests' stamp: 'EiichiroIto 11/23/2019 16:35'!testWriteFile	| all objects s file |	all := OrderedCollection new.	all add: true.	all add: false.	all add: 12345.	all add: 123.	all add: 1234567891.	all add: -1234567891.	all add: 123.546.	all add: 'This is a string.'.	all add: #thisIsASymbol.	all add: #(100 101 102 253 254 255) asByteArray.	"all add: ScriptableScratchMorph popSound samples."	all add: (ImageMorph defaultForm asFormOfDepth: 32) bits.	all add: (Array with: 1 with: 2 with: 3).	all add: (Array with: 1 with: 2 with: 3) asOrderedCollection.	all add: (Array with: 1 with: 2 with: 3) asSet.	all add: (IdentitySet withAll: (Array with: 1 with: 2 with: 3)).	all add: (Dictionary new at: 'John' put: 'Maloney'; at: 'Lise' put: 'Kreps'; yourself).	all add: (IdentityDictionary new at: #John put: 'Maloney'; at: #Lise put: 'Kreps'; yourself).	all add: (Color gray: 0.5).	all add: (Color red alpha: 0.5).	all add: 1@2.0.	all add: (9.5@20 extent: 30@40).	all add: (ImageMorph defaultForm asFormOfDepth: 32).	all add: ImageMorph defaultForm.	objects := (Array with: nil), all asArray.	file := 'test.obj' asFileReference.	file isFile ifTrue: [ file delete ].	s := file binaryWriteStream.	self newObjStream storeObj: objects on: s.	s close.! !!ScratchBaseProcessTest methodsFor: 'private' stamp: 'EiichiroIto 10/25/2019 11:55'!newProcess	^ ScratchBaseProcess new! !!ScratchBaseProcessTest methodsFor: 'test' stamp: 'EiichiroIto 11/24/2019 20:34'!testProgram	| pr |	pr := self newProcess.	self assert: pr program isNil.	pr program: 123.	self assert: pr program equals: 123.! !!ScratchBytecodeCallTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:32'!newCall: aString	^ ScratchBytecodeCall subName: aString! !!ScratchBytecodeCallTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:32'!newCall: aString address: anInteger	^ ScratchBytecodeCall subName: aString address: anInteger! !!ScratchBytecodeCallTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:20'!testAddress	| c |	c := self newCall: 'abc'.	self assert: c address isNil.	c address: 123.	self assert: c address equals: 123.	c address: 456.	self assert: c address equals: 456.! !!ScratchBytecodeCallTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:20'!testCodeSize	| c |	c := self newCall: 'abc'.	self assert: c codeSize equals: 4.! !!ScratchBytecodeCallTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:20'!testIsCall	| c |	c := self newCall: 'abc'.	self assert: c isCall.! !!ScratchBytecodeCallTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:20'!testPrintOn	| c |	c := self newCall: 'abc'.	self assert: c asString equals: '<call=abc,to=nil>'.	c address: 2.	self assert: c asString equals: '<call=abc,to=2>'.! !!ScratchBytecodeCallTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:20'!testPutOn	| c stream |	stream := WriteStream on: Array new.	c := self newCall: 'abc'.	self should: [ c putOn: stream ] raise: Error.	c address: 123.	c putOn: stream.	self assertCollection: stream contents equals: #(pushShort 123 0 call).! !!ScratchBytecodeCallTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:20'!testSubName	| c |	c := self newCall: 'abc'.	self assert: c subName equals: 'abc'.	c subName: 'def'.	self assert: c subName equals: 'def'.	c subName: 'ghi'.	self assert: c subName equals: 'ghi'.! !!ScratchBytecodeCallTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:21'!testSubNameAddress	| c |	c := self newCall: 'abc' address: 123.	self assert: c subName equals: 'abc'.	self assert: c address equals: 123.	c := self newCall: 'def' address: 456.	self assert: c subName equals: 'def'.	self assert: c address equals: 456.! !!ScratchBytecodeGeneratorTest methodsFor: 'private' stamp: 'EiichiroIto 10/20/2019 21:32'!newGenerator	^ ScratchBytecodeGenerator new! !!ScratchBytecodeGeneratorTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 12:28'!newThread	^ ScratchNativeThread new! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:33'!testAddress	| b |	b := self newGenerator.	self assert: b address equals: 1.	b address: 100.	self assert: b address equals: 100.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:34'!testAddressOfSubName	| b d |	b := self newGenerator.	self should: [ b addressOfSubName: 'abc' ] raise: Error.	d := Dictionary new.	b subTable: d.	self should: [ b addressOfSubName: 'abc' ] raise: Error.	d at: 'abc' put: 123.	d at: 'def' put: 456.	self assert: (b addressOfSubName: 'abc') equals: 123.	self assert: (b addressOfSubName: 'def') equals: 456.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:35'!testAndWith	| t b r |	b := self newGenerator.	r := b and: true with: true.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b and: true with: false.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b and: false with: true.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b and: false with: false.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:32'!testAppendCall	| b r |	b := self newGenerator.	b subTable: { 'def'->123 } asDictionary.	self assert: b privStream contents isEmpty.	b appendCall: 'def'.	self assert: b privStream contents size equals: 1.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeCall.	self assert: r subName equals: 'def'.	self assert: r address equals: 123.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:33'!testAppendLabel	| b r |	b := self newGenerator.	self assert: b privStream contents isEmpty.	b appendLabel: 123.	b appendLabel: 456.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeLabel.	self assert: r id equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeLabel.	self assert: r id equals: 456.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:33'!testAppendSymbol	| b r |	b := self newGenerator.	self assert: b privStream contents isEmpty.	b appendSymbol: #abc.	b appendSymbol: #def.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #def.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:33'!testAppendSymbolWithJump	| b r |	b := self newGenerator.	self assert: b privStream contents isEmpty.	b appendSymbol: #abc withJump: 12.	b appendSymbol: #def withJump: 34.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeSymbolWithJump.	self assert: r selector equals: #abc.	self assert: r labelId equals: 12.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeSymbolWithJump.	self assert: r selector equals: #def.	self assert: r labelId equals: 34.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:33'!testAppendValue	| b r |	b := self newGenerator.	self assert: b privStream contents isEmpty.	b appendValue: 123.	b appendValue: 456.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 456.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:33'!testBinaryCommandArg1Arg2	| b r |	b := self newGenerator.	self assert: b privStream contents isEmpty.	b binaryCommand: #abc arg1: 123 arg2: 456.	self assert: b privStream contents size equals: 3.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 456.	r := b privStream contents third.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:37'!testCallSub	| b r |	b := self newGenerator.	b subTable: { 'abc'->9. 'def'->3 } asDictionary.	b return: 1.	b callSub: 'def'.	b address: 5.	r := b code.	self assertCollection: r equals: #(push1 return pushShort 3 0 call stop).! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/21/2019 14:01'!testCode	| b arr |	b := self newGenerator.	b plus: 1 and: 2.	b minus: 3 with: 5.	arr := b code.	self		assertCollection: arr		equals: #(push1 pushShort 2 0 plus pushShort 3 0 pushShort 5 0 minus stop)! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:39'!testComputeFunctionOf	| t b r |	b := self newGenerator.	r := b computeFunction: #abs of: -1.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b computeFunction: #abs of: 10.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := self newGenerator.	r := b computeFunction: #sqrt of: 2.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 2 sqrt.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:42'!testDivideBy	| t b r |	b := self newGenerator.	r := b divide: 100 by: 2.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 50.	b := self newGenerator.	r := b divide: 12 by: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 4.	b := self newGenerator.	r := b divide: 10 by: -2.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: -5.	b := self newGenerator.	r := b divide: 1 by: 5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.2.	b := self newGenerator.	r := b divide: 2 by: -4.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: -0.5.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:16'!testDoIfBegin	| b t i r |	b := self newGenerator.	b appendValue: 1.	b appendValue: false.	i := b doIfBegin: nil.	b appendValue: 1.	b appendSymbol: #plus.	b doIfEnd: i.	t := self newThread.	t codes: b code.	r := t evaluate: 1.	self assert: r equals: 1.	b := self newGenerator.	b appendValue: 1.	b appendValue: true.	i := b doIfBegin: nil.	b appendValue: 1.	b appendSymbol: #plus.	b doIfEnd: i.	t := self newThread.	t codes: b code.	r := t evaluate: 1.	self assert: r equals: 2.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:17'!testDoIfElse	| r b t i |	b := self newGenerator.	b appendValue: 1.	b appendValue: false.	i := b doIfBegin: nil.	b appendValue: 1.	b appendSymbol: #plus.	i := b doIfElse: i.	b appendValue: 2.	b appendSymbol: #plus.	b doIfEnd: i.	t := self newThread.	t codes: b code.	r := t evaluate: 1.	self assert: r equals: 3.	b := self newGenerator.	b appendValue: 1.	b appendValue: true.	i := b doIfBegin: nil.	b appendValue: 1.	b appendSymbol: #plus.	i := b doIfElse: i.	b appendValue: 2.	b appendSymbol: #plus.	b doIfEnd: i.	t := self newThread.	t codes: b code.	r := t evaluate: 1.	self assert: r equals: 2.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:32'!testDoIfEnd	self testDoIfBegin.	self testDoIfElse.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:31'!testDoRepeatBegin	| b t arr |	b := self newGenerator.	b appendValue: false.	arr := b doRepeatBegin: 5.	b doRepeatEndLabels: arr.	t := self newThread.	t codes: b code.	t execute: 1.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:32'!testDoRepeatEndLabels	self testDoRepeatBegin.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 13:32'!testDoUntilBegin	| b t i |	b := self newGenerator.	i := b doUntilBegin.	b appendValue: true.	b doUntilEnd: nil id: i.	t := self newThread.	t codes: b code.	t execute: 1.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:32'!testDoUntilEndId	self testDoUntilBegin.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:43'!testEqualTo	| t b r |	b := self newGenerator.	r := b equal: 12 to: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b equal: 10 to: -3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b equal: 5 to: 5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b equal: -2.5 to: -2.5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 12:22'!testGetId	| g |	g := self newGenerator.	g getId.	self assertCollection: g code equals: { #getId . #stop }.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:32'!testInitialize	self testPrivLabelId.	self testPrivStream.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:46'!testIsBetweenAnd	| t b r |	b := self newGenerator.	r := b is: 10 between: 3 and: 12.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b is: 10 between: 10 and: 12.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b is: 12 between: 10 and: 12.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b is: 9 between: 10 and: 12.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b is: 13 between: 10 and: 12.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:47'!testLabelsAndJumpsFor	| b arr |	b := self newGenerator.	b appendLabel: b privLabelId newNo.	b appendValue: 1.	b appendValue: 2.	b appendLabel: b privLabelId newNo.	b appendSymbol: #a.	b appendLabel: b privLabelId newNo.	b appendValue: 2.	b appendSymbol: #a withJump: 1.	arr := b labelsAndJumpsFor: b privStream contents.	self assertCollection: arr first equals: #(1 5 6).	self assert: arr second size equals: 1.	self assert: arr second first selector equals: #a.	self assert: b address equals: 13.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:47'!testLessEqualThan	| t b r |	b := self newGenerator.	r := b lessEqual: 12 than: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b lessEqual: -10 than: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b lessEqual: 5 than: 5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b lessEqual: -2.5 than: -2.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:48'!testLessThan	| t b r |	b := self newGenerator.	r := b less: 12 than: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b less: -10 than: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b less: 5 than: 5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b less: -2.5 than: -2.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:49'!testMinusWith	| t b r |	b := self newGenerator.	r := b minus: 12 with: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 9.	b := self newGenerator.	r := b minus: 10 with: -3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 13.	b := self newGenerator.	r := b minus: 1.5 with: 5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: -3.5.	b := self newGenerator.	r := b minus: -2 with: -4.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 2.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:49'!testModBy	| t b r |	b := self newGenerator.	r := b mod: 12 by: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b mod: 10 by: -3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: -2.	b := self newGenerator.	r := b mod: 1 by: 5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b mod: -2 by: 4.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 2.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:50'!testMultiplyAnd	| t b r |	b := self newGenerator.	r := b multiply: 12 and: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 36.	b := self newGenerator.	r := b multiply: 10 and: -3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: -30.	b := self newGenerator.	r := b multiply: 1.5 and: 5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 7.5.	b := self newGenerator.	r := b multiply: -2 and: -4.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 8.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:51'!testNot	| t b r |	b := self newGenerator.	r := b not: true.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := self newGenerator.	r := b not: false.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:33'!testNullaryCommand	| b r |	b := self newGenerator.	self assert: b privStream contents isEmpty.	b nullaryCommand: #abc.	self assert: b privStream contents size equals: 1.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:52'!testOrWith	| t b r |	b := self newGenerator.	r := b or: true with: true.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b or: true with: false.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b or: false with: true.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := self newGenerator.	r := b or: false with: false.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:53'!testPlusAnd	| t b r |	b := self newGenerator.	r := b plus: 12 and: 3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 15.	b := self newGenerator.	r := b plus: 10 and: -3.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 7.	b := self newGenerator.	r := b plus: 1.5 and: 5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 6.5.	b := self newGenerator.	r := b plus: -2 and: -4.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: -6.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:53'!testPrivLabelId	| b |	b := self newGenerator.	self assert: b privLabelId class equals: BaseId.	self assert: b privLabelId size equals: 0.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:53'!testPrivStream	| b |	b := self newGenerator.	self assert: b privStream isStream.	self assert: b privStream contents isArray.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:53'!testRandomFromTo	| t b r |	b := self newGenerator.	10		timesRepeat: [ r := b randomFrom: 1 to: 10.			self assert: r isNil.			t := self newThread.			t codes: b code.			self assert: ((t evaluate: 1) between: 1 and: 10) ].! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:54'!testResolveJumpAddressUsing	| b fp arr |	b := self newGenerator.	b appendLabel: b privLabelId newNo.	b appendValue: 1.	b appendValue: 2.	b appendSymbol: #a withJump: 3.	b appendLabel: b privLabelId newNo.	b appendSymbol: #b.	b appendLabel: b privLabelId newNo.	b appendValue: 2.	b appendSymbol: #c withJump: 2.	fp := b privStream contents.	self assert: (fp at: 4) address equals: nil.	self assert: (fp at: 9) address equals: nil.	arr := b labelsAndJumpsFor: fp.	b resolveJumpAddress: arr second using: arr first.	self assert: (fp at: 4) address equals: 10.	self assert: (fp at: 9) address equals: 9.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:32'!testReturn	self testCallSub.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:54'!testReturnValue	| b r |	b := self newGenerator.	b returnValue.	b address: 5.	r := b code.	self assertCollection: r equals: #(returnValue stop).! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:55'!testRounded	| t b r |	b := self newGenerator.	r := b rounded: 10.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := self newGenerator.	r := b rounded: 10.2.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := self newGenerator.	r := b rounded: 10.5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 11.	b := self newGenerator.	r := b rounded: -10.5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: -11.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 12:25'!testStopAll	| g |	g := self newGenerator.	g stopAll.	self assertCollection: g code equals: { #stopAll . #stop }! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 12:26'!testStopThread	| g |	g := self newGenerator.	g stopThread.	self assertCollection: g code equals: { #stop . #stop }! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:33'!testSubTable	| b d |	b := self newGenerator.	self assert: b subTable isNil.	d := Dictionary new.	b subTable: d.	self assert: b subTable equals: d.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:33'!testTernaryCommandArg1Arg2Arg3	| b r |	b := self newGenerator.	self assert: b privStream contents isEmpty.	b ternaryCommand: #abc arg1: 123 arg2: 456 arg3: 789.	self assert: b privStream contents size equals: 4.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 456.	r := b privStream contents third.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 789.	r := b privStream contents fourth.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/20/2019 21:57'!testTruncated	| t b r |	b := self newGenerator.	r := b truncated: 10.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := self newGenerator.	r := b truncated: 10.2.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := self newGenerator.	r := b truncated: 10.5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := self newGenerator.	r := b truncated: -10.5.	self assert: r isNil.	t := self newThread.	t codes: b code.	self assert: (t evaluate: 1) equals: -10.! !!ScratchBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:33'!testUnaryCommandArg	| b r |	b := self newGenerator.	self assert: b privStream contents isEmpty.	b unaryCommand: #abc arg: 123.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.! !!ScratchBytecodeLabelTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:33'!newLabel: anInteger	^ ScratchBytecodeLabel id: anInteger! !!ScratchBytecodeLabelTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:22'!testCodeSize	| c |	c := self newLabel: 1.	self assert: c codeSize equals: 0.! !!ScratchBytecodeLabelTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:22'!testId	| c |	c := self newLabel: 1.	self assert: c id equals: 1.	c id: 20.	self assert: c id equals: 20.! !!ScratchBytecodeLabelTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:22'!testIsLabel	| c |	c := self newLabel: 1.	self assert: c isLabel.! !!ScratchBytecodeLabelTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:22'!testPrintOn	| c |	c := self newLabel: 1.	self assert: c asString equals: '<label=1>'.! !!ScratchBytecodeLabelTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:23'!testPutOn	| c stream |	c := self newLabel: 1.	stream := WriteStream on: Array new.	c putOn: stream.	self assert: stream contents isEmpty.! !!ScratchBytecodeSymbolTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:35'!newSymbol: aSymbol	^ ScratchBytecodeSymbol selector: aSymbol! !!ScratchBytecodeSymbolTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:36'!testPrintOn	| c |	c := self newSymbol: #abc.	self assert: c asString equals: '<symbol=abc>'.! !!ScratchBytecodeSymbolTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:35'!testPutOn	| c stream |	c := self newSymbol: #abc.	stream := WriteStream on: Array new.	c putOn: stream.	self assertCollection: stream contents equals: #(abc).! !!ScratchBytecodeSymbolTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:35'!testSelector	| c |	c := self newSymbol: #abc.	self assert: c selector equals: #abc.	c selector: #def.	self assert: c selector equals: #def.! !!ScratchBytecodeSymbolWithJumpTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:36'!newSymbol: aSymbol label: anInteger	^ ScratchBytecodeSymbolWithJump selector: aSymbol labelId: anInteger! !!ScratchBytecodeSymbolWithJumpTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:37'!testAddress	| c |	c := self newSymbol: #abc label: 1.	self assert: c address isNil.	c address: 123.	self assert: c address equals: 123.! !!ScratchBytecodeSymbolWithJumpTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:37'!testCodeSize	| c |	c := self newSymbol: #abc label: 1.	self assert: c codeSize equals: 4.! !!ScratchBytecodeSymbolWithJumpTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:37'!testIsJump	| c |	c := self newSymbol: #abc label: 1.	self assert: c isJump.! !!ScratchBytecodeSymbolWithJumpTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:37'!testLabelId	| c |	c := self newSymbol: #abc label: 1.	self assert: c labelId equals: 1.	c labelId: 123.	self assert: c labelId equals: 123.! !!ScratchBytecodeSymbolWithJumpTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:37'!testPrintOn	| c |	c := self newSymbol: #abc label: 1.	self assert: c asString equals: '<symbol=abc,id=1,jump=nil>'.	c address: 2.	self assert: c asString equals: '<symbol=abc,id=1,jump=2>'.! !!ScratchBytecodeSymbolWithJumpTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:37'!testPutOn	| c stream |	stream := WriteStream on: Array new.	c := self newSymbol: #abc label: 1.	self should: [ c putOn: stream ] raise: Error.	c address: 123.	c putOn: stream.	self assertCollection: stream contents equals: #(pushShort 123 0 abc).! !!ScratchBytecodeTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:38'!newBytecode	^ ScratchBytecode basicNew! !!ScratchBytecodeTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:38'!testCodeSize	| c |	c := self newBytecode.	self assert: c codeSize equals: 1.! !!ScratchBytecodeTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:32'!testIsCall	| c |	c := ScratchBytecode basicNew.	self deny: c isCall.! !!ScratchBytecodeTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:45'!testIsJump	| c |	c := self newBytecode.	self deny: c isJump.! !!ScratchBytecodeTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:45'!testIsLabel	| c |	c := self newBytecode.	self deny: c isLabel.! !!ScratchBytecodeTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:45'!testPutOn	| c stream |	c := self newBytecode.	stream := WriteStream on: Array new.	c putOn: stream.	self assert: stream contents isEmpty.! !!ScratchBytecodeTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:32'!testPutShortOn	| c stream |	c := ScratchBytecode basicNew.	stream := WriteStream on: Array new.	c putShort: 123 on: stream.	self assertCollection: stream contents equals: #(pushShort 123 0).	c := ScratchBytecode basicNew.	stream := WriteStream on: Array new.	c putShort: -123 on: stream.	self		assertCollection: stream contents		equals: #(pushShort 16r85 16rFF)! !!ScratchBytecodeValueTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 14:46'!newValue: aNumber	^ ScratchBytecodeValue data: aNumber! !!ScratchBytecodeValueTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:47'!testCodeSize	| c |	c := self newValue: 0.	self assert: c codeSize equals: 1.	c := self newValue: 1.	self assert: c codeSize equals: 1.	c := self newValue: 2.	self assert: c codeSize equals: 3.	c := self newValue: 32767.	self assert: c codeSize equals: 3.	c := self newValue: -32768.	self assert: c codeSize equals: 3.	c := self newValue: 32768.	self assert: c codeSize equals: 5.	c := self newValue: -32769.	self assert: c codeSize equals: 5.	c := self newValue: 1.1.	self assert: c codeSize equals: 5.! !!ScratchBytecodeValueTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:47'!testData	| c |	c := self newValue: 1.	self assert: c data equals: 1.	c data: 2.	self assert: c data equals: 2.! !!ScratchBytecodeValueTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:48'!testPrintOn	| c |	c := self newValue: 123.	self assert: c asString equals: '<value=123>'.! !!ScratchBytecodeValueTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:47'!testPutFloatOn	| c stream |	c := self newValue: 123.0.	stream := WriteStream on: Array new.	c putFloatOn: stream.	self		assertCollection: stream contents		equals: #(pushFloat 16r00 16r00 16rF6 16r42).	c := self newValue: -5.3.	stream := WriteStream on: Array new.	c putFloatOn: stream.	self		assertCollection: stream contents		equals: #(pushFloat 16r9A 16r99 16rA9 16rC0)! !!ScratchBytecodeValueTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:48'!testPutOn	| c stream |	c := self newValue: 0.	stream := WriteStream on: Array new.	c putOn: stream.	self assertCollection: stream contents equals: #(push0).	c := self newValue: 1.	stream := WriteStream on: Array new.	c putOn: stream.	self assertCollection: stream contents equals: #(push1).	c := self newValue: 2.	stream := WriteStream on: Array new.	c putOn: stream.	self assertCollection: stream contents equals: #(pushShort 2 0).	c := self newValue: 123.	stream := WriteStream on: Array new.	c putOn: stream.	self assertCollection: stream contents equals: #(pushShort 123 0).	c := self newValue: -2.	stream := WriteStream on: Array new.	c putOn: stream.	self		assertCollection: stream contents		equals: #(pushShort 16rFE 16rFF).	c := self newValue: 123.0.	stream := WriteStream on: Array new.	c putOn: stream.	self		assertCollection: stream contents		equals: #(pushFloat 16r00 16r00 16rF6 16r42).	c := self newValue: -5.3.	stream := WriteStream on: Array new.	c putOn: stream.	self		assertCollection: stream contents		equals: #(pushFloat 16r9A 16r99 16rA9 16rC0)! !!ScratchBytecodeValueTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 14:48'!testPutShortOn	| c stream |	c := self newValue: 123.	stream := WriteStream on: Array new.	c putShortOn: stream.	self assertCollection: stream contents equals: #(pushShort 123 0).	c := self newValue: -123.	stream := WriteStream on: Array new.	c putShortOn: stream.	self		assertCollection: stream contents		equals: #(pushShort 16r85 16rFF)! !!ScratchDirectoryTest methodsFor: 'private' stamp: 'EiichiroIto 11/27/2019 20:30'!newDirectory	^ ScratchDirectory new! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:31'!testAppName	| d |	d := self newDirectory.	self assert: d appName isNil.	d appName: 'abc'.	self assert: d appName equals: 'abc'! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:32'!testComputer	| d |	d := self newDirectory.	self assert: (d computer isKindOf: FileReference).	self assert: d computer isDirectory! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:32'!testDesktop	| d |	d := self newDirectory.	self assert: (d desktop isKindOf: FileReference).	self assert: d desktop isDirectory! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:32'!testExamples	| d |	d := self newDirectory.	self assert: (d examples isKindOf: FileReference).	self assert: d examples isDirectory! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:56'!testGetDefaultFolderForType	| d |	d := self newDirectory.	self assert: (d getDefaultFolderForType: #project) equals: d project.	self assert: (d getDefaultFolderForType: #export) equals: d project.	self assert: (d getDefaultFolderForType: #test) equals: d user! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:37'!testGetLastFolderForType	| d x |	d := self newDirectory.	self assert: (d getLastFolderForType: #projects) equals: d user.	self assert: (d getLastFolderForType: #user) equals: d user.	x := FileSystem workingDirectory.	d setLastFolderTo: x forType: #projects.	self assert: (d getLastFolderForType: #projects) equals: x.	self assert: (d getLastFolderForType: #user) equals: d user.! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:38'!testInitialize	| d |	d := self newDirectory.	self assert: d appName isNil.	self assert: d privLastDirectories isDictionary.	self assert: d privLastDirectories isEmpty.	self assert: d privHomeDirectory isNil! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:54'!testLastFolderIsSampleProjectsFolder	| d |	d := self newDirectory.	d		setLastFolderTo: FileLocator documents asFileReference		forType: #project.	self deny: d lastFolderIsSampleProjectsFolder.	d setLastFolderTo: d examples / 'a' forType: #project.	self assert: d lastFolderIsSampleProjectsFolder! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:41'!testPrivHomeDirectory	| d x |	d := self newDirectory.	self assert: d privHomeDirectory isNil.	x := FileSystem workingDirectory.	d privHomeDirectory: x.	self assert: d privHomeDirectory equals: x! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:42'!testPrivLastDirectories	| d |	d := self newDirectory.	self assert: d privLastDirectories isDictionary.	self assert: d privLastDirectories isEmpty! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:55'!testProject	| d x y |	d := self newDirectory.	x := FileSystem workingDirectory.	self assert: d project equals: x.	x := FileLocator documents asFileReference.	(x / '_xx_') isDirectory		ifTrue: [ (x / '_xx_') delete ].	d appName: '_xx_'.	y := d project.	self assert: y pathString equals: (x / '_xx_') pathString.	self assert: (x / '_xx_') isDirectory.	(x / '_xx_') delete! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:55'!testProjectFor	| d x y |	d := self newDirectory.	x := FileSystem workingDirectory.	self assert: (d projectFor: nil) equals: x.	x := FileLocator documents asFileReference.	(x / '_xx_') isDirectory		ifTrue: [ (x / '_xx_') delete ].	y := d projectFor: '_xx_'.	self assert: y pathString equals: (x / '_xx_') pathString.	self assert: (x / '_xx_') isDirectory.	(x / '_xx_') delete! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:45'!testSetHomeDir	self testUser! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:43'!testSetLastFolderToForType	self testGetLastFolderForType! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 20:45'!testUser	| d u x |	d := self newDirectory.	u := d user.	self assert: u isDirectory.	x := FileSystem workingDirectory.	d setHomeDir: x.	self assert: d user equals: x.! !!ScratchExporterTest methodsFor: 'private' stamp: 'EiichiroIto 10/25/2019 12:20'!newExporter	^ ScratchExporter new! !!ScratchExporterTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 20:43'!testPrivStream	| e s |	e := self newExporter.	self assert: e privStream isNil.	s := WriteStream on: ''.	e privStream: s.	self assert: e privStream equals: s.! !!ScratchNativeThreadTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 09:15'!newThread	^ ScratchNativeThread new! !!ScratchNativeThreadTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 09:17'!sampleCode1	^ OrderedCollection new		add: #push1;		add: #pushShort;		add: 2;		add: 0;		add: #plus;		add: #pushShort;		add: 3;		add: 0;		add: #mul;		add: #stop;		yourself! !!ScratchNativeThreadTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 09:03'!sampleCode2	^ #(pushShort 1 0 pushShort 2 0 plus return pushShort 1 0 call returnValue dup mul stop)! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testAbs	| t |	t := self newThread.	t push: 10.	self assert: t stack size equals: 1.	t abs.	self assert: t stack size equals: 1.	self assert: t pop equals: 10.	t push: -20.	self assert: t stack size equals: 1.	t abs.	self assert: t stack size equals: 1.	self assert: t pop equals: 20.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testAcos	| t |	t := self newThread.	t push: 0.5.	self assert: t stack size equals: 1.	t acos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 60.	t push: -10.	self assert: t stack size equals: 1.	t acos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 180.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testAnd	| t |	t := self newThread.	t push: false.	t push: false.	self assert: t stack size equals: 2.	t and.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: false.	t push: true.	self assert: t stack size equals: 2.	t and.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: true.	t push: false.	self assert: t stack size equals: 2.	t and.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: true.	t push: true.	self assert: t stack size equals: 2.	t and.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testAsin	| t |	t := self newThread.	t push: 0.5.	self assert: t stack size equals: 1.	t asin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 30.	t push: -10.	self assert: t stack size equals: 1.	t asin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -90.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testAtan	| t |	t := self newThread.	t push: 1.	self assert: t stack size equals: 1.	t atan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 45.	t push: -10.	self assert: t stack size equals: 1.	t atan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -45.! !!ScratchNativeThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testCall	| e |	e := self newThread.	e pc: 20.	e push: 10.	e call.	self assert: e pc equals: 10.	self assert: e stack size equals: 1.	self assert: e pop equals: 20.! !!ScratchNativeThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/22/2019 09:03'!testCodes	| t |	t := self newThread.	self assert: t codes isNil.	t codes: #(1 2 3).	self assertCollection: t codes equals: #(1 2 3).! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testCos	| t |	t := self newThread.	t push: 0.	self assert: t stack size equals: 1.	t cos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1.	t push: 90.	self assert: t stack size equals: 1.	t cos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 180.	self assert: t stack size equals: 1.	t cos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -1.	t push: 270.	self assert: t stack size equals: 1.	t cos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testDec	| t |	t := self newThread.	t push: 10.	self assert: t stack first equals: 10.	t dec.	self assert: t stack first equals: 9.	t dec.	self assert: t stack first equals: 8.! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:15'!testDirection	| t |	t := self newThread.	t push: 0.	t push: 0.	t direction.	self assert: t pop equals: 90.	t push: 1.	t push: 1.	t direction.	self assert: t pop equals: 45.	t push: 0.	t push: 1.	t direction.	self assert: t pop equals: 90.	t push: 0.	t push: -1.	t direction.	self assert: t pop equals: -90.	t push: -1.	t push: 1.	t direction.	self assert: t pop equals: 135.	t push: -1.	t push: -1.	t direction.	self assert: t pop equals: 225.	t push: 1.	t push: -1.	t direction.	self assert: t pop equals: 360 - 45.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testDiv	| t |	t := self newThread.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t div.	self assert: t stack size equals: 1.	self assert: t pop equals: 2.	t push: 5.	t push: -10.	self assert: t stack size equals: 2.	t div.	self assert: t stack size equals: 1.	self assert: t pop equals: -0.5.	self deny: t isTerminated.	t push: 5.	t push: 0.	t div.	self assert: t isTerminated.! !!ScratchNativeThreadTest methodsFor: 'tests-execution' stamp: 'EiichiroIto 10/22/2019 09:18'!testDoOneCycle	| e c |	c := self sampleCode1.	e := self newThread.	e codes: c.	self assert: e pc equals: 1.	self assert: e stack isEmpty.	self assert: e doOneCycle not.	self assert: e pc equals: c size + 1.	self assert: e stack size equals: 1.	self assert: e stack first equals: 9.! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testDrop	| t |	t := self newThread.	self assert: t stack size equals: 0.	t push: 10.	self assert: t stack size equals: 1.	t drop.	self assert: t stack size equals: 0.! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testDup	| t |	t := self newThread.	self assert: t stack size equals: 0.	t push: 10.	self assert: t stack size equals: 1.	t dup.	self assert: t stack size equals: 2.	self assert: t pop equals: 10.	self assert: t pop equals: 10.	self assert: t stack size equals: 0.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testEqual	| t |	t := self newThread.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t equal.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -10.	t push: -10.	self assert: t stack size equals: 2.	t equal.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!ScratchNativeThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/22/2019 09:03'!testErrorOccuered	| t |	t := self newThread.	self assert: t isTerminated equals: false.	t errorOccuered.	self assert: t isTerminated equals: true.! !!ScratchNativeThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/22/2019 09:19'!testEvaluate	| t c x |	t := self newThread.	c := #(push1 pushShort 2 0 #plus #stop).	t codes: c.	x := t evaluate: 1.	self assert: x equals: 3.! !!ScratchNativeThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/22/2019 09:21'!testExecute	| t c |	t := self newThread.	c := #(push1 pushShort 2 0 #plus #stop).	t codes: c.	t execute: 1.	self assert: t stack size equals: 1.	self assert: t stack first equals: 3.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testExp	| t |	t := self newThread.	t push: 0.	self assert: t stack size equals: 1.	t exp.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1.	t push: 2.	self assert: t stack size equals: 1.	t exp.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 2 exp.	t push: -1.	self assert: t stack size equals: 1.	t exp.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1 / 1 exp.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testExp10	| t |	t := self newThread.	t push: 0.	self assert: t stack size equals: 1.	t exp10.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1.	t push: 2.	self assert: t stack size equals: 1.	t exp10.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 100.	t push: -1.	self assert: t stack size equals: 1.	t exp10.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.1.! !!ScratchNativeThreadTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testGetId	| t |	t := self newThread.	t privId: 10.	self assert: t stack size equals: 0.	t getId.	self assert: t pop equals: 10.! !!ScratchNativeThreadTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 10/22/2019 09:03'!testInitialize	self testPc.	self testStack.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testInv	| t |	t := self newThread.	t push: 0.	t inv.	self assert: t pop equals: 16rFFFF.	t := self newThread.	t push: 16rFFFF.	t inv.	self assert: t pop equals: 0.	t := self newThread.	t push: 16r1234.	t inv.	self assert: t pop equals: 16rEDCB.! !!ScratchNativeThreadTest methodsFor: 'tests-testing' stamp: 'EiichiroIto 10/22/2019 09:03'!testIsRunning	self testPrivIsRunning.! !!ScratchNativeThreadTest methodsFor: 'tests-testing' stamp: 'EiichiroIto 10/22/2019 09:03'!testIsTerminated	self testPrivIsTerminated.! !!ScratchNativeThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testJump	| t |	t := self newThread.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t push: 5.	self assert: t stack size equals: 1.	t jump.	self assert: t pc equals: 5.	self assert: t stack size equals: 0.! !!ScratchNativeThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testJumpIfFalse	| t |	t := self newThread.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t push: true.	t push: 5.	self assert: t stack size equals: 2.	t jumpIfFalse.	self assert: t pc equals: 1.	self assert: t stack size equals: 0.	t push: false.	t push: 5.	self assert: t stack size equals: 2.	t jumpIfFalse.	self assert: t pc equals: 5.	self assert: t stack size equals: 0.! !!ScratchNativeThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testJumpIfTrue	| t |	t := self newThread.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t push: false.	t push: 5.	self assert: t stack size equals: 2.	t jumpIfTrue.	self assert: t pc equals: 1.	self assert: t stack size equals: 0.	t push: true.	t push: 5.	self assert: t stack size equals: 2.	t jumpIfTrue.	self assert: t pc equals: 5.	self assert: t stack size equals: 0.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testLess	| t |	t := self newThread.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t less.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -10.	t push: -10.	self assert: t stack size equals: 2.	t less.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -10.	t push: 10.	self assert: t stack size equals: 2.	t less.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testLessEqual	| t |	t := self newThread.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t lessEqual.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -10.	t push: -10.	self assert: t stack size equals: 2.	t lessEqual.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: -10.	t push: 10.	self assert: t stack size equals: 2.	t lessEqual.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testLn	| t |	t := self newThread.	t push: 1.	self assert: t stack size equals: 1.	t ln.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 2 exp.	self assert: t stack size equals: 1.	t ln.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 2.	t push: 1 / 1 exp.	self assert: t stack size equals: 1.	t ln.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -1.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testLog	| t |	t := self newThread.	t push: 1.	self assert: t stack size equals: 1.	t log.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 100.	self assert: t stack size equals: 1.	t log.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 2.	t push: 0.1.	self assert: t stack size equals: 1.	t log.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -1.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testMinus	| t |	t := self newThread.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t minus.	self assert: t stack size equals: 1.	self assert: t pop equals: 5.	t push: 5.	t push: -10.	self assert: t stack size equals: 2.	t minus.	self assert: t stack size equals: 1.	self assert: t pop equals: 15.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testMod	| t |	t := self newThread.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t mod.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -5.	t push: 10.	self assert: t stack size equals: 2.	t mod.	self assert: t stack size equals: 1.	self assert: t pop equals: 5.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testMul	| t |	t := self newThread.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t mul.	self assert: t stack size equals: 1.	self assert: t pop equals: 50.	t push: 0.5.	t push: -10.	self assert: t stack size equals: 2.	t mul.	self assert: t stack size equals: 1.	self assert: t pop equals: -5.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testNot	| t |	t := self newThread.	t push: false.	self assert: t stack size equals: 1.	t not.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: true.	self assert: t stack size equals: 1.	t not.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testOr	| t |	t := self newThread.	t push: false.	t push: false.	self assert: t stack size equals: 2.	t or.	self assert: t stack size equals: 1.	self assert: t stack first equals: 0.	t pop.	t push: false.	t push: true.	self assert: t stack size equals: 2.	t or.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: true.	t push: false.	self assert: t stack size equals: 2.	t or.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: true.	t push: true.	self assert: t stack size equals: 2.	t or.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!ScratchNativeThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/22/2019 09:03'!testPc	| e |	e := self newThread.	self assert: e pc equals: 1.	e pc: 10.	self assert: e pc equals: 10.	e pc: 20.	self assert: e pc equals: 20.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testPlus	| t |	t := self newThread.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t plus.	self assert: t stack size equals: 1.	self assert: t pop equals: 15.	t push: 5.	t push: -10.	self assert: t stack size equals: 2.	t plus.	self assert: t stack size equals: 1.	self assert: t pop equals: -5.! !!ScratchNativeThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/22/2019 09:03'!testPop	| e |	e := self newThread.	e push: 10.	e push: 20.	self assertCollection: e stack asArray equals: #(10 20).	self assert: e pop equals: 20.	self assert: e pop equals: 10.	self assert: e stack isEmpty.! !!ScratchNativeThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/22/2019 09:03'!testPrivId	| e |	e := self newThread.	self assert: e privId isNil.	e privId: 10.	self assert: e privId equals: 10.	e privId: 20.	self assert: e privId equals: 20.! !!ScratchNativeThreadTest methodsFor: 'tests-testing' stamp: 'EiichiroIto 10/22/2019 09:03'!testPrivIsRunning	| t |	t := self newThread.	self assert: t isRunning equals: false.	t privIsRunning: true.	self assert: t isRunning equals: true.	t privIsRunning: false.	self assert: t isRunning equals: false.! !!ScratchNativeThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/22/2019 09:03'!testPrivIsTerminated	| t |	t := self newThread.	self assert: t isTerminated equals: false.	t privIsTerminated: true.	self assert: t isTerminated equals: true.	t privIsTerminated: false.	self assert: t isTerminated equals: false.! !!ScratchNativeThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/22/2019 09:03'!testPrivRetVal	| t |	t := self newThread.	self assert: t retVal equals: 0.	t privRetVal: 123.	self assert: t retVal equals: 123.! !!ScratchNativeThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/22/2019 09:03'!testPush	| e |	e := self newThread.	self assert: e stack isEmpty.	e push: 10.	e push: 20.	self assert: e stack size equals: 2.	self assertCollection: e stack asArray equals: #(10 20).! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testPush0	| e |	e := self newThread.	self assert: e stack isEmpty.	e push0.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(0).	e push0.	self assert: e stack size equals: 2.	self assertCollection: e stack asArray equals: #(0 0).! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testPush1	| e |	e := self newThread.	self assert: e stack isEmpty.	e push1.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(1).	e push1.	self assert: e stack size equals: 2.	self assertCollection: e stack asArray equals: #(1 1).! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testPushFloat	| e |	e := self newThread.	e codes: #(16r00 16r00 16rF6 16r42).	self assert: e stack isEmpty.	e pushFloat.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(123.0)! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testPushShort	| e |	e := self newThread.	e codes: #(16r03 16r00).	self assert: e stack isEmpty.	e pushShort.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(3).	e := self newThread.	e codes: #(16rFD 16rFF).	self assert: e stack isEmpty.	e pushShort.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(-3)! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testRandomFromTo	| t |	t := self newThread.	100		timesRepeat: [ self assert: t stack size equals: 0.			t push: 5.			t push: 10.			t randomFromTo.			self assert: t stack size equals: 1.			self assert: (t pop between: 5 and: 10) ].! !!ScratchNativeThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testRetVal	self testPrivRetVal.! !!ScratchNativeThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testReturn	| e |	e := self newThread.	e pc: 20.	e push: 30.	e push: 10.	e return.	self assert: e pc equals: 30.	self assert: e stack size equals: 0.	self assert: e retVal equals: 10.! !!ScratchNativeThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 10/22/2019 09:16'!testReturnValue	| e c ret |	c := self sampleCode2.	e := self newThread.	e codes: c.	ret := e evaluate: 9.	self assert: ret equals: 9.	self assert: e stack isEmpty.	self assert: e pc equals: c size + 1.! !!ScratchNativeThreadTest methodsFor: 'test' stamp: 'EiichiroIto 11/9/2019 18:45'!testRot	| t |	t := self newThread.	self assert: t stack size equals: 0.	t push: 10.	t push: 20.	t push: 30.	self assert: t stack size equals: 3.	t rot.	self assert: t stack size equals: 3.	self assert: t pop equals: 10.	self assert: t pop equals: 30.	self assert: t pop equals: 20.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testRounded	| t |	t := self newThread.	t push: 1.4.	self assert: t stack size equals: 1.	t rounded.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: 1.5.	self assert: t stack size equals: 1.	t rounded.	self assert: t stack size equals: 1.	self assert: t pop equals: 2.	t push: -1.5.	self assert: t stack size equals: 1.	t rounded.	self assert: t stack size equals: 1.	self assert: t pop equals: -2.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testSin	| t |	t := self newThread.	t push: 0.	self assert: t stack size equals: 1.	t sin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 90.	self assert: t stack size equals: 1.	t sin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1.	t push: 180.	self assert: t stack size equals: 1.	t sin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 270.	self assert: t stack size equals: 1.	t sin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -1.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testSqrt	| t |	t := self newThread.	t push: 0.	self assert: t stack size equals: 1.	t sqrt.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 2.	self assert: t stack size equals: 1.	t sqrt.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 2 sqrt.	self deny: t isTerminated.	t push: -5.	self assert: t stack size equals: 1.	t sqrt.	self assert: t isTerminated.! !!ScratchNativeThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/22/2019 09:03'!testStack	| e |	e := self newThread.	self assert: e stack isCollection.	self assert: e stack isEmpty.! !!ScratchNativeThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testStop	| t |	t := self newThread.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t stop.	self deny: t isRunning.	self deny: t isTerminated.! !!ScratchNativeThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testStopAll	| t |	t := self newThread.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t stopAll.	self deny: t isRunning.	self assert: t isTerminated.! !!ScratchNativeThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testSwap	| t |	t := self newThread.	t push: 1.	t push: 2.	t swap.	self assert: t pop equals: 1.	self assert: t pop equals: 2.! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testTan	| t |	t := self newThread.	t push: 0.	self assert: t stack size equals: 1.	t tan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 60.	self assert: t stack size equals: 1.	t tan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 3 sqrt.	t push: 30.	self assert: t stack size equals: 1.	t tan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: (1 / 3 sqrt).! !!ScratchNativeThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 10/22/2019 09:03'!testTruncated	| t |	t := self newThread.	t push: 1.4.	self assert: t stack size equals: 1.	t truncated.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: 1.5.	self assert: t stack size equals: 1.	t truncated.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: -1.5.	self assert: t stack size equals: 1.	t truncated.	self assert: t stack size equals: 1.	self assert: t pop equals: -1.! !!ScratchSexpExporterTest methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 07:53'!appName	^ 'abc'! !!ScratchSexpExporterTest methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 07:53'!newExporter	^ ScratchSexpExporter appName: self appName! !!ScratchSexpExporterTest methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 07:57'!newProject	^ ScratchProject new! !!ScratchSexpExporterTest methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 08:26'!newScript	^ ScTestScript new! !!ScratchSexpExporterTest methodsFor: 'test' stamp: 'EiichiroIto 11/30/2019 07:53'!testAppName	| ex |	ex := self newExporter.	self assert: ex appName equals: self appName.	ex appName: 'def'.	self assert: ex appName equals: 'def'! !!ScratchSexpExporterTest methodsFor: 'test' stamp: 'EiichiroIto 11/30/2019 07:56'!testWriteFooter	| ex |	ex := self newExporter.	ex privStream: '' writeStream.	ex writeFooter: nil.	self assert: ex privStream contents equals: '))'! !!ScratchSexpExporterTest methodsFor: 'test' stamp: 'EiichiroIto 11/30/2019 07:59'!testWriteHeader	| ex proj |	proj := self newProject.	ex := self newExporter.	ex privStream: '' writeStream.	ex writeHeader: proj.	self assert: ex privStream contents equals: '(abc ()', String lf, '('! !!ScratchSexpExporterTest methodsFor: 'test' stamp: 'EiichiroIto 11/30/2019 08:29'!testWriteScript	| ex sc |	sc := self newScript.	ex := self newExporter.	ex privStream: '' writeStream.	ex writeScript: sc.	self		assert: ex privStream contents		equals: '(for test (a "b c")' , String lf , '())' , String lf! !!SexpLexerTest methodsFor: 'test' stamp: 'EiichiroIto 8/2/2019 11:04'!testDelimiters	| l |	l := SexpLexer new.	self assert: (l delimiters includes: $().	self assert: (l delimiters includes: $)).	self assert: (l delimiters includes: $!!).	self assert: (l delimiters includes: $@).	self assert: (l delimiters includes: Character space).	self assert: (l delimiters includes: Character tab).	self assert: (l delimiters includes: Character cr).	self assert: (l delimiters includes: Character lf).	self deny: (l delimiters includes: $:).	($0 to: $9) do: [ :each | self deny: (l delimiters includes: each) ].	($a to: $z) do: [ :each | self deny: (l delimiters includes: each) ].	($A to: $Z) do: [ :each | self deny: (l delimiters includes: each) ]! !!SexpLexerTest methodsFor: 'test' stamp: 'EiichiroIto 8/2/2019 11:09'!testRead	| ret |	ret := SexpLexer new		read:			'(abc (def aaa) ghi))'.	self		assertCollection: ret asArray		equals: #($( 'abc' $( 'de' 'f' 'aaa' $) 'ghi' $) $))! !!SexpLexerTest methodsFor: 'test' stamp: 'EiichiroIto 8/2/2019 11:07'!testWhiteSpaces	| l |	l := SexpLexer new.	self deny: (l whiteSpaces includes: $().	self deny: (l whiteSpaces includes: $)).	self deny: (l whiteSpaces includes: $!!).	self deny: (l whiteSpaces includes: $@).	self assert: (l whiteSpaces includes: Character space).	self assert: (l whiteSpaces includes: Character tab).	self assert: (l whiteSpaces includes: Character cr).	self assert: (l whiteSpaces includes: Character lf).	self deny: (l whiteSpaces includes: $:).	($0 to: $9) do: [ :each | self deny: (l whiteSpaces includes: each) ].	($a to: $z) do: [ :each | self deny: (l whiteSpaces includes: each) ].	($A to: $Z) do: [ :each | self deny: (l whiteSpaces includes: each) ]! !!SexpParserTest methodsFor: 'test' stamp: 'EiichiroIto 8/2/2019 11:34'!testParse	| l ret |	l := #( 'abc' ).	ret := SexpParser new parse: l.	self assert: ret equals: 'abc'.	l := #( $( 'abc' 'def' $) ).	ret := SexpParser new parse: l.	self assertCollection: ret equals: #(abc def).	l := #( $( 'abc' 'def' $( 'ghi' $) $) ).	ret := SexpParser new parse: l.	self assertCollection: ret equals: #(abc def (ghi)).	l := #( $( 'abc' 'def' $( $( 'ghi' $) 'aa' $) $) ).	ret := SexpParser new parse: l.	self assertCollection: ret equals: #(abc def ((ghi) aa)).	l := #( $( $( $( $) $) $) ).	ret := SexpParser new parse: l.	self assertCollection: ret equals: #((())).! !!SexpParserTest methodsFor: 'test' stamp: 'EiichiroIto 8/2/2019 11:37'!testParseItem	| in ret |	in := ReadStream on: #('abc' 'def' $( $( 'ghi' $) 'aa' $) $)).	ret := SexpParser new parseItem: in.	self assert: ret equals: 'abc'.	self assert: in peek equals: 'def'.	in := ReadStream on: #($( 'ghi' $) 'aa' $) $)).	ret := SexpParser new parseItem: in.	self assertCollection: ret equals: #('ghi').	self assert: in peek equals: 'aa'.! !!SexpParserTest methodsFor: 'test' stamp: 'EiichiroIto 8/2/2019 11:40'!testParseItemsTo	| in list |	in := ReadStream on: #('abc' 'def' $) 'ghi' $) 'aa' $) $)).	list := OrderedCollection new.	SexpParser new parseItems: in to: list.	self assertCollection: list asArray equals: #('abc' 'def').	self assert: in peek equals: 'ghi'.	in := ReadStream on: #('abc' $( 'def' $) 'ghi' $) 'aa' $) $)).	list := OrderedCollection new.	SexpParser new parseItems: in to: list.	self assertCollection: list asArray equals: #('abc' #('def') 'ghi').	self assert: in peek equals: 'aa'! !!VarDefTest methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 13:05'!newVarDef	^ VarDef new! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testAddClassName	| v x |	v := self newVarDef.	x := v add: 'a' className: #Array.	self assert: x equals: 1.	self assert: v privClassNames size equals: 1.	self assert: (v privClassNames at: x) equals: #Array! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testAddComputedVariableVarNo	| v a b |	v := self newVarDef.	b := v addComputedVariable: 'b' varNo: 1.	a := v addVariable: 'a'.	self assert: b equals: 1.	self assert: a equals: 2.	self assert: v privVarNames size equals: 2.	self assert: (v privVarNames includes: 'a').	self assert: (v privVarNames includes: 'b').	self assert: v privReservedVarNames size equals: 1.	self assert: (v privReservedVarNames includes: 'b').	self assertCollection: v privClassNames size equals: 2.	self assert: (v privClassNames at: a) equals: #FloatArray.	self assert: (v privClassNames at: b) equals: nil! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testAddList	| v x |	v := self newVarDef.	x := v addList: 'a'.	self assert: x equals: 1.	self assert: v privClassNames size equals: 1.	self assert: (v privClassNames at: x) equals: #Array.	x := v addList: 'b'.	self assert: x equals: 2.	self assert: v privClassNames size equals: 2.	self assert: (v privClassNames at: x) equals: #Array! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testAddReservedVarNoClassName	| v x |	v := self newVarDef.	x := v addReserved: 'b' varNo: 2 className: #ByteArray.	self assert: x equals: 2.	self assert: v privClassNames size equals: 1.	self assert: (v privClassNames at: x) equals: #ByteArray.	self assert: (v privReservedVarNames includes: 'b')! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testAddReservedVariableVarNo	| v a b |	v := self newVarDef.	b := v addReservedVariable: 'b' varNo: 1.	a := v addVariable: 'a'.	self assert: b equals: 1.	self assert: a equals: 2.	self assert: v privVarNames size equals: 2.	self assert: (v privVarNames includes: 'a').	self assert: (v privVarNames includes: 'b').	self assert: v privReservedVarNames size equals: 1.	self assert: (v privReservedVarNames includes: 'b').	self assertCollection: v privClassNames size equals: 2.	self assert: (v privClassNames at: a) equals: #FloatArray.	self assert: (v privClassNames at: b) equals: #FloatArray.! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testAddVariable	| v x |	v := self newVarDef.	x := v addVariable: 'a'.	self assert: x equals: 1.	self assert: v privClassNames size equals: 1.	self assert: (v privClassNames at: x) equals: #FloatArray.	x := v addVariable: 'b'.	self assert: x equals: 2.	self assert: v privClassNames size equals: 2.	self assert: (v privClassNames at: x) equals: #FloatArray! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testAllVarNames	| v ret |	v := self newVarDef.	ret := v allVarNames.	self assert: ret isEmpty.	v addVariable: 'a'.	v addList: 'b'.	ret := v allVarNames.	self assertCollection: ret equals: #(a b).! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 07:16'!testClassFor	| v c |	v := VarDef new.	v addVariable: 'a'.	c := v classFor: 'a'.	self assert: (c isKindOf: LazyArray).	self assert: c className equals: #FloatArray! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testClassNameForVarNo	| pv a b |	pv := self newVarDef.	a := pv add: 'a' className: #Array.	b := pv add: 'b' className: #ByteArray.	self assert: (pv classNameForVarNo: a) equals: #Array.	self assert: (pv classNameForVarNo: b) equals: #ByteArray.! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testDelete	| v |	v := self newVarDef.	v addVariable: 'abc'.	v addVariable: 'def'.	v addVariable: 'ghi'.	self assertCollection: v privVarNames asArray equals: #('abc' 'def' 'ghi').	v delete: 'abc'.	self assertCollection: v privVarNames asArray equals: #('def' 'ghi').! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 07:16'!testFixVars	| v |	v := VarDef new.	v privVarNames: #(a b c b c a) asOrderedCollection.	self assertCollection: v varNames asArray equals: #(a b c b c a).	v fixVars.	self assertCollection: v varNames asArray equals: #(a b c).! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testIncludes	| v |	v := self newVarDef.	v addVariable: 'abc'.	v addVariable: 'def'.	v addVariable: 'ghi'.	self assert: (v includes: 'abc').	self assert: (v includes: 'def').	self assert: (v includes: 'ghi').	self assert: (v includes: 'aaa') not.	self assert: (v includes: 'bbb') not.! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testInitialize	| v |	v := self newVarDef.	self assert: v varNames isEmpty.	self assert: v privClassNames isDictionary.	self assert: v privClassNames isEmpty.	self assert: v privReservedVarNames isCollection.	self assert: v privReservedVarNames isEmpty! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testIsReserved	| v |	v := self newVarDef.	v addReservedVariable: 'b' varNo: 1.	v addVariable: 'a'.	self deny: (v isReserved: 'a').	self assert: (v isReserved: 'b')! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testListNames	| v ret |	v := self newVarDef.	ret := v listNames.	self assert: ret isEmpty.	v addList: 'a'.	v addList: 'b'.	ret := v listNames.	self assertCollection: ret equals: #(a b).! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testPrivClassNames	| v |	v := self newVarDef.	self assert: v privClassNames isDictionary.	self assert: v privClassNames isEmpty! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 07:16'!testPrivReservedVarNames	| v |	v := VarDef new.	self assert: v privReservedVarNames isEmpty.	v privReservedVarNames: 123.	self assert: v privReservedVarNames equals: 123! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testPrivVarNames	| v |	v := self newVarDef.	self assert: v privVarNames isNil.	v privVarNames: #(1 2 3).	self assertCollection: v privVarNames equals: #(1 2 3).! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 07:16'!testRealVarNames	| v |	v := VarDef new.	v addVariable: 'a'.	v addVariable: 'b'.	self assertCollection: v realVarNames equals: #(a b).	v add: 'c' className: nil.	self assertCollection: v realVarNames equals: #(a b)! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 07:40'!testRegularize	| v |	v := VarDef new.	v addReservedVariable: 'x' varNo: 1.	v addVariable: 'a'.	v addVariable: 'b'.	v addVariable: 'c'.	self assertCollection: v privVarNames asArray equals: #(x a b c).	v privVarNames: #('a' 'b' 'x' 'c') asOrderedCollection.	v regularize.	self assertCollection: v privVarNames asArray equals: #('x' 'a' 'b' 'c')! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 07:16'!testReservedNo	| v |	v := VarDef new.	self assert: v reservedNo equals: 0! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testSetupVarNames	| v |	v := self newVarDef.	v addReservedVariable: 'a' varNo: 1.	v addReservedVariable: 'b' varNo: 2.	self assert: v varNames isEmpty.	v setupVarNames.	self assertCollection: v varNames equals: #('a' 'b').	v := self newVarDef.	v addReservedVariable: 'a' varNo: 1.	v addReservedVariable: 'b' varNo: 3.	self assert: v varNames isEmpty.	self should: [ v setupVarNames ] raise: Error! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testSize	| v |	v := self newVarDef.	v addVariable: 'x'.	self assert: v size equals: 1.	v addVariable: 'y'.	self assert: v size equals: 2.! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testUserDefinedVarNames	| v ret |	v := self newVarDef.	ret := v userDefinedVarNames.	self assertCollection: ret equals: #().	v addVariable: 'a'.	v addVariable: 'b'.	v addVariable: 'c'.	ret := v userDefinedVarNames.	self assertCollection: ret equals: #(a b c).! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testUserDefinedVarNoAndNames	| v |	v := self newVarDef .	v addVariable: 'a'.	v addVariable: 'b'.	v addVariable: 'c'.	self		assertCollection: v userDefinedVarNoAndNames asArray		equals: #(#(1 'a') #(2 'b') #(3 'c')).! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testVarFor	| v |	v := self newVarDef.	v addVariable: 'abc'.	v addVariable: 'def'.	v addVariable: 'ghi'.	self assert: (v varNoFor: 'abc') equals: 1.	self assert: (v varNoFor: 'def') equals: 2.	self assert: (v varNoFor: 'ghi') equals: 3.	self should: [v varNoFor: 'aaa'] raise: NotFound.	self should: [v varNoFor: 'bbb'] raise: NotFound.! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 13:05'!testVarNames	| v |	v := self newVarDef.	self assert: v varNames isEmpty.	v addVariable: 'x'.	v addVariable: 'y'.	self assertCollection: v varNames equals: #('x' 'y').! !!VarDefTest methodsFor: 'test' stamp: 'EiichiroIto 11/27/2019 07:16'!testVarNoFor	| v a b c |	v := VarDef new.	a := v addVariable: 'a'.	b := v addVariable: 'b'.	c := v addVariable: 'c'.	self assert: a ~= b.	self assert: b ~= c.	self assert: c ~= a.	self assert: (v varNoFor: 'a') equals: a.	self assert: (v varNoFor: 'b') equals: b.	self assert: (v varNoFor: 'c') equals: c! !!VariablesTest methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 13:05'!newVarDef	^ VarDef new! !!VariablesTest methodsFor: 'private' stamp: 'EiichiroIto 10/22/2019 16:17'!newVariables	^ Variables new! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:45'!testClear	| v varId v1 v2 |	v := self newVariables.	varId := self newVarDef.	v1 := varId addVariable: 'a'.	v2 := varId addVariable: 'b'.	v updateVarDef: varId.	v var: v1 at: 1 put: 2.	v var: v1 at: 2 put: 3.	v var: v2 at: 1 put: 20.	v var: v2 at: 2 put: 30.	self assert: (v privVars at: v1) array notEmpty.	self assert: (v privVars at: v2) array notEmpty.	v clear.	self assert: (v privVars at: v1) array isEmpty.	self assert: (v privVars at: v2) array isEmpty! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testClearVarNo	| v varId v1 |	v := self newVariables.	varId := self newVarDef.	v1 := varId addVariable: 'a'.	v updateVarDef: varId.	self assert: (v var: v1 at: 1) equals: 0.	self assert: (v var: v1 at: 2) equals: 0.	v var: v1 at: 3 put: 3.	v setVar: v1 toAll: 2.	self assert: (v var: v1 at: 1) equals: 2.	self assert: (v var: v1 at: 2) equals: 2.	v clearVarNo: v1.	self assert: (v var: v1 at: 1) equals: 0.	self assert: (v var: v1 at: 2) equals: 0.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testCopyElementFromTo	| v varId v1 v2 |	v := self newVariables.	varId := self newVarDef.	v1 := varId addVariable: 'a'.	v2 := varId addVariable: 'b'.	v updateVarDef: varId.	v var: v1 at: 1 put: 2.	v var: v1 at: 2 put: 3.	v var: v2 at: 1 put: 20.	v var: v2 at: 2 put: 30.	self assert: (v var: v1 at: 1) equals: 2.	self assert: (v var: v1 at: 2) equals: 3.	self assert: (v var: v2 at: 1) equals: 20.	self assert: (v var: v2 at: 2) equals: 30.	v copyElementFrom: 1 to: 2.	self assert: (v var: v1 at: 1) equals: 2.	self assert: (v var: v1 at: 2) equals: 2.	self assert: (v var: v2 at: 1) equals: 20.	self assert: (v var: v2 at: 2) equals: 20.	v var: v1 at: 1 put: 4.	self assert: (v var: v1 at: 1) equals: 4.	self assert: (v var: v1 at: 2) equals: 2.	self assert: (v var: v2 at: 1) equals: 20.	self assert: (v var: v2 at: 2) equals: 20.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testForceSize	| v varId v1 v2 |	v := self newVariables.	varId := self newVarDef.	v1 := varId addVariable: 'a'.	v2 := varId addVariable: 'b'.	v updateVarDef: varId.	v var: v1 at: 1 put: 2.	v var: v1 at: 2 put: 3.	v var: v2 at: 1 put: 20.	v var: v2 at: 5 put: 30.	self assert: (v varAt: v1) fixedSize isNil.	self assert: (v varAt: v2) fixedSize isNil.	v forceSize: 10.	self assert: (v varAt: v1) fixedSize equals: 10.	self assert: (v varAt: v2) fixedSize equals: 10.	self assert: (v var: v1 at: 1) equals: 2.	self assert: (v var: v1 at: 2) equals: 3.	self assert: (v var: v2 at: 1) equals: 20.	self assert: (v var: v2 at: 5) equals: 30.	self assert: (v var: v1 at: 10) equals: 0.	self assert: (v var: v2 at: 10) equals: 0.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 16:18'!testInitialize	| v |	v := self newVariables.	self assert: v privVarNames isArray.	self assert: v privVarNames isEmpty.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testMax	| v varId v1 v2 |	v := self newVariables.	varId := self newVarDef.	v1 := varId addVariable: 'a'.	v2 := varId addVariable: 'b'.	v updateVarDef: varId.	v var: v1 at: 1 put: 2.	v var: v1 at: 2 put: 3.	v var: v2 at: 1 put: 30.	v var: v2 at: 5 put: 20.	self assert: v max equals: 100! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testMultiplyBy	| var varId v1 v2 |	var := self newVariables.	varId := self newVarDef.	v1 := varId addVariable: 'a'.	v2 := varId addVariable: 'b'.	var updateVarDef: varId.	var var: v1 at: 1 put: 10.	var var: v2 at: 1 put: 20.	self assert: (var var: v1 at: 1) equals: 10.	self assert: (var var: v2 at: 1) equals: 20.	var multiply: v1 by: 2.	var multiply: v2 by: 3.	self assert: (var var: v1 at: 1) equals: 20.	self assert: (var var: v2 at: 1) equals: 60! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 16:18'!testPrivVarNames	| v |	v := self newVariables.	self assert: v privVarNames class equals: Array.	v privVarNames: 123.	self assert: v privVarNames equals: 123.	v privVarNames: 234.	self assert: v privVarNames equals: 234.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 10/22/2019 16:18'!testPrivVars	| v |	v := self newVariables.	self assert: v privVars isNil.	v privVars: 123.	self assert: v privVars equals: 123.	v privVars: 234.	self assert: v privVars equals: 234.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testRealArrayAt	| v varId |	v := self newVariables.	varId := self newVarDef.	varId addVariable: 'a'.	varId addVariable: 'b'.	v updateVarDef: varId.	self assert: (v realArrayAt: 1) isEmpty.	self assert: (v realArrayAt: 2) isEmpty.	v var: 1 at: 1 put: 10.	v var: 2 at: 2 put: 20.	self assertCollection: (v realArrayAt: 1) size equals: 100.	self assertCollection: (v realArrayAt: 2) size equals: 100.	self assert: (v realArrayAt: 1) first equals: 10.0.	self assert: (v realArrayAt: 1) second equals: 0.0.	self assert: (v realArrayAt: 2) first equals: 0.0.	self assert: (v realArrayAt: 2) second equals: 20.0.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testSetVarToAll	| v varId v1 |	v := self newVariables.	varId := self newVarDef.	v1 := varId addVariable: 'a'.	v updateVarDef: varId.	v var: v1 at: 3 put: 3.	self assert: (v var: v1 at: 1) equals: 0.	self assert: (v var: v1 at: 2) equals: 0.	v setVar: v1 toAll: 1.	self assert: (v var: v1 at: 1) equals: 1.	self assert: (v var: v1 at: 2) equals: 1.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testSetVarToArray	| v varId v1 a |	v := self newVariables.	varId := self newVarDef.	v1 := varId addVariable: 'a'.	v updateVarDef: varId.	self assert: (v varAt: v1) isEmpty.	a := #(1 2 3) asFloatArray.	v setVar: v1 toArray: a.	self assertCollection: (v realArrayAt: v1) equals: a.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 18:59'!testSize	self testMax! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:34'!testUpdateVarDef	| v varId1 varId2 |	varId1 := self newVarDef.	varId1 addVariable: 'a'.	varId1 addVariable: 'b'.	varId1 addVariable: 'c'.	v := self newVariables.	v updateVarDef: varId1.	self assertCollection: v privVarNames asArray equals: #('a' 'b' 'c').	self assert: v privVars isArray.	self assert: v privVars size equals: 3.	self assert: (v privVars at: 1) isEmpty.	self assert: (v privVars at: 2) isEmpty.	self assert: (v privVars at: 3) isEmpty.	(v privVars at: 1) setArray: #(0 0 0) asFloatArray.	(v privVars at: 2) setArray: #(1 2 3) asFloatArray.	(v privVars at: 3) setArray: #(4 5 6) asFloatArray.	varId2 := self newVarDef.	varId2 addVariable: 'c'.	varId2 addVariable: 'b'.	varId2 addVariable: 'd'.	v updateVarDef: varId2.	self assertCollection: v privVarNames asArray equals: #('c' 'b' 'd').	self assert: v privVars isArray.	self assert: v privVars size equals: 3.	self assert: (v privVars at: 1) privArray equals: #(4 5 6) asFloatArray.	self assert: (v privVars at: 2) privArray equals: #(1 2 3) asFloatArray.	self assert: (v privVars at: 3) isEmpty.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testVarAt	| vid var v |	vid := self newVarDef.	v := vid addVariable: 'a'.	var := self newVariables.	var updateVarDef: vid.	self assert: (var var: v at: 1) equals: 0.	(var varAt: v) at: 1 put: 1.	(var varAt: v) at: 2 put: 5.	self assert: (var var: v at: 1) equals: 1.	self assert: (var var: v at: 2) equals: 5.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testVarAt2	| v varId |	v := self newVariables.	varId := self newVarDef.	varId addVariable: 'a'.	varId addVariable: 'b'.	v updateVarDef: varId.	self assert: (v varAt: 1) isEmpty.	self assert: (v varAt: 2) isEmpty.	v privVars at: 1 put: 10.	v privVars at: 2 put: 20.	self assert: (v varAt: 1) equals: 10.	self assert: (v varAt: 2) equals: 20.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:28'!testVarAtPut	| vid var v |	vid := self newVarDef.	v := vid addVariable: 'a'.	var := self newVariables.	var updateVarDef: vid.	self assert: (var var: v at: 1) equals: 0.	self assert: (var var: v at: 2) equals: 0.	var var: v at: 1 put: 1.	var var: v at: 2 put: 5.	self assert: (var var: v at: 1) equals: 1.	self assert: (var var: v at: 2) equals: 5.! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:57'!testVarListAdd	| v varDef v1 |	v := self newVariables.	varDef := self newVarDef.	v1 := varDef addList: 'a'.	v updateVarDef: varDef.	v var: v1 list: 1 add: 10.	v var: v1 list: 1 add: 20.	v var: v1 list: 2 add: 5.	v var: v1 list: 2 add: 6.	self assert: (v var: v1 list: 1 at: 1) equals: 10.	self assert: (v var: v1 list: 1 at: 2) equals: 20.	self assert: (v var: v1 list: 2 at: 1) equals: 5.	self assert: (v var: v1 list: 2 at: 2) equals: 6! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 21:05'!testVarListAt	self testVarListAtPut! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 20:58'!testVarListAtPut	| v varDef v1 |	v := self newVariables.	varDef := self newVarDef.	v1 := varDef addList: 'a'.	v updateVarDef: varDef.	v var: v1 list: 1 at: 1 put: 10.	v var: v1 list: 1 at: 2 put: 20.	v var: v1 list: 2 at: 1 put: 5.	v var: v1 list: 2 at: 2 put: 6.	self assert: (v var: v1 list: 1 at: 1) equals: 10.	self assert: (v var: v1 list: 1 at: 2) equals: 20.	self assert: (v var: v1 list: 2 at: 1) equals: 5.	self assert: (v var: v1 list: 2 at: 2) equals: 6! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 21:06'!testVarListContains	| v varDef v1 |	v := self newVariables.	varDef := self newVarDef.	v1 := varDef addList: 'a'.	v updateVarDef: varDef.	v var: v1 list: 1 at: 1 put: 10.	v var: v1 list: 1 at: 2 put: 20.	v var: v1 list: 2 at: 1 put: 5.	v var: v1 list: 2 at: 2 put: 6.	self assert: (v var: v1 list: 1 contains: 10).	self assert: (v var: v1 list: 1 contains: 20).	self deny: (v var: v1 list: 1 contains: 30).	self assert: (v var: v1 list: 2 contains: 5).	self assert: (v var: v1 list: 2 contains: 6).	self deny: (v var: v1 list: 2 contains: 7)! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 21:07'!testVarListRemove	| v varDef v1 |	v := self newVariables.	varDef := self newVarDef.	v1 := varDef addList: 'a'.	v updateVarDef: varDef.	v var: v1 list: 1 at: 1 put: 10.	v var: v1 list: 1 at: 2 put: 20.	v var: v1 list: 1 at: 3 put: 30.	v var: v1 list: 1 remove: 2.	self assert: (v var: v1 list: 1 at: 1) equals: 10.	self assert: (v var: v1 list: 1 at: 2) equals: 30! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 21:09'!testVarListSet	| v varDef v1 |	v := self newVariables.	varDef := self newVarDef.	v1 := varDef addList: 'a'.	v updateVarDef: varDef.	v var: v1 list: 1 set: #(10 20 30).	v var: v1 list: 1 add: 40.	self assert: (v var: v1 list: 1 at: 1) equals: 10.	self assert: (v var: v1 list: 1 at: 2) equals: 20.	self assert: (v var: v1 list: 1 at: 3) equals: 30.	self assert: (v var: v1 list: 1 at: 4) equals: 40! !!VariablesTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 21:10'!testVarListSizeOf	| v varDef v1 |	v := self newVariables.	varDef := self newVarDef.	v1 := varDef addList: 'a'.	v updateVarDef: varDef.	v var: v1 list: 1 set: #(10 20 30).	self assert: (v var: v1 listSizeOf: 1) equals: 3! !!InputEventSensor methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/29/2016 20:35'!peekAnyButtonPressed	^ self peekMouseButtons anyMask: 7! !!InputEventSensor methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/29/2016 20:34'!peekMouseButtons	| evt |	evt := eventQueue peek.	^ (evt notNil and: [ (evt at: 1) = EventTypeMouse ])		ifTrue: [ evt at: 3 ]		ifFalse: [ mouseButtons ]! !!SpScratchApp class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:14'!appFolderName	self subclassResponsibility! !!SpScratchApp class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:18'!appName	self subclassResponsibility! !!SpScratchApp class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:14'!extension	self subclassResponsibility! !!SpScratchApp class methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 09:14'!icon	^ (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20917024 0 0 2168865 0 0 0 218103844 14388762 0 0 0 0 0 0 0 150994979 2794676508 285212716 0 0 0 168429857 3619256603 654311460 0 0 0 0 0 0 0 0 3485892891 4292907545 2238268958 2847241755 2963893787 3467341852 4294944022 2156550166 0 2168865 0 0 0 0 0 0 2863230491 4294945048 4294680335 4294944270 4294944536 4294944534 4290743881 4154824329 1025776423 0 2168865 0 0 0 0 0 2897047835 4294418716 4290886326 4290558654 4293105701 4294944020 4291804323 4294967295 4287133026 201326592 0 0 0 0 0 493635615 4058486297 4293894182 4294439917 4292730080 4290616948 4294944786 4291332655 4291941340 4289702571 2188990254 0 0 0 237049889 1193351201 1601983006 4294221337 4294615059 4290091383 4292006100 4290820016 4292780356 4286797342 4289504157 4291282376 4292927458 1533501799 756945950 253827105 136386593 790698017 2640067871 4294484248 4294946610 4294634453 4293585643 4290492604 4294375674 4291874768 4294967295 4294967295 4294901502 4291019203 0 0 0 0 530080796 4209349913 4294948677 4294967295 4294046193 4294769916 4290821568 4291808719 4290887361 4293651179 4294967295 3649471110 688521226 86054945 0 0 0 1701200927 4293696546 4294965217 4294704639 4289900466 4293651179 4293651179 4289966259 4294835709 4140287175 609833561 0 0 0 0 4599584 0 1142559519 3569449230 3891254444 4126800119 4124299731 3939618769 3689605610 2643956631 167772160 0 0 0 0 0 0 2168865 0 83886119 356392448 597659520 614966441 427982466 134217728 0 0 2168865 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!SpScratchApp class methodsFor: 'class initialization' stamp: 'EiichiroIto 11/24/2019 09:22'!initialize	UseErrorCatcher := false.	Clipboard := nil! !!SpScratchApp class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:13'!putInClipboard: anObject	Clipboard := anObject! !!SpScratchApp class methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 09:15'!thumbnailExtent	^ 120 @ 120! !!SpScratchApp class methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 21:19'!try: aBlock onFailure: anErrorBlock	self useErrorCatcher		ifTrue: [ aBlock ifError: anErrorBlock ]		ifFalse: aBlock value! !!SpScratchApp class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:12'!useErrorCatcher	^ UseErrorCatcher! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 17:15'!aboutAppString	self subclassResponsibility! !!SpScratchApp methodsFor: 'button actions' stamp: 'EiichiroIto 11/23/2019 17:15'!addList: aScript	| listName |	listName := UIManager default request: 'List name?' localized.	(listName isNil or: [ listName isEmpty ])		ifTrue: [ ^ self ].	(aScript variableNameInUse: listName)		ifTrue: [ ^ UIManager default				alert: 'That list name is already in use' localized ].	aScript addList: listName.	presenter currentCategory: #variables! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 11/23/2019 17:15'!addSubBlock: anEvent script: aScript	| subName |	subName := UIManager default request: 'Sub name?'.	(subName isNil or: [ subName isEmpty ])		ifTrue: [ ^ self ].	aScript addSubBlock: anEvent cursorPoint name: subName! !!SpScratchApp methodsFor: 'button actions' stamp: 'EiichiroIto 11/23/2019 17:16'!addVariable: aScript	| varName |	varName := UIManager default request: 'Variable name?' localized.	(varName isNil or: [ varName isEmpty ])		ifTrue: [ ^ self ].	(aScript variableNameInUse: varName)		ifTrue: [ ^ UIManager default				alert: 'That variable name is already in use' localized ].	aScript addVariable: varName.	presenter currentCategory: 'Variables'! !!SpScratchApp methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 17:16'!appFolderName	^ self class appFolderName! !!SpScratchApp methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:18'!appName	^ self class appName! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 12/5/2019 21:07'!backupProject	self subclassResponsibility! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 17:16'!basedVersion	^ '1.4 (source code of 23-Sep-09)'! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 17:17'!closeMediaEditorsAndDialogs	DialogWindow allInstances do: #cancel.	^ true! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 11:47'!createProject	self subclassResponsibility! !!SpScratchApp methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 17:17'!currentTab	^ presenter currentTab! !!SpScratchApp methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 17:17'!currentTarget	^ presenter currentTarget! !!SpScratchApp methodsFor: 'button actions' stamp: 'EiichiroIto 11/23/2019 17:17'!deleteVariable: aScript	"Ask the user which user variable to delete, then remove it."	| menu choice |	aScript varNames isEmpty		ifTrue: [ ^ UIManager default alert: 'No variables.' localized ].	menu := MenuMorph new.	menu target: [ :v | choice := v ].	aScript varNames		do: [ :v | menu add: v selector: #value: argument: v ].	menu invokeModal: true.	choice ifNil: [ ^ self ].	aScript deleteVariable: choice.	presenter currentCategory: 'Variables'! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 11/23/2019 21:15'!editNotes	| ret |	ret := UIManager default		multiLineRequest: 'Project Notes' localized		initialAnswer: project comment		answerHeight: 450.	ret ifNil: [ ^ self ].	project comment: ret! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 09:46'!export: anExporter extension: aString	| fName f str |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	fName := (SpFileChooserDialog extension: aString)		chooseNewFileDefault: self projectName		title: 'Export ...'		type: #export.	fName ifNil: [ ^ self ].	fName := fName withExtension: aString.	fName isFile		ifTrue: [ (UIManager default				confirm: 'Overwrite existing ' , fName basename , '?')				ifFalse: [ ^ self ].			fName delete ].	f := nil.	[ f := fName writeStream.	str := anExporter exportFrom: self.	f nextPutAll: str.	f close ]		ifError: [ f ifNotNil: [ f close ].			UIManager default				alert: 'Could not write file' , fName basename				title: 'Export failed' localized ]! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 17:20'!extension	^ self class extension! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 10:21'!import: anImporter extension: aString	| response fr f code |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	response := (SpFileChooserDialog extension: aString)		chooseExistingFileType: #export		title: 'Import ...'.	response ifNil: [ ^ self ].	fr := response asFileReference.	fr isFile		ifFalse: [ ^ self ].	[ f := fr readStream.	code := f contents.	f close ]		ifError: [ f ifNotNil: [ f close ].			^ UIManager default				alert: 'Could not read file' localized				title: 'Import failed' localized ].	anImporter import: code to: self.	self restoreProject.	presenter updateDisplay! !!SpScratchApp methodsFor: 'initialization' stamp: 'EiichiroIto 11/23/2019 19:02'!initialize	super initialize.	presenter := self newPresenter.	updateInfoCount := 0! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 19:07'!installNewProject: aProject	self subclassResponsibility! !!SpScratchApp methodsFor: 'processes' stamp: 'EiichiroIto 11/23/2019 19:05'!isProcessRunning	^ process notNil and: [ process isRunning ]! !!SpScratchApp methodsFor: 'processes' stamp: 'EiichiroIto 11/23/2019 19:11'!maxUpdateInfoCount	^ 50! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 19:03'!newPresenter	self subclassResponsibility! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 12/5/2019 21:45'!newProject	| response |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	(project notNil and: [ project modified ])		ifTrue: [ response := UIManager default				confirm: 'Save the current project?' localized				orCancel: [ ^ self ].			response				ifTrue: [ self saveProjectNoDialog ] ].	self		projectDirectory: (ScratchDirectory current getDefaultFolderForType: #project).	self projectName: 'New Project'.	self installNewProject: self createProject! !!SpScratchApp methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 23:08'!open	self open: presenter.	self newProject.	presenter window maximize.	^ self! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 11/29/2019 20:51'!openProject	| response newProj |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	(project notNil and: [ project modified ])		ifTrue: [ response := UIManager default				confirm: 'Save the current project?'				orCancel: [ ^ self ].			response				ifTrue: [ self saveProjectNoDialog ] ].	response := (SpFileChooserDialog extension: self extension)		project: self createProject;		openScratchFile.	response ifNil: [ ^ self ].	newProj := self createProject readProjectFrom: response.	newProj ifNil: [ ^ self ].	self projectDirectory: response parent.	self projectName: response base.	self installNewProject: newProj! !!SpScratchApp methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 18:54'!project	^ project! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 07:45'!projectDirectory	^ ScratchDirectory current getLastFolderForType: #project! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 07:45'!projectDirectory: aFileReference	ScratchDirectory current		setLastFolderTo: aFileReference		forType: #project! !!SpScratchApp methodsFor: 'testing' stamp: 'EiichiroIto 11/23/2019 19:03'!projectIsEmpty	^ true! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 19:03'!projectName	^ presenter projectName! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/29/2019 23:06'!projectName: aString	| text |	presenter projectName: aString.	text := (aString isEmpty		ifTrue: [ '' ]		ifFalse: [ aString , '- ' ]) , self appName.	presenter window		title: text;		updateTitle! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 18:53'!restoreProject	self subclassResponsibility! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 11/24/2019 09:50'!saveProject	| fName result |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	fName := (SpFileChooserDialog extension: self extension)		saveScratchFileFor: project.	fName ifNil: [ ^ self ].	[ (result := (SpFileChooserDialog extension: self extension)		confirmFileOverwriteIfExisting: fName		orCancel: [ ^ self ]) isNil ]		whileTrue: [ fName := (SpFileChooserDialog extension: self extension)				saveScratchFileFor: self.			fName ifNil: [ ^ self ] ].	project		thumbnailForm: (presenter stageShotSized: self class thumbnailExtent).	(project writeProjectAs: result)		ifFalse: [ ^ self ].	self projectName: result base.	self projectDirectory: result parent! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 11/24/2019 10:22'!saveProjectNoDialog	| fName dir file |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	fName := self projectName.	dir := ScratchDirectory current getLastFolderForType: #project.	file := dir / (fName , '.' , self extension).	file isFile		ifFalse: [ ^ self saveProject ].	ScratchDirectory current lastFolderIsSampleProjectsFolder		ifTrue: [ ^ self saveProject ].	(project writeProjectAs: file)		ifFalse: [ ^ self ].	self projectName: file base.	self projectDirectory: file parent! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 11/24/2019 09:48'!saveScriptsToImage	"Take a snapshot of all scripts for a sprite and save as a GIF file"	| fName saveForm pngExt |	pngExt := 'png'.	saveForm := presenter scriptForm.	saveForm ifNil: [ ^ self ].	fName := (SpFileChooserDialog extension: pngExt)		chooseNewFileDefault: ''		title: 'Save Scripts Snapshot'		type: #scriptsSnapshot.	fName ifNil: [ ^ self ].	fName := fName withExtension: pngExt.	saveForm writePNGFileNamed: fName pathString! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 12/5/2019 21:22'!setupView	| viewTarget |	viewTarget := project scripts first.	project scripts		do: [ :m | 			m scripts size > viewTarget scripts size				ifTrue: [ viewTarget := m ] ].	presenter target: viewTarget! !!SpScratchApp methodsFor: 'processes' stamp: 'EiichiroIto 11/23/2019 17:23'!startProcessFor: topBlock	self subclassResponsibility! !!SpScratchApp methodsFor: 'processes' stamp: 'EiichiroIto 11/23/2019 19:11'!stepProcesses	process ifNil: [ ^ self ].	process step.	updateInfoCount := updateInfoCount + 1.	updateInfoCount > self maxUpdateInfoCount		ifTrue: [ updateInfoCount := 0.			self updateInfo ].	presenter updateDisplay! !!SpScratchApp methodsFor: 'processes' stamp: 'EiichiroIto 11/23/2019 17:22'!stopAllProcesses	process ifNil: [ ^ self ].	process stop.	process := nil! !!SpScratchApp methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 17:22'!updateContents	presenter updateContents! !!SpScratchApp methodsFor: 'processes' stamp: 'EiichiroIto 11/23/2019 18:59'!updateInfo	self subclassResponsibility! !!False methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 22:26'!asNumberNoError	^ 0! !!PasteUpMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/22/2016 20:54'!isPartsBin	^ false! !!PasteUpMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/18/2016 17:07'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow the given submorph to be extracted. If I am a parts bin answer a new copy of it."	| root |	root := aMorph.	[root = self] whileFalse: [		root owner == self ifTrue: [			self isPartsBin ifTrue: [^ root fullCopy].			self dragNDropEnabled ifTrue: [^ root]].		root := root owner].	^ super rootForGrabOf: aMorph! !!ScratchScriptsMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/22/2019 15:20'!cleanUp	"Align all scripts vertically in alphabetical order"	| sortedBlocks y collectedBlocks |	collectedBlocks := OrderedCollection new.	submorphs		do: [ :m | 			m isBlockMorph				ifTrue: [ collectedBlocks add: m ] ].	sortedBlocks := collectedBlocks copy		sort: [ :s1 :s2 | s1 top < s2 top ].	y := 20.	(owner isKindOf: ScrollFrameMorph2)		ifTrue: [ owner hScrollPixels: 0.			owner vScrollPixels: 0 ].	sortedBlocks		do: [ :s | 			s position: self position + (20 @ y).			y := y + s fullBounds height + 15 ].	self layoutChanged! !!ScratchScriptsMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/23/2019 08:37'!click: evt	self showMenu: evt! !!ScratchScriptsMorph methodsFor: 'drawing' stamp: 'EiichiroIto 11/23/2019 15:40'!drawOn: aCanvas	"Fill with my texture patch. Fill with a solid color if there is no texture in the current skin dictionary."	| patchF clipC y x |	self isScreenshooting		ifTrue: [ aCanvas fillRectangle: self bounds color: Color transparent.			^ self ].	patchF := ScratchTheme formAt: #scriptsPaneTexture.	clipC := aCanvas copyClipRect: self bounds.	y := self top.	[ y <= self bottom ]		whileTrue: [ x := self left.			[ x <= self right ]				whileTrue: [ clipC paintImage: patchF at: x @ y.					x := x + patchF width ].			y := y + patchF height ]! !!ScratchScriptsMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 11/27/2019 08:51'!fieldsVersion	^ 1! !!ScratchScriptsMorph methodsFor: 'event handling' stamp: 'md 2/18/2004 14:58'!handlesMouseDown: evt		^ true! !!ScratchScriptsMorph methodsFor: 'initialization' stamp: 'ee 11/4/2008 11:49'!initialize	super initialize.	color := Color white.	borderWidth := 0.	self enableDragNDrop: true.! !!ScratchScriptsMorph methodsFor: 'screenshot' stamp: 'jens 3/9/2009 13:02'!isScreenshooting	^ screenshooting ifNil: [screenshooting := false]! !!ScratchScriptsMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 07:23'!isScriptEditor	^ true! !!ScratchScriptsMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/23/2019 08:38'!mouseDown: evt	evt hand newKeyboardFocus: nil.	evt hand waitForClicksOrDrag: self event: evt! !!ScratchScriptsMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/20/2019 06:15'!project	^ project! !!ScratchScriptsMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/20/2019 06:15'!project: aProject	project := aProject! !!ScratchScriptsMorph methodsFor: 'screenshot' stamp: 'EiichiroIto 11/23/2019 15:42'!screenshot	"answer a Form of myself apt for exporting"	| saveForm leftX topY rightX bottomY |	screenshooting := true.	self changed.	saveForm := self imageForm.	"clip"	submorphs isEmpty		ifTrue: [ ^ nil ].	leftX := submorphs anyOne left.	topY := submorphs anyOne top.	rightX := submorphs anyOne right.	bottomY := submorphs anyOne bottom.	(self allMorphs select: [ :m | m ~= self ])		do: [ :m | 			leftX := leftX min: m left.			topY := topY min: m top.			rightX := rightX max: m right.			bottomY := bottomY max: m bottom ].	saveForm := saveForm		copy:			(leftX @ topY - self position				rectangle: rightX @ bottomY - self position).	screenshooting := false.	self changed.	^ saveForm! !!ScratchScriptsMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/23/2019 12:41'!scriptsMenu: anEvent script: aScript	"Present a menu of Scratch script operations."	| app menu |	app := self project application.	menu := MenuMorph new.	menu target: app.	menu		add: 'add sub block'		target: app		selector: #addSubBlock:script:		argumentList:			{anEvent.			aScript}.	menu addLine.	menu add: 'clean up' target: self selector: #cleanUp.	menu add: 'save picture of scripts' selector: #saveScriptsToImage.	menu localize.	menu popUpEvent: anEvent in: self world! !!ScratchScriptsMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/23/2019 15:43'!showMenu: anEvent	| m |	(m := self project) ifNil: [ ^ self ].	m application currentTarget		ifNotNil: [ :s | self scriptsMenu: anEvent script: s ]! !!ScratchScriptsMorph methodsFor: 'stepping' stamp: 'EiichiroIto 11/23/2019 15:45'!step	"Give feedback about possible drop targets."	| feedbackColor h b targetArg targetAssoc targetP targetBlock |	feedbackMorph		ifNil: [ feedbackMorph := BorderedMorph new borderWidth: 3 ]		ifNotNil: [ feedbackMorph delete ].	feedbackColor := Color white.	feedbackMorph useSquareCorners.	h := self activeHand.	"h toolType = 'CutTool' ifTrue: [^ self showDeleteFeedback]."	(self bounds containsPoint: h position)		ifFalse: [ ^ self ].	h submorphCount = 1		ifFalse: [ ^ self ].	b := h firstSubmorph.	b isBlockMorph		ifFalse: [ ^ self ].	b isReporter		ifTrue: [ "reporter block"			(targetArg := self topArgMorphAt: b bounds exclude: nil)				ifNil: [ ^ self ].			(targetArg acceptsTypeOf: b)				ifFalse: [ ^ self ].			feedbackMorph				bounds: (targetArg bounds expandBy: 5);				color: (feedbackColor alpha: 0.4);				borderColor: feedbackColor;				useRoundedCorners.			^ self addMorphFront: feedbackMorph ].	"non-reporter (i.e. command block or hat block)"	targetAssoc := b closestAttachTargetIn: self.	targetAssoc		ifNil: [ b bottomBlock isCBlock				ifFalse: [ targetAssoc := b bottomBlock closestAttachTargetIn: self.					targetAssoc						ifNotNil: [ targetAssoc value owner isBlockMorph								ifTrue: [ targetAssoc := nil ] ] ] ].	targetAssoc ifNil: [ ^ self ].	targetP := targetAssoc key.	targetBlock := targetAssoc value.	feedbackMorph		borderColor: feedbackColor;		color: feedbackColor.	"subtract the attachment point x from the width so that the feedback in CBlock won't stick out"	feedbackMorph extent: (targetBlock right - targetP x) @ 5.	self addMorphFront: (feedbackMorph position: targetP)! !!ScratchScriptsMorph methodsFor: 'stepping' stamp: 'md 2/20/2004 17:31'!stepTime	^ 50! !!ScratchScriptsMorph methodsFor: 'stepping' stamp: 'EiichiroIto 11/23/2019 15:50'!topArgMorphAt: aRectangle exclude: aMorph	"Give feedback about possible drop targets."	| stack argM |	"find the top block or stack under the given point, excluding the given morph"	stack := submorphs		detect: [ :m | 			m ~~ aMorph				and:					[ m isBlockMorph and: [ m fullBounds intersects: aRectangle ] ] ]		ifNone: [ ^ nil ].	stack		allMorphsDo: [ :b | 			(b isCommandBlock and: [ b isHatBlock not ])				ifTrue: [ 1 to: b argumentCount do: [ :i | 						argM := b argumentAt: i.						((argM bounds intersects: aRectangle)							and: [ argM acceptsDroppedReporters ])							ifTrue: [ ^ argM ] ] ] ].	^ nil! !!ScratchScriptsMorph methodsFor: 'dropping/grabbing' stamp: 'EiichiroIto 11/23/2019 15:39'!wantsDroppedMorph: aMorph event: evt	^ aMorph isBlockMorph! !!ImageMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/23/2019 16:22'!fieldsVersion	^ 1! !!ImageMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/5/2018 21:06'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		form		"transparency"	) from: anObjStream.! !!ImageMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/5/2018 21:03'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		form		"transparency"	) on: anObjStream.! !!Cursor class methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/24/2019 22:14'!eyeDropper	^ CursorWithMask derivedFrom: (((Smalltalk ui icons iconNamed: #eyeDropper) scaledIntoFormOfSize: 16) offset: 0@ -14)! !!ZnBufferedWriteStream methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/13/2019 16:56'!uint24: integer	^ self nextIntegerOfSize: 3 signed: false bigEndian: true put: integer! !!BlockMorph class methodsFor: 'class initialization' stamp: 'EiichiroIto 9/30/2016 13:19'!initialize	"self initialize"	LabelColor := Color white.	PuzzleInset := 11.	PuzzleWidth := 14.	CBlockBracketThickness := 12.	DebugMenu := true! !!BlockMorph class methodsFor: 'class initialization' stamp: 'jm 6/20/2007 19:06'!setLabelFont	"BlockMorph setLabelFont"	| menu fName fSize |	menu := CustomMenu new.	StrikeFont fontNames do: [:fn | menu add: fn action: fn].	menu addLine.	menu add: 'normal' action: #normal.	(fName := menu startUp) ifNil: [^ self].	#normal = fName ifTrue: [		LabelFont := StrikeFont fontName: 'VerdanaBoldNarrowSpace' size: 10.		^ self].	menu := CustomMenu new.	(StrikeFont sizesForFontName: fName) do: [:sz | menu add: sz printString action: sz].	(fSize := menu startUp) ifNil: [^ self].	LabelFont := StrikeFont fontName: fName size: fSize.! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'EiichiroIto 11/21/2019 11:23'!aboutToBeGrabbedBy: aHandMorph	"If I'm being used as an argument, replace myself with an appropriate argument morph. Copied from WatcherMorph."	| m |	owner ifNil: [ ^ self ].	owner isCommandBlock		ifFalse: [ ^ self ].	"if I was being used as argument, replace myself with a generic argument morph"	m := owner argMorphToReplace: self.	m ifNil: [ ^ self ].	owner replaceArgMorph: self by: m! !!BlockMorph methodsFor: 'accessing' stamp: 'md 12/8/2004 01:00'!acceptsDroppedReporters	^ true! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 3/28/2005 19:20'!acceptsTypeOf: aBlockMorph	"Answer true if I can accept a dropped reporter of the given type. Answer false by default."	^ false! !!BlockMorph methodsFor: 'accessing' stamp: 'ee 2/21/2009 14:40'!addCopyTooltip: aMorph	copyTooltip := aMorph.	self addMorph: copyTooltip.! !!BlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/21/2019 22:23'!applicationDo: aBlock	^ self project ifNotNil: [ :p | aBlock value: p application ]! !!BlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 17:03'!attachBlock: aBlockMorph	"Attach the given block to me. Assume the block has been positioned correctly."	self addMorph: aBlockMorph.! !!BlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/22/2019 10:06'!blockAttachPoints: aSet	"Answer a collection of possible attachment points for me. Each entry is an Association mapping a point to the morph to which a dropping command block could be attached."	| nextB result |	result := #().	self isHatBlock		ifFalse: [ result := result copyWith: self topLeft -> self ].	nextB := self nextBlock.	nextB		ifNil: [ self isStopOrForever				ifFalse: [ result := result copyWith: self bottomLeft -> self ] ].	nextB ifNotNil: [ nextB blockAttachPoints: aSet ].	aSet addAll: result! !!BlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 20:50'!blockID	"answer a temporary (!!) id for the receiver	which can be used for tuple conversion of	sticky comments"	| sm |	sm := self script.	sm ifNil: [ ^ nil ].	^ sm blockIDOf: self! !!BlockMorph methodsFor: 'block enumerating' stamp: 'jm 12/8/2002 19:22'!blockSequence	"Answer the sequence of blocks starting with myself. Each block is a submorph of the previous block."	| result this |	result := OrderedCollection new: 20.	this := self.	[this isNil] whileFalse: [		result addLast: this.		this := this nextBlock].	^ result asArray! !!BlockMorph methodsFor: 'block enumerating' stamp: 'EiichiroIto 11/21/2019 17:59'!bottomBlock	"Answer the bottom Block of this stack. The top block may be a CommandBlockMorph, or perhaps some other kind of BlockMorph."	| m obj |	m := self.	[ obj := m nextBlock.	obj ifNil: [ ^ m ].	obj isBlockMorph ] whileTrue: [ m := m nextBlock ].	^ m! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 6/26/2006 09:51'!canBecomeWatcher	"Answer true if this block can become a watcher when dropped onto the stage. False by default."	^ false! !!BlockMorph methodsFor: 'drawing-optimization' stamp: 'jm 12/4/2006 13:56'!changed	"Don't flush my cachedForm when I do 'self changed'."	owner ifNotNil: [owner invalidRect: (self fullBounds expandBy: 3)].! !!BlockMorph methodsFor: 'processes' stamp: 'jm 6/4/2009 13:25'!clearProcess	"Called on the top block of a running stack when all processes are stopped."	scratchProc ifNotNil: [self scratchProc: nil].! !!BlockMorph methodsFor: 'event handling' stamp: 'EiichiroIto 10/5/2018 21:26'!click: evt	"If a tool is selected, handle a click with that tool. Otherwise, toggle my process."	self topBlock toggleProcess.! !!BlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/22/2019 15:32'!closestAttachTargetIn: newOwner	"Answer the closest block attachment point among the blocks and stack submorphs of the given morph. Answer nil if there are no blocks close enough to attach myself to."	| xThresh yThresh attachPoints best bestDist targetP dist ref topUsed bottomUsed |	xThresh := 65.	((self isKindOf: CBlockMorph) and: [(self nestedBlockAt: (self top + self topBarHeight)) isNil])		ifTrue: [yThresh := 25]		ifFalse: [yThresh := 14].	topUsed := false.	bottomUsed := false.	attachPoints := OrderedCollection new:100.	newOwner submorphsDo: [:m |		((m ~~ self) and:		 [(m ~~ (self bottomBlock)) and:		 [(m ~~ (self topBlock)) and:		 [(m ~~ (self owner)) and:		 [(m isKindOf: BlockMorph) and:		 [m isReporter not]]]]]) ifTrue: [			m blockAttachPoints: attachPoints]].	((self isKindOf: HatBlockMorph) or: [(self meOrOwnerThatIsA: HatBlockMorph) ~= nil]) ifTrue: [		"if I am a HatBlock or the bottom block of a HatBlock stack, I can only attach to the top block of a stack"		attachPoints := attachPoints select: [:assoc |			(assoc value owner = newOwner) and:			[assoc key y = assoc value top]]].	(self isStop or:[self bottomBlock isStop]) ifTrue: [		"I am a stop block; I can't attach to the top of a stack"		attachPoints := attachPoints select: [:assoc |			assoc key y ~= assoc value top]].	(self topBlock isForever not and: [self bottomBlock isForever]) ifTrue: [		"My bottom block is a forever; I can't attach to the top of a stack"		attachPoints := attachPoints select: [:assoc |			assoc key y ~= assoc value top]].	best := nil.	bestDist := 10000.	attachPoints do: [:assoc |		targetP := assoc key.		ref := self left.		((ref - targetP x) abs < xThresh)			ifTrue: [				(((self top - targetP y) abs < yThresh) or: [self nextBlock isNil and: [(self bottom - targetP y) abs < yThresh]])					ifTrue: [  "targetP is within sticking range"						dist := (self position - targetP) r.						dist < bestDist ifTrue: [							((self top - targetP y) abs < yThresh) ifTrue: [topUsed := true. bottomUsed := false].							(self nextBlock isNil and: [(self bottom - targetP y) abs < yThresh]) ifTrue: [topUsed := false. bottomUsed := true].							best := assoc.							bestDist := dist]]]].	"special case for the auto-wrapping of c-shaped/if-else blocks"	(self isKindOf: CBlockMorph) ifTrue: [	best ifNotNil: [		bottomUsed ifTrue: [				(best value owner isKindOf: BlockMorph) ifTrue: [				self stretchHeight: 0. ^ best := nil]].		(self isStopOrForever or:[self bottomBlock isStopOrForever]) ifTrue: [			bottomUsed ifTrue: [					self stretchHeight: 0.					^ best := nil]].		((best key y = best value top) and: [((self isForever or:[self bottomBlock isForever])) and: [(self nestedBlockAt: (best key y)) isNil not]])					ifTrue: [self stretchHeight: 0. ^ best := nil].		(self nestedBlockAt: (best key y)) ifNil: [			bottomUsed ifTrue: [					self stretchHeight: 0.					(best key y = best value bottom) ifTrue: [^ best := nil].					((best key y = best value top) and: [(best value owner isKindOf: BlockMorph)]) ifTrue: [^ best := nil].					((best key y = best value bottom) and: [(best value owner isKindOf: BlockMorph) not]) ifTrue: [^ best := nil]].			topUsed ifTrue: [				((best key y = best value bottom) and: [best value nextBlock isNil not]) ifTrue: [self stretchHeight: 0. ^ best := nil].				"((best key y = best value top) and: [(best value owner isKindOf: BlockMorph)]) ifTrue: [self stretchHeight: 0. ^ best := nil]."				(best key y = best value top) ifTrue: [self stretchHeight: best value fullBounds height - 17. ^ best]].			self stretchHeight: 0]].	best ifNil: [		self stretchHeight: 0]].	 ^ best! !!BlockMorph methodsFor: 'accessing' stamp: 'DaveF 8/4/2003 15:07'!color: aColor	"Remember the color of this block, for lighting-up purposes."	super color: aColor.	oldColor := aColor.! !!BlockMorph methodsFor: 'private' stamp: 'jm 3/29/2009 12:58'!commentLayoutChanged	lastLayoutTime := Time millisecondClockValue.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 3/30/2005 07:32'!computeHighlightColors	| h s v |	h := color hue.	s := color saturation.	v := color brightness.	highlightColor1 := Color h: h s: (s - 0.13) v: (v + 0.1).	highlightColor2 := Color h: h s: s v: (v + 0.07).	shadowColor := color mixed: 0.7 with: Color black.! !!BlockMorph methodsFor: 'private' stamp: 'md 6/10/2004 17:24'!copyRecordingIn: aDict		^ (super copyRecordingIn: aDict) clearProcess.	! !!BlockMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/24/2019 09:25'!delete	self topBlock stop.	SpScratchApp putInClipboard: self.	super delete! !!BlockMorph methodsFor: 'event handling' stamp: 'jm 12/30/2008 18:10'!doubleClick: evt	"If I'm a block with a receiver that's in a Scratch window, execute me."	self topBlock toggleProcess.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 3/30/2005 07:31'!drawBodyOn: aCanvas 	aCanvas		fillRectangle: (self left@(self top + 5) corner: (self right - 1)@(self bottom - 7))		color: color.	aCanvas		fillRectangle: (self left@(self top + 2) corner: (self left + 2)@(self bottom - 7))		color: highlightColor2.	aCanvas		fillRectangle: ((self right - 1)@(self top + 3) corner: self right@(self bottom - 7))		color: shadowColor.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 3/30/2005 07:31'!drawBottomEdgeOn: aCanvas	| right y gapStart gapEnd |	right := self width - 1.	y := self height - 7.	gapStart := PuzzleInset.	gapEnd := PuzzleInset + PuzzleWidth.	self drawHLineFrom: 1 to: right - 1 y: y color: color on: aCanvas.	self drawHLineFrom: 2 to: right - 2 y: y + 1 color: color on: aCanvas.	self drawHLineFrom: gapStart to: gapEnd y: y + 2 color: color on: aCanvas.	self drawHLineFrom: gapStart + 1 to: gapEnd - 1 y: y + 3 color: color on: aCanvas.	self drawHLineFrom: gapStart + 1 to: gapEnd - 1 y: y + 4 color: color on: aCanvas.	self drawHLineFrom: gapStart + 2 to: gapEnd - 2 y: y + 5 color: color on: aCanvas.	self drawHLineFrom: 3 to: gapStart y: y + 2 color: shadowColor on: aCanvas.	self drawHLineFrom: gapEnd to: right - 2 y: y + 2 color: shadowColor on: aCanvas.	self drawHLineFrom: gapStart + 2 to: gapEnd - 2 y: y + 6 color: shadowColor on: aCanvas.	self drawPoint: gapStart@(y + 3) color: shadowColor on: aCanvas.	self drawPoint: gapStart@(y + 4) color: shadowColor on: aCanvas.	self drawPoint: (gapStart + 1)@(y + 5) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 1)@(y + 3) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 1)@(y + 4) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 2)@(y + 5) color: shadowColor on: aCanvas.	self drawPoint: (right - 1)@y color: shadowColor on: aCanvas.	self drawPoint: (right - 2)@(y + 1) color: shadowColor on: aCanvas.! !!BlockMorph methodsFor: 'drawing' stamp: 'EiichiroIto 11/22/2019 10:09'!drawFinalOn: aCanvas fromCanvas: c	aCanvas paintImage: c form at: self topLeft! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 3/25/2005 16:52'!drawHLineFrom: startX to: endX y: yOffset color: c on: aCanvas	| y |	y := self top + yOffset.	aCanvas		fillRectangle: ((self left + startX)@y corner: (self left + endX)@(y + 1))		color: c.! !!BlockMorph methodsFor: 'drawing' stamp: 'ee 3/5/2008 15:41'!drawOn: aCanvas 	| c |	self computeHighlightColors.	c := FormCanvas extent: self extent depth: 32.	c := c copyOffset: self topLeft negated.	self isReporter ifTrue: [		self drawSmoothTopEdgeOn: c.		self drawReporterBodyOn: c.		self drawSmoothBottomEdgeOn: c.		^ self].	self isStop ifTrue: [		self drawTopEdgeOn: c.		self drawStopBodyOn: c.		self drawSmoothBottomEdgeOn: c.		self drawFinalOn: aCanvas fromCanvas: c.		^ self].	self drawTopEdgeOn: c.	self drawBodyOn: c.	self drawBottomEdgeOn: c.	self drawFinalOn: aCanvas fromCanvas: c.! !!BlockMorph methodsFor: 'drawing' stamp: 'EiichiroIto 9/15/2016 17:41'!drawPoint: aPoint color: c on: aCanvas	aCanvas fillRectangle: (self topLeft + aPoint extent: (1@1)) color: c.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 3/30/2005 07:31'!drawReporterBodyOn: aCanvas 	aCanvas		fillRectangle: (self left@(self top + 3) corner: (self right - 1)@(self bottom - 3))		color: color.	aCanvas		fillRectangle: (self left@(self top + 2) corner: (self left + 2)@(self bottom - 3))		color: highlightColor2.	aCanvas		fillRectangle: ((self right - 1)@(self top + 2) corner: self right@(self bottom - 3))		color: shadowColor.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 3/30/2005 07:31'!drawSmoothBottomEdgeOn: aCanvas	| right y |	right := self width - 1.	y := self height - 3.	self drawHLineFrom: 1 to: right - 1 y: y color: color on: aCanvas.	self drawHLineFrom: 2 to: right - 2 y: y + 1 color: color on: aCanvas.	self drawHLineFrom: 3 to: right - 2 y: y + 2 color: shadowColor on: aCanvas.	self drawPoint: (right - 1)@y color: shadowColor on: aCanvas.	self drawPoint: (right - 2)@(y + 1) color: shadowColor on: aCanvas.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 3/26/2005 12:12'!drawSmoothTopEdgeOn: aCanvas	| right |	right := self width - 1.	self drawHLineFrom: 2 to: right - 2 y: 0 color: highlightColor1 on: aCanvas.	self drawHLineFrom: 1 to: right - 1 y: 1 color: highlightColor2 on: aCanvas.	self drawHLineFrom: 0 to: right y: 2 color: color on: aCanvas.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 4/15/2007 19:40'!drawStopBodyOn: aCanvas 	aCanvas		fillRectangle: (self left@(self top + 5) corner: (self right - 1)@(self bottom - 3))		color: color.	aCanvas		fillRectangle: (self left@(self top + 2) corner: (self left + 2)@(self bottom - 3))		color: highlightColor2.	aCanvas		fillRectangle: ((self right - 1)@(self top + 2) corner: self right@(self bottom - 3))		color: shadowColor.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 3/26/2005 13:22'!drawTopEdgeOn: aCanvas	| right gapStart gapEnd |	right := self width - 1.	gapStart := PuzzleInset.	gapEnd := PuzzleInset + PuzzleWidth.	self drawHLineFrom: 2 to: gapStart y: 0 color: highlightColor1 on: aCanvas.	self drawHLineFrom: gapEnd to: right - 2 y: 0 color: highlightColor1 on: aCanvas.	self drawHLineFrom: 1 to: gapStart y: 1 color: highlightColor2 on: aCanvas.	self drawHLineFrom: gapEnd to: right - 1 y: 1 color: highlightColor2 on: aCanvas.	self drawHLineFrom: 0 to: gapStart + 1 y: 2 color: color on: aCanvas.	self drawHLineFrom: gapEnd - 1 to: right y: 2 color: color on: aCanvas.	self drawHLineFrom: 0 to: gapStart + 2 y: 3 color: color on: aCanvas.	self drawHLineFrom: gapEnd - 2 to: right y: 3 color: color on: aCanvas.	self drawHLineFrom: 0 to: right y: 4 color: color on: aCanvas.	self drawHLineFrom: gapStart + 2 to: gapEnd - 2 y: 4 color: highlightColor1 on: aCanvas.! !!BlockMorph methodsFor: 'event handling' stamp: 'EiichiroIto 10/10/2018 23:07'!duplicate	"self world activeHand attachMorph: self fullCopy."	self world activeHand attachMorph: super duplicate.! !!BlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/15/2018 07:09'!emitCode: aGenerator indent: indent	aGenerator emitBlock: self indent: indent.! !!BlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:51'!fieldsVersion	^ 1! !!BlockMorph methodsFor: 'block enumerating' stamp: 'jm 6/22/2004 18:17'!firstBlockList	"If I am a control block, answer an array containing the block sequences for my first nested block (i.e., the blocks for the 'true' case of an if-then-else block). If I'm not a control structure block, just answer an empty array."	^ #()! !!BlockMorph methodsFor: 'private' stamp: 'jm 11/28/2006 20:28'!fixBlockLayout	"This default implementation just clears my cached forms."	blockLayoutNeeded ifFalse: [^ self].	cachedForm := nil.	cachedFeedbackForm := nil.! !!BlockMorph methodsFor: 'drawing-optimization' stamp: 'jm 11/30/2006 21:42'!fullBounds	"This is the hook that triggers lazy re-layout. It works because layoutChanged clears the fullBounds cache. Once per cycle, the fullBounds is requested from every morph in the world, and that request gets propagated through the entire submorph hierarchy, causing re-layout where needed. Note that multiple layoutChanges to the same morph can be done with little cost, since the layout is only done when the morph needs to be displayed."	"Detail: Expands by 3 pixels if I have a process to allow for the running/error feedback."	fullBounds ifNil: [		"do layout here"		blockLayoutNeeded ifTrue: [			super fullBounds.			self fixBlockLayout.			fullBounds := nil.			super fullBounds.  "recompute after layout"			self changed].		blockLayoutNeeded := false].	scratchProc ifNotNil: [^ super fullBounds expandBy: 3].  "allow for running/error feedback"	^ super fullBounds! !!BlockMorph methodsFor: 'drawing-optimization' stamp: 'EiichiroIto 11/21/2019 17:54'!fullDrawOn: aCanvas	"Optimization: To speed up redisplay, especially when giving feedback that a stack is running, we create a cached form of the stack in the top block of the stack and simply display that. We also keep a cached image of the running/error feedback outline. This allows the running feedback to be turned on and off quickly. The caches are flushed whenever the layout of the stack changes."	| offset |	self visible ifFalse: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^ self drawErrorOn: aCanvas].	(owner isBlockMorph) ifTrue: [^ super fullDrawOn: aCanvas].  "only cache at top level"	cachedForm ifNil: [self updateCachedForm].	cachedForm ifNil: [^ super fullDrawOn: aCanvas].  "should not happen"	offset := 0@0.	scratchProc ifNotNil: [		offset := 3@3.		cachedFeedbackForm ifNil: [self updateCachedFeedbackForm].		cachedFeedbackForm ifNotNil: [			aCanvas paintImage: cachedFeedbackForm at: self fullBounds topLeft]].	aCanvas paintImage: cachedForm at: self fullBounds topLeft + offset.! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'EiichiroIto 11/23/2019 15:48'!handleReporterDrop	"This block, a reporter, has just been dropped. Try to embed it in a command block."	| scriptsMorph argM argOwner |	(self isReporter and: [owner isKindOf: ScratchScriptsMorph]) ifFalse: [^ self].	scriptsMorph := owner.	argM := owner topArgMorphAt: self bounds exclude: self.	(argM notNil and: [argM acceptsTypeOf: self]) ifFalse: [^ self].	(argM isBlockMorph)		ifTrue: [			argOwner := argM owner.			argOwner replaceArgMorph: argM by: self.			scriptsMorph addMorph: argM.			argM position: (argOwner left+90)@(argM top - 20)]		ifFalse: [			argM owner replaceArgMorph: argM by: self].! !!BlockMorph methodsFor: 'event handling' stamp: 'jm 8/13/2003 10:22'!handlesMouseDown: evt	^ true! !!BlockMorph methodsFor: 'processes' stamp: 'jm 6/4/2009 13:01'!hasRunningProcess	^ scratchProc notNil and: [scratchProc isRunning]! !!BlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:52'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		isSpecialForm		oldColor	) from: anObjStream.! !!BlockMorph methodsFor: 'initialization' stamp: 'jm 6/4/2009 13:16'!initialize	super initialize.	blockLayoutNeeded := true.	isSpecialForm := false.	color := Color r: 0.4 g: 0.7 b: 0.8.	oldColor := color.	scratchProc := nil.	hadError := false.	lastLayoutTime := 0.! !!BlockMorph methodsFor: 'drawing-optimization' stamp: 'jm 12/4/2006 13:55'!invalidRect: damageRect	"Flush my cachedForm if some submorph reports a change."	super invalidRect: (damageRect expandBy: 3).  "allows for running feedback"	cachedForm := nil.! !!BlockMorph methodsFor: 'testing' stamp: 'jm 12/9/2008 17:35'!isBlockMorph	"True only for BlockMorphs."	^ true! !!BlockMorph methodsFor: 'testing' stamp: 'jm 3/28/2005 19:14'!isBooleanReporter	"Answer true if this block reports a boolean value. Answer false by default."	^ false! !!BlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 11:12'!isCBlock	^ false! !!BlockMorph methodsFor: 'testing' stamp: 'jm 4/15/2007 20:02'!isForever	"True only for forever command blocks."	^ false! !!BlockMorph methodsFor: 'testing' stamp: 'jm 12/21/2008 12:21'!isHatBlock	^ false! !!BlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 11:12'!isIfElseBlock	^ false! !!BlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 12:43'!isInBlockPalette	owner ifNil: [ ^ false ].	owner isBlockPalette ifTrue: [ ^ true ].	owner isScriptEditor ifTrue: [ ^ false ].	^ owner isInBlockPalette! !!BlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 08:31'!isInScriptEditor	owner ifNil: [ ^ false ].	owner isScriptEditor ifTrue: [ ^ true ].	^ owner isInScriptEditor! !!BlockMorph methodsFor: 'testing' stamp: 'jm 6/26/2006 09:45'!isReporter	"Answer true if this block reports a value. False by default."	^ false! !!BlockMorph methodsFor: 'testing' stamp: 'DaveF 7/11/2003 00:41'!isSpecialForm	^isSpecialForm.! !!BlockMorph methodsFor: 'testing' stamp: 'DaveF 7/10/2003 17:39'!isSpecialForm: aBoolean	"Sets a flag indicating that this block has a special evaluation rule."	isSpecialForm := aBoolean.! !!BlockMorph methodsFor: 'testing' stamp: 'jm 4/15/2007 11:49'!isStop	"True for only stop command blocks."	^ false! !!BlockMorph methodsFor: 'testing' stamp: 'jm 4/15/2007 20:02'!isStopOrForever	"True for stop or forever command blocks."	^ self isStop or: [self isForever]! !!BlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 11:16'!isVariableBlock	^ false! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'EiichiroIto 11/22/2019 15:34'!justDroppedInto: newOwner event: evt	"Handle being dropped into a new situation."	| project targetAssoc targetP targetBlock bottomBlockUsed upperBlock |	bottomBlockUsed := false.	"blocks cannot be dropped onto the stage"	owner isWorldMorph		ifTrue: [ self delete.			self receiver blocksBin changed.			^ self ].	(project := newOwner project) ifNotNil: [ project modified: true ].	"delete myself when dropped in the blocks palette area"	self isInBlockPalette		ifTrue: [ self delete.			self receiver blocksBin changed.			^ self ].	"okay to drop blocks into the world during development"	"((owner == World) and: [Preferences noviceMode not]) ifTrue: [^ self]."	(owner isScriptEditor		or: [ owner isBlockMorph or: [ self isReporter ] ])		ifFalse: [ ^ self rejectDropEvent: evt ].	self isReporter		ifTrue: [ ^ self handleReporterDrop ].	targetAssoc := self closestAttachTargetIn: newOwner.	targetAssoc		ifNil: [ self bottomBlock isCBlock				ifFalse: [ targetAssoc := self bottomBlock closestAttachTargetIn: newOwner.					targetAssoc						ifNotNil: [ bottomBlockUsed := true.							targetAssoc value owner isBlockMorph								ifTrue: [ targetAssoc := nil ] ] ] ].	targetAssoc ifNil: [ ^ self ].	"make sure no processes are running"	self = self topBlock		ifTrue: [ self stop ].	targetP := targetAssoc key.	targetBlock := targetAssoc value.	targetP y = targetBlock top		ifTrue: [ "c-shaped block should nest the target block"			"((bottomBlockUsed not) and: [((targetBlock owner isKindOf: BlockMorph) not) and: [(self isKindOf: CBlockMorph)]]) ifTrue:["			(bottomBlockUsed not and: [ self isCBlock ])				ifTrue: [ targetBlock owner isBlockMorph						ifTrue: [ targetBlock owner attachBlock: self ]						ifFalse: [ self								position:									(targetP x - self bracketThickness)										@ (targetP y - self topBarHeight - 3) ].					self attachBlockNested: targetBlock.					^ self ].			"for all other non-c-shaped blocks"			(bottomBlockUsed				or: [ targetBlock owner isBlockMorph not and: [ self isCBlock not ] ])				ifTrue: [ self bottomBlock						position: targetP x @ (targetP y - (self bottomBlock height - 4)).					upperBlock := self bottomBlock owner.					[ upperBlock isBlockMorph ]						whileTrue: [ upperBlock nextBlock								ifNotNil: [ upperBlock										position:											targetP x												@ (upperBlock nextBlock position y - (upperBlock height - 4)).									upperBlock := upperBlock owner ] ] ].			(bottomBlockUsed not and: [ targetBlock owner isBlockMorph ])				ifTrue: [ self position: targetP x @ (targetP y - (self height - 4)) ].			targetBlock owner isBlockMorph				ifTrue: [ self topBlock position: targetP x @ targetP y.					targetBlock owner attachBlock: self topBlock ].			targetBlock				position:					targetP x						@ (self bottomBlock position y + self bottomBlock height + 4).			(bottomBlockUsed not				and: [ targetBlock owner isBlockMorph not and: [ self isCBlock ] ])				ifFalse: [ self bottomBlock attachBlock: targetBlock ] ]		ifFalse: [ self assert: [ self isHatBlock not ].	"I am not a HatBlockMorph"			self position: targetP.			targetBlock attachBlock: self ]! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 3/28/2009 20:48'!lastLayoutTime	"Return the millisecond clock value the last time I was sent layoutChanged. This value can be used by other morphs to detect when layout changes have occured."	^ lastLayoutTime! !!BlockMorph methodsFor: 'private' stamp: 'jm 11/29/2006 12:15'!layoutChanged	blockLayoutNeeded ifFalse: [super layoutChanged].	blockLayoutNeeded := true.! !!BlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 10/5/2018 10:32'!litUp: aBoolean	"If the argument true, light up this block. Otherwise, revert to it's old color."	"Note: We use super color: so we don't overwrite oldColor. We also force a world update to ensure that the highlighting is seen by the user."	aBoolean		ifTrue:	[super color: (Color h: 60 s: 0.9 v: 0.89)]		ifFalse:	[oldColor ifNotNil: [super color: oldColor]].	"aBoolean ifTrue: [		World			cycleWhileWaitingMSecs: ScratchProcess blockHighlightMSecs			doInput: true			doSteps: false]."! !!BlockMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/23/2019 08:43'!mouseDown: evt	"Handle a mouse click. Left button either drags or performs click action. Right button brings up a menu."	evt hand newKeyboardFocus: nil.	evt yellowButtonPressed		ifTrue: [ Sensor waitNoButton.			^ self rightButtonMenu: evt ].	evt hand waitForClicksOrDrag: self event: evt! !!BlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 10/19/2019 17:21'!newScriptOwner: newOwner	"Update the receiver of all blocks to be the given morph. Used when moving scripts from one object to another."	| rcvr |	self allMorphsDo: [:m |		(m isKindOf: BlockMorph) ifTrue: [			rcvr := newOwner.			((m isKindOf: VariableBlockMorph) | (m isKindOf: SetterBlockMorph)) ifTrue: [				(m receiver isStageMorph) ifTrue: [rcvr := m receiver].				newOwner ensureVariableExists: m variable asString.  "ensure that variable exists"				m color: rcvr variableBlockColor].			m receiver: rcvr].		"(m isKindOf: CommandBlockMorph) ifTrue: [			m argMorphs do: [:arg |				((arg isKindOf: ChoiceArgMorph) and:				 [arg getOptionsSelector = #listVarMenu]) ifTrue: [					arg choice ifNotNil: [newOwner ensureListExists: arg choice]]]]."		"(m isKindOf: ListContentsBlockMorph) ifTrue: [			newOwner ensureListExists: m commandSpec]."		(m isKindOf: HatBlockMorph) ifTrue: [m scriptOwner: newOwner]].! !!BlockMorph methodsFor: 'block enumerating' stamp: 'EiichiroIto 11/21/2019 18:58'!nextBlock	"Answer the block myself in the block sequence or nil if I am the last block in the sequence. Each block is a submorph of the previous block."	^ self submorphs detect: [:m | m isBlockMorph] ifNone: [nil]! !!BlockMorph methodsFor: 'block enumerating' stamp: 'jm 3/26/2005 21:08'!nextBlock: aBlockMorph	"Add the given block to this stack."	self addMorph: aBlockMorph.! !!BlockMorph methodsFor: 'private' stamp: 'jm 11/29/2006 12:21'!nonControlFlowSubmorphs	"Answer a collection of submorphs minus any blocks that are part of the control flow. For example, command blocks omit their submorph that is the next block in the block sequence, C-blocks omit both their next block and the first block of their nested block list, etc."	^ submorphs select: [:m | (m ~~ self nextBlock)]! !!BlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/20/2019 06:17'!project	^ owner ifNotNil: [ owner project ]! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 4/19/2004 21:36'!receiver	"Overridden by blocks which have receivers."	^ nil! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 4/19/2004 19:19'!receiver: anObject	"Set my receiver. Does nothing here, but overridden in blocks that have a receiver." ! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'EiichiroIto 11/21/2019 12:51'!rejectDropEvent: evt	"Reject being dropped by the given event."	evt hand rejectDropMorph: self event: evt.! !!BlockMorph methodsFor: 'accessing' stamp: 'ee 2/21/2009 14:40'!removeCopyTooltip	copyTooltip delete.	copyTooltip := nil.! !!BlockMorph methodsFor: 'event handling' stamp: 'EiichiroIto 11/23/2019 13:33'!rightButtonMenu: anEvent	| menu |	owner isBlockPalette		ifTrue: [ ^ self ].	owner isBlockMorph		ifTrue: [ ^ self ].	menu := MenuMorph new.	menu target: self.	menu add: 'delete' selector: #delete.	menu localize.	menu popUpEvent: anEvent in: self world! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'jm 3/17/2003 17:59'!rootForGrabOf: aMorph	"Allow myself to be extracted."	(owner notNil and: [owner isPartsBin])		ifTrue: [^ super rootForGrabOf: aMorph]		ifFalse: [^ self].! !!BlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/21/2019 17:53'!rootMorph	owner ifNil: [ ^ self ].	^ self rootMorph! !!BlockMorph methodsFor: 'processes' stamp: 'jm 12/12/2004 14:10'!scratchProc	"Answer my process or nil if I'm not currently the top of a running stack."	^ scratchProc! !!BlockMorph methodsFor: 'processes' stamp: 'jm 6/4/2009 13:44'!scratchProc: aScratchProcess	hadError == true ifTrue: [cachedFeedbackForm := nil].	hadError := false.	scratchProc := aScratchProcess.	self changed.! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 6/4/2009 14:44'!showError	"Make this block to show an error."	super color: (Color r: 0.831 g: 0.156 b: 0.156).! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 6/4/2009 13:19'!showErrorFeedback	"Show that this stack encountered an error."	hadError := true.	cachedFeedbackForm := nil.	self changed.! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'EiichiroIto 9/29/2016 17:34'!slideBackToFormerSituation: evt	| wasEmbedded o pane oldP slideForm startPoint |	wasEmbedded := false.	(o := evt hand formerOwner) ifNil: [^ self].	(o isKindOf: BlockMorph) ifTrue: [		wasEmbedded := true.		(pane := o meOrOwnerThatIsA: ScratchScriptsMorph) ifNotNil: [			o := pane]].	oldP := evt hand formerPosition.	slideForm := self imageForm offset: 0@0.	startPoint := evt hand fullBounds origin.	owner privateRemoveMorph: self.	self world displayWorld.	slideForm slideFrom: startPoint to: oldP nSteps: 12 delay: 15.	self position: oldP.	o addMorph: self.	wasEmbedded ifTrue: [self justDroppedInto: o event: evt].! !!BlockMorph methodsFor: 'processes' stamp: 'jm 3/12/2004 04:19'!start	"Start a process running this block stack. This default implementation does nothing."! !!BlockMorph methodsFor: 'event handling' stamp: 'EiichiroIto 9/3/2019 21:26'!startDrag: evt	| rootForGrab point |	"evt hand toolType ifNil: ["		point := evt hand firstClickCursorPoint ifNil: [ evt cursorPoint ].		rootForGrab := self rootForGrabOf: self.		rootForGrab ifNil: [^ self].		evt hand grabMorph: rootForGrab.		rootForGrab position: evt hand position + (rootForGrab topLeft - point)		"]".	"self handleTool: evt hand toolType hand: evt hand"! !!BlockMorph methodsFor: 'processes' stamp: 'EiichiroIto 11/21/2019 22:24'!stop	self applicationDo: [ :app | app stopAllProcesses ]! !!BlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:17'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		isSpecialForm		oldColor	) on: anObjStream.! !!BlockMorph methodsFor: 'processes' stamp: 'EiichiroIto 11/21/2019 22:25'!toggleProcess	self		applicationDo: [ :app | 			app isProcessRunning				ifTrue: [ self stop ]				ifFalse: [ self start ] ]! !!BlockMorph methodsFor: 'block enumerating' stamp: 'jm 2/22/2004 15:03'!topBlock	"Answer the top Block of this stack. The top block may be a HatBlockMorph, a CommandBlockMorph, or perhaps some other kind of BlockMorph."	| m |	m := self.	[m owner isKindOf: BlockMorph] whileTrue: [m := m owner].	^ m! !!BlockMorph methodsFor: 'block enumerating' stamp: 'jm 3/23/2005 10:24'!tupleSequence	"Answer a sequence of tuples (Array) describing this stack of blocks."	^ self blockSequence collect: [:b | b asBlockTuple]! !!BlockMorph methodsFor: 'drawing-optimization' stamp: 'jm 11/29/2006 12:29'!updateCachedFeedbackForm	"Create a cached feedback Form to show this stack's running (or error) status."	| outlineColor |	cachedForm ifNil: [^ self].	outlineColor := (scratchProc notNil and: [scratchProc errorFlag])		ifTrue: [Color r: 0.831 g: 0.156 b: 0.156]		ifFalse: [Color gray: 0.953].	cachedFeedbackForm := cachedForm		outlineWidth: 3		color: outlineColor		depth: 8.! !!BlockMorph methodsFor: 'drawing-optimization' stamp: 'EiichiroIto 11/22/2019 10:10'!updateCachedForm	"Create a cached Form of this stack's appearance."	| c |	oldColor ifNotNil: [ color := oldColor ].	c := FormCanvas extent: self fullBounds extent depth: 32.	c := c copyOffset: self topLeft negated.	self drawOn: c.	self drawSubmorphsOn: c.	cachedForm := c form.	lastLayoutTime := Time millisecondClockValue! !!BlockMorph methodsFor: 'event handling' stamp: 'jm 10/20/2004 15:02'!wantsKeyboardFocusFor: aSubmorph	"Don't allow shift-click editing of block labels."	^ false! !!CBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 20:55'!addCommandIcons	"Add additional icons to certain blocks. Do nothing if this isn't one of those blocks."	| f |	super addCommandIcons.	(#(doForever doForeverIf doRepeat doUntil) includes: selector) ifTrue: [		f := ScratchTheme formAt: #loopIcon.		loopMorph := ImageMorph new form: f.		self addMorphBack: loopMorph].! !!CBlockMorph methodsFor: 'private' stamp: 'ee 2/28/2009 16:10'!asBlockTuple	"Answer a tuple (Array) describing this block and its arguments."	| blockTuple arg argList |	blockTuple := Array new: argMorphs size + 2.	blockTuple at: 1 put: selector.	argList := argMorphs.	argList := self organizeArgs: argList.	1 to: argList size do: [:i |		arg := argList at: i.		(arg isKindOf: ArgMorph)			ifTrue: [blockTuple at: i + 1 put: arg evaluate]			ifFalse: [blockTuple at: i + 1 put: arg asBlockTuple]].	nestedBlock		ifNil: [blockTuple at: blockTuple size put: nil]		ifNotNil: [blockTuple at: blockTuple size put: nestedBlock tupleSequence].	^ blockTuple! !!CBlockMorph methodsFor: 'private' stamp: 'jm 4/3/2005 16:01'!attachBlock: aBlockMorph	"Attach the given block to me. Assume the block has been positioned correctly."	self addMorph: aBlockMorph.	aBlockMorph top >= (self bottom - CBlockBracketThickness)		ifTrue: [nextBlock := aBlockMorph]		ifFalse: [nestedBlock := aBlockMorph].! !!CBlockMorph methodsFor: 'private' stamp: 'jens 8/29/2008 12:21'!attachBlockNested: aBlockMorph	"Attach the given block to me. Assume the block has been positioned correctly."	(stretchHeight = 0)			ifTrue: [self position: (aBlockMorph left)@(aBlockMorph top - self height + 4)].	self addMorph: aBlockMorph.	(stretchHeight = 0)		ifTrue: [self bottomBlock nextBlock: aBlockMorph]		ifFalse: [nestedBlock := aBlockMorph].! !!CBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/22/2019 13:11'!blockAttachPoints: aSet	"Answer a collection of possible attachment points for me. Each entry is an Association mapping a point to the morph to which a dropping command block could be attached."	| result |	result := #().	self isHatBlock		ifFalse: [ result := result copyWith: self topLeft -> self ].	nestedBlock		ifNil: [ result := result				copyWith: self topLeft + (12 @ (self topBarHeight + 7)) -> self ]		ifNotNil: [ nestedBlock blockAttachPoints: aSet ].	nextBlock		ifNil: [ self isStopOrForever				ifFalse: [ result := result copyWith: self bottomLeft -> self ] ]		ifNotNil: [ nextBlock blockAttachPoints: aSet ].	aSet addAll: result! !!CBlockMorph methodsFor: 'accessing' stamp: 'ee 7/11/2008 22:23'!bracketThickness	^ CBlockBracketThickness! !!CBlockMorph methodsFor: 'geometry' stamp: 'jm 3/29/2008 12:19'!containsPoint: aPoint	cachedForm ifNil: [self updateCachedForm].	^ (self fullBounds containsPoint: aPoint) and:	  [(cachedForm isTransparentAt: aPoint - self fullBounds origin) not]! !!CBlockMorph methodsFor: 'drawing' stamp: 'jm 4/15/2007 20:05'!drawBottomBarOn: aCanvas 	| left barTop barBottom |	self isForever		ifTrue: [			barBottom := self bottom - 3.			self drawSmoothBottomEdgeOn: aCanvas]		ifFalse: [			barBottom := self bottom - 7.			self drawBottomEdgeOn: aCanvas].	barTop := barBottom - (CBlockBracketThickness - 3).	left := self left + CBlockBracketThickness - 1.	"fill in bottom-left corner"	aCanvas fillRectangle: (left@(barTop - 2) extent: 1@1) color: color.	aCanvas fillRectangle: (left@(barTop - 1) extent: 2@1) color: color.	aCanvas fillRectangle: (left@barTop extent: 3@1) color: color.	aCanvas		fillRectangle: ((left + 3)@barTop corner: (self right - 2)@(barTop + 1))		color: highlightColor1.	aCanvas		fillRectangle: (left@(barTop + 1) corner: (self right - 1)@barBottom)		color: color.	aCanvas		fillRectangle: ((self right - 1)@(barTop + 2) corner: self right@barBottom)		color: shadowColor.! !!CBlockMorph methodsFor: 'drawing' stamp: 'jm 12/14/2005 17:20'!drawInnerTopY: y on: aCanvas	| left right gapStart gapEnd |	left := CBlockBracketThickness - 1.	right := self width - 1.	gapStart := left + PuzzleInset + 1.	gapEnd := gapStart + PuzzleWidth.	self drawHLineFrom: left to: (right - 1) y: y color: color on: aCanvas.	self drawHLineFrom: left to: (right - 2) y: y + 1 color: color on: aCanvas.	"fill in upper-left inside corner"	self drawHLineFrom: left to: (left + 2) y: y + 2 color: color on: aCanvas.	self drawHLineFrom: left to: (left + 1) y: y + 3 color: color on: aCanvas.	self drawPoint: (left + 1)@(y + 3) color: shadowColor on: aCanvas.	self drawHLineFrom: gapStart to: gapEnd y: y + 2 color: color on: aCanvas.	self drawHLineFrom: gapStart + 1 to: gapEnd - 1 y: y + 3 color: color on: aCanvas.	self drawHLineFrom: gapStart + 1 to: gapEnd - 1 y: y + 4 color: color on: aCanvas.	self drawHLineFrom: gapStart + 2 to: gapEnd - 2 y: y + 5 color: color on: aCanvas.	self drawHLineFrom: (left + 2) to: gapStart y: y + 2 color: shadowColor on: aCanvas.	self drawHLineFrom: gapEnd to: right - 2 y: y + 2 color: shadowColor on: aCanvas.	self drawHLineFrom: gapStart + 2 to: gapEnd - 2 y: y + 6 color: shadowColor on: aCanvas.	self drawPoint: gapStart@(y + 3) color: shadowColor on: aCanvas.	self drawPoint: gapStart@(y + 4) color: shadowColor on: aCanvas.	self drawPoint: (gapStart + 1)@(y + 5) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 1)@(y + 3) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 1)@(y + 4) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 2)@(y + 5) color: shadowColor on: aCanvas.	self drawPoint: (right - 1)@y color: shadowColor on: aCanvas.	self drawPoint: (right - 2)@(y + 1) color: shadowColor on: aCanvas.! !!CBlockMorph methodsFor: 'drawing' stamp: 'ee 3/5/2008 16:15'!drawOn: aCanvas 	| c |	topBarBottom := self top + self topBarHeight.	self isForever		ifTrue: [blockBottom := self bottom - 3]		ifFalse: [blockBottom := self bottom - 7].	self computeHighlightColors.	c := FormCanvas extent: self extent depth: 32.	c := c copyOffset: self topLeft negated.	self drawTopEdgeOn: c.	self drawTopBarOn: c.	self drawVerticalBarOn: c.	self drawBottomBarOn: c.	self drawFinalOn: aCanvas fromCanvas: c.! !!CBlockMorph methodsFor: 'drawing' stamp: 'jm 3/30/2005 10:07'!drawTopBarOn: aCanvas 	| left right y gapStart gapEnd |	aCanvas		fillRectangle: (self left@(self top + 5) corner: (self right - 1)@topBarBottom)		color: color.	aCanvas		fillRectangle: ((self right - 1)@(self top + 3) corner: self right @topBarBottom)		color: shadowColor.	left := CBlockBracketThickness - 1.	right := self width - 1.	y := topBarBottom - self top.	gapStart := left + PuzzleInset + 1.	gapEnd := gapStart + PuzzleWidth.	self drawHLineFrom: left to: (right - 1) y: y color: color on: aCanvas.	self drawHLineFrom: left to: (right - 2) y: y + 1 color: color on: aCanvas.	"fill in upper-left inside corner"	self drawHLineFrom: left to: (left + 2) y: y + 2 color: color on: aCanvas.	self drawHLineFrom: left to: (left + 1) y: y + 3 color: color on: aCanvas.	self drawPoint: (left + 1)@(y + 3) color: shadowColor on: aCanvas.	self drawHLineFrom: gapStart to: gapEnd y: y + 2 color: color on: aCanvas.	self drawHLineFrom: gapStart + 1 to: gapEnd - 1 y: y + 3 color: color on: aCanvas.	self drawHLineFrom: gapStart + 1 to: gapEnd - 1 y: y + 4 color: color on: aCanvas.	self drawHLineFrom: gapStart + 2 to: gapEnd - 2 y: y + 5 color: color on: aCanvas.	self drawHLineFrom: (left + 2) to: gapStart y: y + 2 color: shadowColor on: aCanvas.	self drawHLineFrom: gapEnd to: right - 2 y: y + 2 color: shadowColor on: aCanvas.	self drawHLineFrom: gapStart + 2 to: gapEnd - 2 y: y + 6 color: shadowColor on: aCanvas.	self drawPoint: gapStart@(y + 3) color: shadowColor on: aCanvas.	self drawPoint: gapStart@(y + 4) color: shadowColor on: aCanvas.	self drawPoint: (gapStart + 1)@(y + 5) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 1)@(y + 3) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 1)@(y + 4) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 2)@(y + 5) color: shadowColor on: aCanvas.	self drawPoint: (right - 1)@y color: shadowColor on: aCanvas.	self drawPoint: (right - 2)@(y + 1) color: shadowColor on: aCanvas.! !!CBlockMorph methodsFor: 'drawing' stamp: 'jm 3/30/2005 07:31'!drawVerticalBarOn: aCanvas 	| left top barRight |	left := self left.	barRight := (left + CBlockBracketThickness) - 1.	top := self top.		aCanvas		fillRectangle: (left@(top + 5) corner: barRight@blockBottom)		color: color.	aCanvas		fillRectangle: (left@(top + 2) corner: (left + 2)@blockBottom)		color: highlightColor2.	aCanvas		fillRectangle: (barRight@(topBarBottom + 4) corner: (barRight + 1)@blockBottom)		color: shadowColor.! !!CBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/15/2018 07:12'!emitCode: aGenerator indent: indent	aGenerator emitCBlock: self indent: indent.! !!CBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:04'!fieldsVersion	^ 1! !!CBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 12:11'!firstBlockList	"Answer an array containing the block sequence for my first (and only) nested block. (An if-then-else block would have a second block list.)"	nestedBlock		ifNil: [^ #()]		ifNotNil: [^ nestedBlock blockSequence].! !!CBlockMorph methodsFor: 'private' stamp: 'jm 3/23/2005 18:08'!firstBlockList: aBlockMorph	"Add the given block as my first nested block sequence. Delete the old nested blocks, if any."	nestedBlock ifNotNil: [nestedBlock delete].	nestedBlock := aBlockMorph.	aBlockMorph ifNotNil: [self addMorph: aBlockMorph].! !!CBlockMorph methodsFor: 'drawing' stamp: 'EiichiroIto 11/22/2019 13:13'!fixBlockLayout	"Update the positions of my submorphs."	| oldExtent newW newH f |	blockLayoutNeeded		ifFalse: [ ^ self ].	super fixBlockLayout.	"fix nestedBlock and nextBlock in case they've been removed from me"	(nestedBlock notNil and: [ nestedBlock owner ~~ self ])		ifTrue: [ nestedBlock := nil ].	(nextBlock notNil and: [ nextBlock owner ~~ self ])		ifTrue: [ nextBlock := nil ].	oldExtent := self extent.	newW := oldExtent x max: 40.	newH := self topBarHeight + CBlockBracketThickness.	self isForever		ifFalse: [ newH := newH + 4 ].	nestedBlock		ifNil: [ newH := newH + 14 ]		ifNotNil: [ stretchHeight := 0.			nestedBlock fixBlockLayout.			newH := newH + nestedBlock fullBounds height - 1.			nestedBlock				position: self position + (CBlockBracketThickness @ (self topBarHeight + 3)).			nestedBlock blockSequence last isStopOrForever				ifTrue: [ newH := newH + 4 ] ].	self extent: newW @ newH + (0 @ stretchHeight).	"position loop morph"	loopMorph		ifNotNil: [ f := ScratchTheme formAt: #loopIcon.			loopMorph form: f.			self isForever				ifTrue: [ loopMorph position: self bottomRight - loopMorph extent - (4 @ 2) ]				ifFalse: [ loopMorph position: self bottomRight - loopMorph extent - (4 @ 6) ] ].	nextBlock		ifNotNil: [ nextBlock position: self left @ (self bottom - 4) ]! !!CBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:05'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		nestedBlock		nextBlock	) from: anObjStream.! !!CBlockMorph methodsFor: 'initialization' stamp: 'ee 7/10/2008 13:19'!initialize	super initialize.	self color: (Color r: 1.0 g: 0.581 b: 0.194).	stretchHeight := 0.! !!CBlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 11:12'!isCBlock	^ true! !!CBlockMorph methodsFor: 'private' stamp: 'jm 10/20/2004 09:51'!litUp: aBoolean	"Overridden to suppress highlighting of control structures. Do nothing."! !!CBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/15/2018 07:12'!nestedBlock	^ nestedBlock! !!CBlockMorph methodsFor: 'accessing' stamp: 'ee 7/11/2008 22:23'!nestedBlockAt: aPoint	^ nestedBlock! !!CBlockMorph methodsFor: 'private' stamp: 'jm 3/20/2003 13:21'!nextBlock	"Answer the block myself in the block sequence or nil if I am the last block in the sequence. Each block is a submorph of the previous block."	^ nextBlock! !!CBlockMorph methodsFor: 'private' stamp: 'jm 3/23/2005 18:08'!nextBlock: aBlockMorph	"Add the given block as the block following me. Delete old nextBlock, if any."	self nextBlock ifNotNil: [self nextBlock delete].	nextBlock := aBlockMorph.	aBlockMorph ifNotNil: [self addMorph: aBlockMorph].! !!CBlockMorph methodsFor: 'private' stamp: 'jm 11/29/2006 12:22'!nonControlFlowSubmorphs	"Answer a collection of submorphs minus any blocks that are part of the control flow. For example, command blocks omit their submorph that is the next block in the block sequence, C-blocks omit both their next block and the first block of their nested block list, etc."	^ submorphs select: [:m | (m ~~ nestedBlock) & (m ~~ nextBlock)]! !!CBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:05'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		nestedBlock		nextBlock	) on: anObjStream.! !!CBlockMorph methodsFor: 'geometry' stamp: 'ee 7/11/2008 22:23'!stretchHeight: aNumber	(stretchHeight = aNumber) ifTrue: [^ self].	stretchHeight := aNumber.	blockLayoutNeeded := true.	self fixBlockLayout.! !!CBlockMorph methodsFor: 'accessing' stamp: 'jm 11/29/2006 12:22'!topBarHeight	"Answer the height of the top bar."	| nonBlockSubmorphs |	nonBlockSubmorphs := self submorphs select: [:m |		(m isKindOf: BlockMorph) not or: [argMorphs includes: m]].	^ nonBlockSubmorphs inject: CBlockBracketThickness into: [:h :m | h max: (m height + 4)].! !!CommandBlockMorph class methodsFor: 'utilities' stamp: 'ee 3/28/2009 20:07'!argPermutationForSpec: spec withTranslation: translatedSpec	"CommandBlockMorph argPermutationForSpec: '%a of %m of %m of %t' withTranslation: '%a de %m de %m de %t'"	"CommandBlockMorph argPermutationForSpec: '%a of %m of %m of %t' withTranslation: '%t de %m2 de %m1 de %a'"	| parsedSpec parsedTranslatedSpec parsedSpecArgs parsedTranslatedSpecArgs permutation a copiesSize n originalPermutation |	parsedSpec := CommandBlockMorph parseCommandSpec: spec.	parsedSpecArgs := parsedSpec select: [:s | CommandBlockMorph isArgSpec: s].	parsedTranslatedSpec := CommandBlockMorph parseCommandSpec: translatedSpec.	parsedTranslatedSpecArgs := parsedTranslatedSpec select: [:s | CommandBlockMorph isArgSpec: s].	permutation := #().	1 to: parsedSpecArgs size do: [:i | permutation := permutation copyWith: i].	originalPermutation := permutation.	"no change"	(parsedSpecArgs = parsedTranslatedSpecArgs) ifTrue: [			^ originalPermutation].	"otherwise, calculate permutation"	1 to: parsedSpecArgs size do: [:i |		a := parsedSpecArgs at: i.		copiesSize := (parsedSpecArgs select: [:s | (s = a)]) size.		(copiesSize = 1)			ifTrue:[permutation at: i put: (parsedTranslatedSpecArgs indexOf: a				ifAbsent: [Transcript show: 'Permutation failed: ', spec.						^ originalPermutation])]			ifFalse:["count copies until now"				n := ((parsedSpecArgs copyFrom: 1 to: i) select: [:s | (s = a)]) size.				permutation at: i put: (parsedTranslatedSpecArgs indexOf: (a,n asString)					ifAbsent: [Transcript show: 'Permutation failed: ', spec.						^ originalPermutation])]].	^ permutation! !!CommandBlockMorph class methodsFor: 'utilities' stamp: 'ee 2/28/2009 13:39'!isArgSpec: aString	"Answer true if the given string is an argument specification."	^ ((aString size > 1) and: [aString first = $%])! !!CommandBlockMorph class methodsFor: 'utilities' stamp: 'EiichiroIto 9/27/2016 10:51'!parseCommandSpec: aCommandSpec	"Answer an array of token strings containing my keywords and argument specs."	| result len i j spec k |	result := OrderedCollection new.	spec := aCommandSpec.	"(spec isKindOf: UTF8) ifTrue: [spec := String withAll: spec]."	len := aCommandSpec size.	i := 1.	[(i < len) and: [(spec at: i) isSeparator]] whileTrue: [i := i + 1].	[i <= len] whileTrue: [		j := spec indexOf: $% startingAt: i.		j > 0			ifTrue: [				j > i ifTrue: [result addLast: (spec copyFrom: i to: j - 1)].				j < len					ifTrue: [k := j + 1.						((spec at: k) isLetter)							ifTrue: [[(k+1 <= len) and: [(spec at: k+1) isDigit]] whileTrue:[								k := k + 1].								(k >= len)									ifTrue: [result addLast: (spec copyFrom: j to: len).										i := len + 1]									ifFalse: [result addLast: (spec copyFrom: j to: k).										i := k+1]]							ifFalse: [result addLast: '%'.										i := j + 1]]					ifFalse: [result addLast: '%'.						i := j + 2]]			ifFalse: [				result addLast: (spec copyFrom: i to: len).				i := len + 1]].	result := result select: [:s | s ~= ' '].	^ result asArray collect: [:s | s trimBoth]! !!CommandBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 20:55'!addCommandIcons	"Add additional icons to certain blocks. Do nothing if this isn't one of those blocks."	| f m |	#turnLeft: = selector ifTrue: [		f := ScratchTheme formAt: #turnCCW.		m := self firstSubmorph delete.		self addMorphFront: (ImageMorph new form: f).		self addMorphFront: m].	#turnRight: = selector ifTrue: [		f := ScratchTheme formAt: #turnCW.		m := self firstSubmorph delete.		self addMorphFront: (ImageMorph new form: f).		self addMorphFront: m].	#stopAll = selector ifTrue: [		f := ScratchTheme formAt: #stopButton.		self addMorphBack: (ImageMorph new form: f)].! !!CommandBlockMorph methodsFor: 'private' stamp: 'ee 2/27/2009 12:46'!addLabel	"Add a label for my command and arguments. This is the method that really creates the whole block."	"Details: We remove all the pieces of this block, and then reassemble them, being careful not to destroy any argument morphs that we might still want to use. This is helpful if someone adds/removes parameters from a hat block."	| tokens args nextArgIndex m next |	commandSpec ifNil: [^ self].	"we make sure not to remove the next block."	next := self nextBlock.	self removeAllMorphsIn: (self submorphs reject: [:t | t = next]).	tokens := CommandBlockMorph parseCommandSpec: commandSpec.	args := tokens select: [:s | CommandBlockMorph isArgSpec: s].	"remove any excess arg morphs from the list."	[argMorphs size > args size] whileTrue: [		m := argMorphs last.		argMorphs remove: m.		"if the argument we're throwing out is anything complicated, we'd like to keep it around in the world."		(m isKindOf: BlockMorph) ifTrue: [m openInWorld]].	"create new arg morphs."	[argMorphs size < args size] whileTrue: [		argMorphs addLast: (self argMorphFor: (args at: argMorphs size + 1))].	nextArgIndex := 1.	tokens do: [:s |		(CommandBlockMorph isArgSpec: s)			ifTrue:	[				m := argMorphs at: nextArgIndex.				nextArgIndex := nextArgIndex + 1]			ifFalse:	[				m := self labelMorphFor: s].		self addMorphBack: m].	self isReporter ifTrue: [		m := submorphs first.		((m isKindOf: ChoiceArgMorph) | (m isKindOf: SpriteArgMorph)) ifTrue: [  "add spacer"			self addMorphFront: (Morph new color: Color transparent; extent: 2@5)].		m := submorphs last.		((m isKindOf: ChoiceArgMorph) | (m isKindOf: SpriteArgMorph)) ifTrue: [  "add spacer"			self addMorphBack: (Morph new color: Color transparent; extent: 2@5)]].! !!CommandBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 22:38'!argMorphFor: specString	"Answer an argument morph for the given argument specification string. Set it's color appropriately."	| m |	m := self script uncoloredArgMorphFor: specString.	(m isKindOf: ColorArgMorph)		ifTrue: [m color: Color random].	^ m! !!CommandBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 22:46'!argMorphToReplace: aMorph	"Answer a new argument morph to be used to replace the given morph. Answer nil if the given morph is not one of my argMorphs."	| i argSpecs spec argM defaults v |	i := argMorphs indexOf: aMorph ifAbsent: [^ nil].	argSpecs := (CommandBlockMorph parseCommandSpec: commandSpec) select: [:s | CommandBlockMorph isArgSpec: s].	i > argSpecs size ifTrue: [^ nil].	argM := self argMorphFor: (argSpecs at: i).	(#setVar:to: = selector and: [(argSpecs at: i) = '%n']) ifTrue: [		^ argM stringExpression: '0'].	spec := self script class blockSpecAt: selector.	spec ifNil: [ ^ argM ].	defaults := receiver defaultArgsFor: spec.	i <= defaults size ifTrue: [		v := defaults at: (argPermutation indexOf: i).		(v isKindOf: String)			ifTrue: [				(argM isKindOf: ExpressionArgMorph)					ifTrue: [argM defaultValueFromSpec: v localized]					ifFalse: [argM defaultValue: v localized]]			ifFalse: [argM defaultValue: v]].	^ argM! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 8/6/2008 20:59'!argMorphs	^ argMorphs! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'ee 3/2/2009 11:53'!argPermutation: aSet	argPermutation := aSet! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 4/1/2009 10:37'!args	"Answer my arguments evaluated and permuted into the order expected by the underlying Squeak method."	^ self organizeArgs: (argMorphs collect: [:m | m evaluate]) asArray! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'ee 3/2/2009 11:53'!argumentAt: index	"Returns the argument morph at the given index."	^ argMorphs at: (argPermutation at: index).! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'jm 12/10/2003 18:41'!argumentCount	"Returns the number of arguments to this command block."	^ argMorphs size! !!CommandBlockMorph methodsFor: 'stack/tuple conversion' stamp: 'EiichiroIto 11/22/2019 10:12'!asBlockTuple	"Answer a tuple (Array) describing this block and its arguments."	| blockTuple argList arg |	blockTuple := Array new: argMorphs size + 1.	blockTuple at: 1 put: selector.	argList := argMorphs.	argList := self organizeArgs: argList.	"((#(+ - / * =) includes: selector) and: [ScratchTranslator isRTLMath])		ifTrue: [argList := argList reversed]."	1 to: argList size do: [ :i | 		arg := argList at: i.		(arg isArgMorph) | (arg isKindOf: EventTitleMorph)			ifTrue: [ blockTuple at: i + 1 put: arg evaluate ]			ifFalse: [ blockTuple at: i + 1 put: arg asBlockTuple ] ].	^ blockTuple! !!CommandBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 8/28/2018 14:17'!blockArgs	"^ submorphs select: [:m | (m isKindOf: ArgMorph) or: [m isKindOf: ReporterBlockMorph] ]"	^ self organizeArgs: argMorphs asArray! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'EiichiroIto 10/5/2018 07:35'!coerceArgs: argList	"Answer an arugments array in which all arguments that should be numbers have been coerced to numbers if necessary."	| args specialCommands numFlags |	args := argList asArray.	specialCommands := #(		setVar:to:).	(specialCommands includes: selector) ifFalse: [		"ensure args are numbers where numbers are expected"		numFlags := self numberArgFlags.		1 to: args size do: [:i |			(numFlags at: i) ifTrue: [args at: i put: (args at: i) asNumberNoError]]].	^ args! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 17:05'!color: aColor	super color: aColor.	self layoutChanged.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 11/20/2002 09:16'!commandSpec	^ commandSpec! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 6/12/2008 13:12'!commandSpec: aString	"Set my command spec string. See my class comment."	"CommandBlockMorph new commandSpec: 'forward %n'"	commandSpec := aString.	numberArgFlags := nil.	self addLabel.	self addCommandIcons.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 5/7/2009 14:16'!defaultArgs: defaultValues	"Set the default values of my arguments from the given list."	| argM defaultValue |	1 to: (defaultValues size min: argMorphs size) do: [:i |		argM := argMorphs at: (argPermutation at: i).		defaultValue := defaultValues at: i.		(argM  isKindOf: ExpressionArgMorph)			ifTrue: [argM defaultValueFromSpec: defaultValue]			ifFalse: [argM defaultValue: defaultValue]].! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'jm 7/19/2006 11:06'!evaluate	^ self evaluateWithArgs: self args! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'EiichiroIto 11/22/2019 10:21'!evaluateInfixWithArgs: rawArgs	"Evalue an infix operator with the given arguments list. Special case for comparison operatores when both operands are strings. Reverse order of comparison operands in RTL languages."	"Note: The strings 'true' and 'false' in either English or the current language are equal to the boolean value that they name."	| args result arg1 arg2 |	args := rawArgs.	#= = selector ifTrue: [		"special case: check for equality between a boolean and the special strings 'true' or 'false'"		((args first isString) and: [args second isKindOf: Boolean]) ifTrue: [			(args first = 'true') ifTrue: [^ args second = true].			(args first = 'false') ifTrue: [^ args second = false].			"(args first = (ScratchTranslator translationFor: 'true')) ifTrue: [^ args second = true]."			"(args first = (ScratchTranslator translationFor: 'false')) ifTrue: [^ args second = false]"].		((args first isKindOf: Boolean) and: [args second isString]) ifTrue: [			(args second = 'true') ifTrue: [^ args first = true].			(args second = 'false') ifTrue: [^ args first = false].			"(args second = (ScratchTranslator translationFor: 'true')) ifTrue: [^ args first = true]."			"(args second = (ScratchTranslator translationFor: 'false')) ifTrue: [^ args first = false]"]].	(#(< = >) includes: selector)		ifTrue: [((args first isString) or: [args second isString]) ifTrue: [				arg1 := receiver interpretStringAsNumberIfPossible: args first.				arg2 := receiver interpretStringAsNumberIfPossible: args second.				((arg1 isString) and: [arg2 isString]) ifTrue: [					result := args first compare: args second.					#< = selector ifTrue: [^ result = 1].					#= = selector ifTrue: [^ result = 2].					#> = selector ifTrue: [^ result = 3]].				((arg1 isNumber) and: [arg2 isNumber]) ifTrue: [					^ arg1 perform: selector with: arg2].				^ false]]		"ifFalse: [(ScratchTranslator isRTLMath and: [((selector = #\\) not)]) ifTrue: [args := args reversed]]". "RTLMath operators are RTL"	(#(& |) includes: selector) ifTrue: [^ args first perform: selector with: args second].	^ args first asNumberNoError perform: selector with: args second asNumberNoError! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'jm 6/3/2008 17:24'!evaluateWithArgs: rawArgs	"Evalue this block with the given argument list."	| args |	"special case for math and boolean infix operators"	selector isInfix ifTrue: [^ self evaluateInfixWithArgs: rawArgs].	args := self coerceArgs: rawArgs..	"special case for unary operators"	(#(abs not rounded sqrt truncated) includes: selector) ifTrue: [^ args first perform: selector].	^ receiver perform: selector withArguments: args! !!CommandBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:54'!fieldsVersion	^ 1! !!CommandBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/22/2019 13:11'!fixBlockLayout	"Update the positions of my submorphs."	| isFirst h x minXForArgs hAdjust nextB w oldPos oldExtent |	blockLayoutNeeded		ifFalse: [ ^ self ].	super fixBlockLayout.	oldPos := self position.	oldExtent := self extent.	hAdjust := 4.	isFirst := true.	h := 14.	"minimum height"	self nonControlFlowSubmorphs		do: [ :m | 			(m isBlockMorph)				ifTrue: [ m fixBlockLayout ].			(m isArgMorph)				ifTrue: [ m fixArgLayout ].			(isFirst and: [ (m isKindOf: StringMorph) not ])				ifTrue: [ "extra space when an arg overlaps with notch"					h := h max: m height + 3.					hAdjust := 1 ].			isFirst := false.			h := h max: m height ].	((self isCBlock) or: [ self isIfElseBlock ])		ifTrue: [ minXForArgs := self left + PuzzleInset + PuzzleWidth + 8 ]		ifFalse: [ minXForArgs := self left ].	h := h + 10.	self isReporter		ifTrue: [ h := h - 2.			hAdjust := 2 ].	self isStop		ifTrue: [ h := h - 5.			hAdjust := 0 ].	x := self left + 5.	self nonControlFlowSubmorphs		do: [ :m | 			(m isKindOf: StringMorph)				ifTrue: [ m color: self labelColor ]				ifFalse: [ x := x max: minXForArgs ].			m position: x @ (self top + ((h - hAdjust - m height) // 2)).			x := x + m width + 4 ].	w := x - self left max: 37.	(self isCBlock or: [ self isIfElseBlock ])		ifTrue: [ w := w max: 71 ].	self extent: w @ h.	(nextB := self nextBlock)		ifNotNil: [ self isCBlock				ifFalse: [ nextB position: self left @ (self bottom - 4) ].			nextB fixBlockLayout ]! !!CommandBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:01'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		commandSpec		argMorphs		titleMorph		receiver		selector		isReporter		isTimed		wantsName		wantsPossession	) from: anObjStream.! !!CommandBlockMorph methodsFor: 'initialization' stamp: 'jm 10/22/2007 09:15'!initialize	super initialize.	commandSpec := ''.	argMorphs := OrderedCollection new.	receiver := nil.	selector := nil.	isTimed := false.! !!CommandBlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 11:10'!isCommandBlock	^ true! !!CommandBlockMorph methodsFor: 'testing' stamp: 'jm 4/15/2007 20:01'!isForever	^ (selector = #doForever) | (selector = #doForeverIf)! !!CommandBlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 9/12/2019 15:50'!isStop	^ (selector = #stopThread) | (selector = #stopAll) | (selector = #return:)! !!CommandBlockMorph methodsFor: 'testing' stamp: 'jm 12/10/2003 20:58'!isTimed	^ isTimed! !!CommandBlockMorph methodsFor: 'testing' stamp: 'DaveF 7/10/2003 17:41'!isTimed: aBoolean	"Indicates that this block's evaluate method will be called repeatedly throughout some time interval."	isTimed := aBoolean.! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 6/20/2007 19:10'!labelColor	"Answer a label color, either black or white, that maximizes the contrast with my color."	^ LabelColor"old:	^ self color luminance > 0.8		ifTrue: [Color black]		ifFalse: [Color white]"! !!CommandBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 9/13/2018 16:16'!labelId	^ labelId! !!CommandBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 9/13/2018 16:16'!labelId: anInteger	labelId := anInteger.! !!CommandBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 21:15'!labelMorphFor: aString	| s |	s := aString.	"commandSpec isUnicode ifTrue: [s := UTF8 withAll: s]."	^ (StringMorph contents: s font: (ScratchTheme labelFont))		color: self labelColor! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 6/3/2009 16:38'!mapReceiver: oldObj to: newObj	"Used in cloning an object to make blocks that refererred to the original object new refer to the new copy."	receiver == oldObj ifTrue: [receiver := newObj].	argMorphs do: [:arg |		(arg isKindOf: CommandBlockMorph) ifTrue: [			arg mapReceiver: oldObj to: newObj]].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/31/2006 09:18'!nextBlock	"Answer the block following myself in the block sequence or nil if I am the last block in the sequence. Each block is a submorph of the previous block."	^ self submorphs		detect: [:m | (m isKindOf: BlockMorph) and: [(argMorphs includes: m) not]]		ifNone: [nil]! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 3/23/2005 18:02'!nextBlock: aBlock	"Add the given block as the block following me. Delete old nextBlock, if any."	self nextBlock ifNotNil: [self nextBlock delete].	self addMorph: aBlock.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 22:38'!numberArgFlags	"Answer an array of booleans indicating which of my arguments must be numbers. Compute on first use and cache the result."	| argSpecs argM |	numberArgFlags ifNotNil: [ ^ numberArgFlags ].	argSpecs := (CommandBlockMorph parseCommandSpec: commandSpec)		select: [ :s | CommandBlockMorph isArgSpec: s ].	argSpecs := self organizeArgs: argSpecs.	numberArgFlags := argSpecs		collect: [ :spec | 			argM := self script uncoloredArgMorphFor: spec.			(argM isKindOf: ExpressionArgMorph)				ifTrue: [ argM isNumberExpression ]				ifFalse: [ false ] ].	^ numberArgFlags.! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'jm 5/5/2009 17:05'!organizeArgs: argList	"Answer an arugments array in which all arguments have been rearranged to the original English permutation"	| newArgList |	argPermutation ifNil: [^ argList].	(#(+ - / * =) includes: selector) ifTrue: [^ argList].	newArgList := #().	1 to: argPermutation size do: [:i |		newArgList := newArgList copyWith: (argList at: (argPermutation at: i))].	^ newArgList! !!CommandBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 9/27/2016 10:50'!parseCommandSpec	"Answer an array of token strings containing my keywords and argument specs."	| spec result len i j |	result := OrderedCollection new.	spec := commandSpec.	"(spec isKindOf: UTF8) ifTrue: [spec := String withAll: spec]."	len := commandSpec size.	i := 1.	[(i < len) and: [(spec at: i) isSeparator]] whileTrue: [i := i + 1].	[i <= len] whileTrue: [		j := spec indexOf: $% startingAt: i.		j > 0			ifTrue: [				j > i ifTrue: [result addLast: (spec copyFrom: i to: j - 1)].				j < len					ifTrue: [result addLast: (spec copyFrom: j to: j + 1)]					ifFalse: [result addLast: '%'].				i := j + 2]			ifFalse: [				result addLast: (spec copyFrom: i to: len).				i := len + 1]].	^ result asArray collect: [:s | s trimBoth]! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 6/22/2003 21:50'!receiver	^ receiver! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 7/7/2004 00:09'!receiver: anObject	"Set my receiver object."	receiver := anObject.! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 17:06'!replaceArgMorph: oldMorph by: newMorph	"Replace oldMorph with newMorph in my argMorphs and submorphs lists. This is done when dropping a reporter block onto one of my arguments."	argMorphs := argMorphs collect: [:m |		m == oldMorph ifTrue: [newMorph] ifFalse: [m]].	self replaceSubmorph: oldMorph by: newMorph.	self layoutChanged.! !!CommandBlockMorph methodsFor: 'menus' stamp: 'EiichiroIto 11/23/2019 08:45'!rightButtonMenu: anEvent	| menu choice spec |	menu := MenuMorph new.	menu target: [ :v | choice := v ].	"menu add: 'help' selector: #value: argument: #presentHelpScreen."	owner isBlockPalette		ifFalse: [ menu addLine.			(#(+ - * / \\) includes: selector)				ifTrue: [ #(+ - * / mod)						with: #(+ - * / \\)						do: [ :s :op | menu add: s selector: #value: argument: op ] ].			(#(< = >) includes: selector)				ifTrue: [ #(< = >) do: [ :op | menu add: op selector: #value: argument: op ] ].			(#(& |) includes: selector)				ifTrue: [ #(and or)						with: #(& |)						do: [ :s :op | menu add: s selector: #value: argument: op ] ].			menu addLine.			"menu add: 'duplicate' selector: #value: argument: #duplicate."			self owner isBlockMorph				ifFalse:					[ "can't yet delete a blocks inside a script" menu add: 'delete' selector: #value: argument: #delete ] ].	"sFrame := self meOrOwnerThatIsA: ScratchFrameMorph."	"(sFrame notNil and: [#(sensor: sensorPressed:) includes: selector]) ifTrue: [		menu addLine.		menu add: 'show ScratchBoard watcher' selector: #value: argument: #showSensorBoard.		sFrame workPane scratchServer			ifNil: [menu add: 'enable remote sensor connections' selector: #value: argument: #enableRemoteSensors]			ifNotNil: [menu add: 'disable remote sensor connections' selector: #value: argument: #exitScratchSession]]."	"DebugMenu ifTrue: [		menu addLine.		menu add: 'show tuples' selector: #value: argument: #showTuples]."	menu localize.	menu invokeAt: anEvent cursorPoint in: self world.	choice ifNil: [ ^ self ].	(#(duplicate delete) includes: choice)		ifTrue: [ ^ self perform: choice ].	"choice = #showSensorBoard ifTrue: [sFrame showSensorBoard. ^ self].	choice = #enableRemoteSensors ifTrue: [sFrame enableRemoteSensors. ^ self]."	"choice = #exitScratchSession ifTrue: [sFrame exitScratchSession. ^ self]."	"choice = #showTuples ifTrue: [^ self showTuples]."	"change operator"	spec := '%n ' , choice , ' %n'.	'\\' = choice		ifTrue: [ spec := '%n mod %n' ].	'&' = choice		ifTrue: [ spec := '%b and %b' ].	'|' = choice		ifTrue: [ spec := '%b or %b' ].	self commandSpec: spec.	self selector: choice! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 22:38'!script	^ receiver! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 7/2/2003 11:47'!selector	^ selector! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 8/3/2003 23:52'!selector: aSymbol	selector := aSymbol.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 11/30/2007 12:21'!selectorAndArg	"Answer an array containing my selector and argument (if any)."	| args |	args := self args.	^ Array with: selector with: (args size = 0 ifTrue: [nil] ifFalse: [args first])! !!CommandBlockMorph methodsFor: 'processes' stamp: 'EiichiroIto 11/21/2019 22:24'!start	self stop.	self receiver ifNil: [ ^ self ].	self applicationDo: [ :app | app startProcessFor: self ].	self changed! !!CommandBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:01'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		commandSpec		argMorphs		titleMorph		receiver		selector		isReporter		isTimed		wantsName		wantsPossession	) on: anObjStream.! !!CommandBlockMorph methodsFor: 'menus' stamp: 'jm 2/2/2009 16:51'!tabToNextField: evt	"Move the keyboard focus to the next submorph that responds to keyboard events."	| fields current |	fields := argMorphs select: [:m | m isKindOf: ExpressionArgMorph].	current := (1 to: fields size) detect: [:i | (fields at: i) labelMorph == evt hand keyboardFocus] ifNone: [fields size].	evt hand newKeyboardFocus: (fields at: (current \\ fields size) + 1) labelMorph.! !!CommandBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 9/19/2016 19:38'!updateReferencesUsing: deepCopier	"Update my arg morphs."	super updateReferencesUsing: deepCopier.	argMorphs := argMorphs collect: [:m | deepCopier references at: m ifAbsent: [m]].! !!IfElseBlockMorph methodsFor: 'private' stamp: 'ee 2/28/2008 17:02'!addLabel	"Also add the else label"	super addLabel.	elseMorph := self labelMorphFor: 'else' localized.	self addMorphBack: elseMorph.! !!IfElseBlockMorph methodsFor: 'private' stamp: 'ee 2/28/2009 16:11'!asBlockTuple	"Answer a tuple (Array) describing this block and its arguments."	| blockTuple arg argList |	blockTuple := Array new: argMorphs size + 3.	blockTuple at: 1 put: selector.	argList := argMorphs.	argList := self organizeArgs: argList.	1 to: argList size do: [:i |		arg := argList at: i.		(arg isKindOf: ArgMorph)			ifTrue: [blockTuple at: i + 1 put: arg evaluate]			ifFalse: [blockTuple at: i + 1 put: arg asBlockTuple]].	trueBlock		ifNil: [blockTuple at: blockTuple size - 1 put: nil]		ifNotNil: [blockTuple at: blockTuple size - 1 put: trueBlock tupleSequence].	falseBlock		ifNil: [blockTuple at: blockTuple size put: nil]		ifNotNil: [blockTuple at: blockTuple size put: falseBlock tupleSequence].	^ blockTuple! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 12/14/2005 17:07'!attachBlock: aBlockMorph	"Attach the given block to me. Assume the block has been positioned correctly."	| y |	self addMorph: aBlockMorph.	y := aBlockMorph top.	y <= (self top + elseBarY) ifTrue: [trueBlock := aBlockMorph. ^ self].	y <= (self bottom - CBlockBracketThickness) ifTrue: [falseBlock := aBlockMorph. ^ self].	nextBlock := aBlockMorph.! !!IfElseBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/22/2019 15:11'!blockAttachPoints: aSet	"Answer a collection of possible attachment points for me. Each entry is an Association mapping a point to the morph to which a dropping command block could be attached."	| result |	result := #().	self = self topBlock		ifTrue: [ result := result copyWith: self topLeft -> self ].	(self isKindOf: HatBlockMorph)		ifFalse: [ result := result copyWith: self topLeft -> self ].	trueBlock		ifNil: [ result := result				copyWith: self topLeft + (12 @ (self topBarHeight + 7)) -> self ]		ifNotNil: [ trueBlock blockAttachPoints: aSet ].	falseBlock		ifNil: [ result := result				copyWith: self topLeft + (12 @ (elseBarY + self elseBarHeight + 9)) -> self ]		ifNotNil: [ falseBlock blockAttachPoints: aSet ].	nextBlock		ifNil: [ result := result copyWith: self bottomLeft -> self ]		ifNotNil: [ nextBlock blockAttachPoints: aSet ].	aSet addAll: result! !!IfElseBlockMorph methodsFor: 'geometry' stamp: 'jm 6/21/2009 11:47'!containsPoint: aPoint	cachedForm ifNil: [self updateCachedForm].	^ (self fullBounds containsPoint: aPoint) and:	  [(cachedForm isTransparentAt: aPoint - self fullBounds origin) not]! !!IfElseBlockMorph methodsFor: 'drawing' stamp: 'jm 12/14/2005 17:39'!drawBottomBarOn: aCanvas 	self drawInnerBottomY: self bottom - CBlockBracketThickness - 4 on: aCanvas.	self drawBottomEdgeOn: aCanvas.! !!IfElseBlockMorph methodsFor: 'drawing' stamp: 'ee 8/11/2008 14:46'!drawElseBarOn: aCanvas	| left y |	"these are in absolute coordinates"	left := self left + CBlockBracketThickness - 1.	y := self top + elseBarY.	self drawInnerBottomY: y on: aCanvas.	y := y + 2.	aCanvas		fillRectangle: (left@y corner: (self right - 1)@(y + self elseBarHeight))		color: color.	aCanvas		fillRectangle: ((self right - 1)@y corner: self right@(y + self elseBarHeight))		color: shadowColor.	self drawInnerTopY: elseBarY + self elseBarHeight + 2 on: aCanvas.! !!IfElseBlockMorph methodsFor: 'drawing' stamp: 'jm 12/14/2005 17:42'!drawInnerBottomY: y on: aCanvas	| left barBottom |	left := self left + CBlockBracketThickness - 1.	barBottom := y + (CBlockBracketThickness - 3).	"fill in bottom-left corner"	aCanvas fillRectangle: (left@(y - 2) extent: 1@1) color: color.	aCanvas fillRectangle: (left@(y - 1) extent: 2@1) color: color.	aCanvas fillRectangle: (left@y extent: 3@1) color: color.	aCanvas		fillRectangle: ((left + 3)@y corner: (self right - 2)@(y + 1))		color: highlightColor1.	aCanvas		fillRectangle: (left@(y + 1) corner: (self right - 1)@barBottom)		color: color.	aCanvas		fillRectangle: ((self right - 1)@(y + 2) corner: self right@barBottom)		color: shadowColor.! !!IfElseBlockMorph methodsFor: 'drawing' stamp: 'jm 12/14/2005 17:21'!drawInnerTopY: y on: aCanvas	| left right gapStart gapEnd |	left := CBlockBracketThickness - 1.	right := self width - 1.	gapStart := left + PuzzleInset + 1.	gapEnd := gapStart + PuzzleWidth.	self drawHLineFrom: left to: (right - 1) y: y color: color on: aCanvas.	self drawHLineFrom: left to: (right - 2) y: y + 1 color: color on: aCanvas.	"fill in upper-left inside corner"	self drawHLineFrom: left to: (left + 2) y: y + 2 color: color on: aCanvas.	self drawHLineFrom: left to: (left + 1) y: y + 3 color: color on: aCanvas.	self drawPoint: (left + 1)@(y + 3) color: shadowColor on: aCanvas.	self drawHLineFrom: gapStart to: gapEnd y: y + 2 color: color on: aCanvas.	self drawHLineFrom: gapStart + 1 to: gapEnd - 1 y: y + 3 color: color on: aCanvas.	self drawHLineFrom: gapStart + 1 to: gapEnd - 1 y: y + 4 color: color on: aCanvas.	self drawHLineFrom: gapStart + 2 to: gapEnd - 2 y: y + 5 color: color on: aCanvas.	self drawHLineFrom: (left + 2) to: gapStart y: y + 2 color: shadowColor on: aCanvas.	self drawHLineFrom: gapEnd to: right - 2 y: y + 2 color: shadowColor on: aCanvas.	self drawHLineFrom: gapStart + 2 to: gapEnd - 2 y: y + 6 color: shadowColor on: aCanvas.	self drawPoint: gapStart@(y + 3) color: shadowColor on: aCanvas.	self drawPoint: gapStart@(y + 4) color: shadowColor on: aCanvas.	self drawPoint: (gapStart + 1)@(y + 5) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 1)@(y + 3) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 1)@(y + 4) color: shadowColor on: aCanvas.	self drawPoint: (gapEnd - 2)@(y + 5) color: shadowColor on: aCanvas.	self drawPoint: (right - 1)@y color: shadowColor on: aCanvas.	self drawPoint: (right - 2)@(y + 1) color: shadowColor on: aCanvas.! !!IfElseBlockMorph methodsFor: 'drawing' stamp: 'ee 3/6/2008 15:28'!drawOn: aCanvas 	| c |	topBarBottom := self top + self topBarHeight.	blockBottom := self bottom - 7.	self computeHighlightColors.	c := FormCanvas extent: self extent depth: 32.	c := c copyOffset: self topLeft negated.	self drawTopEdgeOn: c.	self drawTopBarOn: c.	self drawVerticalBarOn: c.	self drawElseBarOn: c.	self drawBottomBarOn: c.	self drawFinalOn: aCanvas fromCanvas: c.! !!IfElseBlockMorph methodsFor: 'drawing' stamp: 'jm 12/14/2005 17:27'!drawTopBarOn: aCanvas 	aCanvas		fillRectangle: (self left@(self top + 5) corner: (self right - 1)@topBarBottom)		color: color.	aCanvas		fillRectangle: ((self right - 1)@(self top + 3) corner: self right @topBarBottom)		color: shadowColor.	self drawInnerTopY: topBarBottom - self top on: aCanvas.! !!IfElseBlockMorph methodsFor: 'drawing' stamp: 'jm 12/13/2005 20:31'!drawVerticalBarOn: aCanvas 	| left top barRight |	left := self left.	barRight := (left + CBlockBracketThickness) - 1.	top := self top.		aCanvas		fillRectangle: (left@(top + 5) corner: barRight@blockBottom)		color: color.	aCanvas		fillRectangle: (left@(top + 2) corner: (left + 2)@blockBottom)		color: highlightColor2.	aCanvas		fillRectangle: (barRight@(topBarBottom + 4) corner: (barRight + 1)@blockBottom)		color: shadowColor.! !!IfElseBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 21:17'!elseBarHeight	 ^ (ScratchTranslator stringExtent: 'else' localized font: (ScratchTheme labelFont)) y! !!IfElseBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/15/2018 07:38'!emitCode: aGenerator indent: indent	aGenerator emitIfElseBlock: self indent: indent.! !!IfElseBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/15/2018 07:36'!falseBlock	^ falseBlock! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 12/14/2005 11:35'!falseBlock: aBlockMorph	"Add the given block as my false nested block sequence. Delete the old nested blocks, if any."	falseBlock ifNotNil: [falseBlock delete].	falseBlock := aBlockMorph.	aBlockMorph ifNotNil: [self addMorph: aBlockMorph].! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 12/13/2005 20:36'!falseBlockList	"Answer an array containing the block sequence false-case nested stack."	falseBlock		ifNil: [^ #()]		ifNotNil: [^ falseBlock blockSequence].! !!IfElseBlockMorph methodsFor: 'object i/o' stamp: 'jm 12/13/2005 20:31'!fieldsVersion	^ 1! !!IfElseBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/22/2019 15:12'!fixBlockLayout	"Update the positions of my submorphs."	| newH |	blockLayoutNeeded		ifFalse: [ ^ self ].	"fix trueBlock, falseBlock, and nextBlock in case they've been removed from me"	(trueBlock notNil and: [ trueBlock owner ~~ self ])		ifTrue: [ trueBlock := nil ].	(falseBlock notNil and: [ falseBlock owner ~~ self ])		ifTrue: [ falseBlock := nil ].	(nextBlock notNil and: [ nextBlock owner ~~ self ])		ifTrue: [ nextBlock := nil ].	super fixBlockLayout.	newH := self topBarHeight + 3.	trueBlock		ifNil: [ newH := newH + 15 ]		ifNotNil: [ trueBlock fixBlockLayout.			trueBlock position: self position + (CBlockBracketThickness @ newH).			newH := newH + trueBlock fullBounds height.			trueBlock blockSequence last isStopOrForever				ifTrue: [ newH := newH + 4 ] ].	elseBarY := newH - 4.	newH := newH + self elseBarHeight + 1.	falseBlock		ifNil: [ newH := newH + 15 ]		ifNotNil: [ falseBlock fixBlockLayout.			falseBlock				position: self position + (CBlockBracketThickness @ newH).			newH := newH + falseBlock fullBounds height.			falseBlock blockSequence last isStopOrForever				ifTrue: [ newH := newH + 4 ] ].	newH := newH + CBlockBracketThickness.	self height: newH.	nextBlock		ifNotNil: [ nextBlock position: self left @ (self bottom - 4) ].	elseMorph		position:			(self left + 6)				@					(self top + elseBarY						+							((ScratchTranslator								centerOffsetForButtonWithFont: ScratchTheme labelFont) // 4))! !!IfElseBlockMorph methodsFor: 'object i/o' stamp: 'jm 12/13/2005 20:39'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		trueBlock		falseBlock		nextBlock	) from: anObjStream.! !!IfElseBlockMorph methodsFor: 'initialization' stamp: 'jm 12/13/2005 20:31'!initialize	super initialize.	self color: (Color r: 1.0 g: 0.581 b: 0.194).! !!IfElseBlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 11:13'!isIfElseBlock	^ true! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 12/13/2005 20:31'!litUp: aBoolean	"Overridden to suppress highlighting of control structures. Do nothing."! !!IfElseBlockMorph methodsFor: 'accessing' stamp: 'ee 7/11/2008 22:26'!nestedBlockAt: aPoint	| dist |	trueBlock		ifNotNil: [dist := trueBlock - aPoint.			falseBlock				ifNotNil: [(dist > (falseBlock - aPoint))					ifTrue: [^ falseBlock]					ifFalse: [^ trueBlock]]				ifNil: [^ trueBlock]]		ifNil: [^ falseBlock].! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 12/13/2005 20:31'!nextBlock	"Answer the block myself in the block sequence or nil if I am the last block in the sequence. Each block is a submorph of the previous block."	^ nextBlock! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 12/13/2005 20:31'!nextBlock: aBlockMorph	"Add the given block as the block following me. Delete old nextBlock, if any."	self nextBlock ifNotNil: [self nextBlock delete].	nextBlock := aBlockMorph.	aBlockMorph ifNotNil: [self addMorph: aBlockMorph].! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 11/29/2006 12:22'!nonControlFlowSubmorphs	"Answer a collection of submorphs minus any blocks that are part of the control flow. For example, command blocks omit their submorph that is the next block in the block sequence, C-blocks omit both their next block and the first block of their nested block list, etc."	^ submorphs select: [:m |		(m ~~ trueBlock) &		(m ~~ falseBlock) &		(m ~~ nextBlock)]! !!IfElseBlockMorph methodsFor: 'object i/o' stamp: 'jm 12/13/2005 20:40'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		trueBlock		falseBlock		nextBlock	) on: anObjStream.! !!IfElseBlockMorph methodsFor: 'accessing' stamp: 'ee 7/11/2008 22:26'!stretchHeight: aNumber	"Temporary"	^ self! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 11/29/2006 12:21'!topBarHeight	"Answer the height of the top bar."	| nonBlockSubmorphs |	nonBlockSubmorphs := self submorphs select: [:m |		(m isKindOf: BlockMorph) not or: [argMorphs includes: m]].	^ nonBlockSubmorphs inject: CBlockBracketThickness into: [:h :m | h max: (m height + 4)].! !!IfElseBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/15/2018 07:35'!trueBlock	^ trueBlock! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 12/14/2005 11:34'!trueBlock: aBlockMorph	"Add the given block as my true nested block sequence. Delete the old nested blocks, if any."	trueBlock ifNotNil: [trueBlock delete].	trueBlock := aBlockMorph.	aBlockMorph ifNotNil: [self addMorph: aBlockMorph].! !!IfElseBlockMorph methodsFor: 'private' stamp: 'jm 12/13/2005 20:36'!trueBlockList	"Answer an array containing the block sequence true-case nested stack."	trueBlock		ifNil: [^ #()]		ifNotNil: [^ trueBlock blockSequence].! !!ListContentsBlockMorph methodsFor: 'all' stamp: 'jens 11/18/2008 09:40'!addLabel	"Add a label for my command and arguments. 	This is the method that really creates the whole block."	"Details: This overrides the superclass method to allow 	using percent character in variable/list names"	commandSpec ifNil: [^ self].	self removeAllMorphs.	self addMorphBack: (self labelMorphFor: commandSpec).! !!ListContentsBlockMorph methodsFor: 'all' stamp: 'jm 5/12/2008 22:45'!asBlockTuple	"Answer a tuple (Array) describing this block and its arguments."	^ Array with: #contentsOfList: with: commandSpec! !!ListContentsBlockMorph methodsFor: 'all' stamp: 'jm 5/5/2008 10:45'!evaluateWithArgs: ignored	^ receiver contentsOfList: commandSpec! !!ListContentsBlockMorph methodsFor: 'all' stamp: 'jm 5/6/2008 17:10'!selectorAndArg	^ Array with: selector with: commandSpec! !!ReporterBlockMorph methodsFor: 'other' stamp: 'jm 3/28/2005 19:22'!acceptsTypeOf: aBlockMorph	"Answer true if I can accept a dropped reporter of the given type. Answer false by default."	aBlockMorph isReporter ifFalse: [^ false].	^ aBlockMorph isBooleanReporter = self isBooleanReporter! !!ReporterBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator reporterArgString: self.! !!ReporterBlockMorph methodsFor: 'watcher' stamp: 'EiichiroIto 11/25/2019 10:33'!canBecomeWatcher	^ self isReporter		and: [ self argumentCount <= 1				and:					[ self script watcherSelectors includes: selector ] ]! !!ReporterBlockMorph methodsFor: 'other' stamp: 'jm 3/30/2005 09:21'!computeHighlightColors	| h s v |	h := color hue.	s := color saturation.	v := color brightness.	highlightColor1 := Color h: h s: (s - 0.13) v: (v + 0.17).	highlightColor2 := Color h: h s: s v: (v + 0.06).	shadowColor := color mixed: 0.8 with: Color black.! !!ReporterBlockMorph methodsFor: 'drawing' stamp: 'jm 3/30/2005 09:37'!drawBooleanOn: aCanvas 	| right topY bottomY xInset c |	self computeHighlightColors.	right := self width.	topY := bottomY := self height // 2.	self height even ifTrue: [topY := bottomY - 1].	xInset := 0.	[topY >= 0] whileTrue: [		topY = 0 ifTrue: [c := highlightColor1].		topY = 1 ifTrue: [c := highlightColor2].		topY > 1 ifTrue: [c := color].		self drawHLineFrom: xInset to: right - xInset y: topY color: c on: aCanvas.		(topY > 1) & (xInset > 0) ifTrue: [			self drawPoint: xInset@topY color: highlightColor1 on: aCanvas.			self drawPoint: (right - xInset - 1)@topY color: shadowColor on: aCanvas].		c := bottomY = (self height - 1) ifTrue: [shadowColor] ifFalse: [color].		self drawHLineFrom: xInset to: right - xInset y: bottomY color: c on: aCanvas.		xInset > 0 ifTrue: [			self drawPoint: xInset@bottomY color: shadowColor on: aCanvas.			self drawPoint: (right - xInset - 1)@bottomY color: shadowColor on: aCanvas].		xInset := xInset + 1.			bottomY := bottomY + 1.		topY := topY - 1].! !!ReporterBlockMorph methodsFor: 'drawing' stamp: 'jm 3/30/2005 08:15'!drawNumericOn: aCanvas 	| right topY bottomY radius xInset c |	self computeHighlightColors.	right := self width.	topY := bottomY := radius := self height // 2.	self height even ifTrue: [topY := bottomY - 1].	[topY >= 0] whileTrue: [		xInset := radius - (radius squared - (radius - topY - 1) squared) sqrt rounded.		topY = 0 ifTrue: [c := highlightColor1].		topY = 1 ifTrue: [c := highlightColor2].		topY > 1 ifTrue: [c := color].		self drawHLineFrom: xInset to: right - xInset y: topY color: c on: aCanvas.		(xInset > 0) & (topY > 1) ifTrue: [			self drawPoint: xInset@topY color: highlightColor1 on: aCanvas.			self drawPoint: (right - xInset - 1)@topY color: highlightColor1 on: aCanvas].		c := bottomY = (self height - 1) ifTrue: [shadowColor] ifFalse: [color].		self drawHLineFrom: xInset to: right - xInset y: bottomY color: c on: aCanvas.		xInset > 0 ifTrue: [			self drawPoint: xInset@bottomY color: shadowColor on: aCanvas.			self drawPoint: (right - xInset - 1)@bottomY color: shadowColor on: aCanvas].		bottomY := bottomY + 1.		topY := topY - 1].! !!ReporterBlockMorph methodsFor: 'drawing' stamp: 'jm 3/28/2005 13:16'!drawOn: aCanvas 	self computeHighlightColors.	isBoolean		ifTrue: [self drawBooleanOn: aCanvas]		ifFalse: [self drawNumericOn: aCanvas].! !!ReporterBlockMorph methodsFor: 'object i/o' stamp: 'jm 5/15/2005 10:27'!fieldsVersion	^ 2! !!ReporterBlockMorph methodsFor: 'other' stamp: 'EiichiroIto 9/29/2016 17:35'!fixBlockLayout	"Update the positions of my submorphs."	| mList maxH h x y |	blockLayoutNeeded ifFalse: [^ self].	cachedForm := nil.	cachedFeedbackForm := nil.	mList := self nonControlFlowSubmorphs.	maxH := 0.	mList do: [:m |		(m isKindOf: ArgMorph) ifTrue: [m fixArgLayout].		(m isKindOf: BlockMorph) ifTrue: [m fixBlockLayout].		maxH := maxH max: m height].	h := (maxH + 4) max: 17.	x := isBoolean ifTrue: [8] ifFalse: [4].	(mList size > 0 and: [mList first isKindOf: StringMorph]) ifTrue: [x := x + 2].	mList do: [:m |		(m isKindOf: StringMorph) ifTrue: [m color: self labelColor].		y := (h - m height) // 2.		m position: self position + (x@y).		x := x + m width + 3].	x := x + (isBoolean ifTrue: [1] ifFalse: [-3]).	self extent: (x + 4) @ h.	(self meOrOwnerThatIsA: ScratchBlockPaletteMorph) ifNotNil: [		(self meOrOwnerThatIsA: ScratchBlockPaletteMorph) fixLayout].! !!ReporterBlockMorph methodsFor: 'watcher' stamp: 'jm 12/1/2007 20:49'!getAssociatedSprite	"Return my receiver."	^ receiver! !!ReporterBlockMorph methodsFor: 'object i/o' stamp: 'jm 5/15/2005 10:27'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	classVersion = 1 ifTrue: [^ self].	"fields added in version 2"	self initFieldsNamed: #(		isBoolean	) from: anObjStream.! !!ReporterBlockMorph methodsFor: 'initialization' stamp: 'jm 3/31/2005 19:39'!initialize	super initialize.	isBoolean := false.	self extent: 80@20.! !!ReporterBlockMorph methodsFor: 'other' stamp: 'jm 3/28/2005 12:59'!isBoolean: aBoolean	isBoolean := aBoolean.! !!ReporterBlockMorph methodsFor: 'other' stamp: 'jm 3/28/2005 19:14'!isBooleanReporter	^ isBoolean! !!ReporterBlockMorph methodsFor: 'other' stamp: 'jm 3/31/2005 19:38'!isReporter	"Answer true if this block reports a value."	^ true! !!ReporterBlockMorph methodsFor: 'object i/o' stamp: 'jm 5/11/2005 10:50'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		isBoolean	) on: anObjStream.! !!ReporterBlockMorph methodsFor: 'processes' stamp: 'EiichiroIto 9/13/2018 07:10'!toggleProcess	"do nothing"! !!VariableBlockMorph methodsFor: 'private' stamp: 'jens 11/18/2008 09:40'!addLabel	"Add a label for my command and arguments. 	This is the method that really creates the whole block."	"Details: This overrides the superclass method to allow 	using percent character in variable/list names"	commandSpec ifNil: [^ self].	self removeAllMorphs.	self addMorphBack: (self labelMorphFor: commandSpec).! !!VariableBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator variableArgString: self.! !!VariableBlockMorph methodsFor: 'private' stamp: 'jm 3/23/2005 10:57'!asBlockTuple	"Answer a tuple (Array) describing this block and its arguments."	^ Array with: #readVariable with: commandSpec! !!VariableBlockMorph methodsFor: 'watcher' stamp: 'TIS 6/19/2006 13:52'!canBecomeWatcher	"All variable blocks can become watchers when dragged onto the stage."	^ true! !!VariableBlockMorph methodsFor: 'evaluation' stamp: 'jm 11/15/2006 11:38'!evaluateWithArgs: args	"Overridden to read my variable value."	^ receiver getVar: commandSpec! !!VariableBlockMorph methodsFor: 'object i/o' stamp: 'jm 2/24/2004 18:24'!fieldsVersion	^ 1! !!VariableBlockMorph methodsFor: 'initialization' stamp: 'jm 2/23/2004 11:07'!initialize	super initialize.	commandSpec := ''.	self color: (Color r: 0.4 g: 1.0 b: 0.4).! !!VariableBlockMorph methodsFor: 'accessing' stamp: 'jm 2/23/2004 11:07'!isReporter	^ true! !!VariableBlockMorph methodsFor: 'testing' stamp: 'EiichiroIto 11/21/2019 11:15'!isVariableBlock	^ true! !!VariableBlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 21:18'!receiver: anObject	"Set my receiver object and, if possible, my block color."	receiver := anObject.	self color: ScratchTheme variableBlockColor darker! !!VariableBlockMorph methodsFor: 'watcher' stamp: 'jm 11/30/2007 12:26'!selectorAndArg	"Answer an array containing my selector and argument (if any)."	^ Array with: #getVar: with: self variable! !!VariableBlockMorph methodsFor: 'accessing' stamp: 'jm 12/13/2006 20:12'!variable	^ commandSpec! !!SetterBlockMorph methodsFor: 'private' stamp: 'jm 7/13/2008 23:04'!asBlockTuple	"Answer a tuple (Array) describing this block and its arguments."	| result arg |	result := Array with: #changeVariable with: self variable with: selector with: nil.	arg := (argMorphs first isKindOf: ChoiceArgMorph)		ifTrue: [argMorphs last]		ifFalse: [argMorphs first].	(arg isKindOf: ArgMorph)		ifTrue: [result at: 4 put: arg evaluate]		ifFalse: [result at: 4 put: arg asBlockTuple].	^ result! !!SetterBlockMorph methodsFor: 'accessing' stamp: 'jm 7/3/2008 16:09'!expressionArg	submorphs do: [:m |		(m isKindOf: ExpressionArgMorph) ifTrue: [^ m]].	^ nil! !!SetterBlockMorph methodsFor: 'object i/o' stamp: 'jm 12/1/2003 10:52'!fieldsVersion	^ 1! !!SetterBlockMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/22/2019 15:13'!initChangerForVar: varName	self commandSpec: 'change %v by %n'.	argPermutation := CommandBlockMorph		argPermutationForSpec: 'set %v to %n'		withTranslation: commandSpec.	self selector: #changeVar:by:.	self variable: varName! !!SetterBlockMorph methodsFor: 'object i/o' stamp: 'jm 7/13/2008 23:07'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		variable	) from: anObjStream.	self variable: variable.! !!SetterBlockMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/22/2019 15:13'!initSetterForVar: varName	self commandSpec: 'set %v to %n'.	argPermutation := CommandBlockMorph		argPermutationForSpec: 'set %v to %n'		withTranslation: commandSpec.	self selector: #setVar:to:.	self variable: varName! !!SetterBlockMorph methodsFor: 'initialization' stamp: 'jm 3/31/2005 19:38'!initialize	super initialize.	isSpecialForm := false.	isTimed := false.! !!SetterBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 21:15'!labelMorphFor: aString	| s |	s := aString.	"commandSpec isUnicode ifTrue: [s := UTF8 withAll: s]."	"self variable isUnicode ifTrue: [s := UTF8 withAll: s]."	^ (StringMorph contents: s font: (ScratchTheme labelFont))		color: self labelColor! !!SetterBlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 21:18'!receiver: anObject	"Set my receiver object and, if possible, my block color."	receiver := anObject.	self color: ScratchTheme variableBlockColor! !!SetterBlockMorph methodsFor: 'object i/o' stamp: 'jm 7/13/2008 23:07'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	variable := self variable.	self storeFieldsNamed: #(		variable	) on: anObjStream.! !!SetterBlockMorph methodsFor: 'accessing' stamp: 'jm 7/13/2008 23:04'!variable	submorphs do: [:m |		(m isKindOf: ChoiceArgMorph) ifTrue: [^ m choice]].	^ ''! !!SetterBlockMorph methodsFor: 'accessing' stamp: 'jm 7/13/2008 23:04'!variable: aVar	submorphs do: [:m |		(m isKindOf: ChoiceArgMorph) ifTrue: [^ m choice: aVar]].! !!EventHatMorph methodsFor: 'other' stamp: 'jm 3/28/2005 12:42'!asBlockTuple	"Answer a tuple (Array) describing this block and its event name."	^ Array with: self class name with: self eventName! !!EventHatMorph methodsFor: 'code generation' stamp: 'EiichiroIto 8/2/2019 14:08'!emitCode: aGenerator indent: indent	aGenerator emitEventHatBlock: self indent: indent.! !!EventHatMorph methodsFor: 'other' stamp: 'jm 3/28/2005 12:32'!eventName	"Answer the name of this script."	^ scriptNameMorph eventName! !!EventHatMorph methodsFor: 'other' stamp: 'EiichiroIto 11/21/2019 22:25'!eventName: aString	"Set my event name. Used for initialization."	scriptNameMorph eventName: aString.	self fixBlockLayout.	self applicationDo: [ :app | app updateContents ]! !!EventHatMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/22/2019 16:22'!for: aString event: aSymbol	| s |	super initialize.	self removeAllMorphs.	s := self newLabelString		contents: aString;		yourself.	self addMorphBack: s.	"create scriptNameMorph but don't add it"	scriptNameMorph := EventTitleMorph new eventName: aSymbol.	self fixBlockLayout! !!EventHatMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/22/2019 15:48'!forLoopEvent	self for: 'when loop' event: #loop! !!EventHatMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/22/2019 15:49'!forSetupEvent	self for: 'when setup' event: #setup! !!EventHatMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/22/2019 15:49'!forStartupEvent	self for: 'when setup' event: #startup! !!EventHatMorph methodsFor: 'initialization' stamp: 'EiichiroIto 9/29/2016 17:35'!forceLayout	"My UpdatingStringMorph calls this when its contents change"	self fixBlockLayout.	(self meOrOwnerThatIsA: ScratchBlockPaletteMorph) ifNotNil:[		(self meOrOwnerThatIsA: ScratchBlockPaletteMorph) fixLayout].! !!EventHatMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/22/2019 16:21'!initialize	| label |	super initialize.	self removeAllMorphs.	label := StringMorph		contents: 'when I receive'		font: ScratchTheme labelFont.	label color: Color white.	self addMorphBack: label.	scriptNameMorph := EventTitleMorph new.	self addMorphBack: scriptNameMorph! !!EventHatMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/22/2019 15:47'!newLabelString	^ StringMorph new		font: ScratchTheme labelFont;		color: Color white;		yourself! !!EventHatMorph methodsFor: 'other' stamp: 'jm 12/8/2005 19:21'!printHatNameOn: aStream	"Append a human-readable string for this hat block's name to the given stream."	| evtName |	evtName := self eventName.	evtName = 'Scratch-StartClicked'		ifTrue: [aStream nextPutAll: 'when green flag clicked']		ifFalse: [aStream nextPutAll: 'when I receive "', evtName, '"'].	aStream cr.! !!HatBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/22/2019 13:16'!blockAttachPoints: aSet	"Answer a collection of possible attachment points for me. Each entry is an Association mapping a point to the morph to which a dropping block could be attached."	| nextB |	nextB := self nextBlock.	nextB		ifNil: [ aSet add: self bottomLeft -> self ]		ifNotNil: [ nextB blockAttachPoints: aSet ]! !!HatBlockMorph methodsFor: 'drawing' stamp: 'ee 3/5/2008 16:13'!drawArchOn: aCanvas 	| archForm stretchX leftForm midForm rightForm y x |	archForm := self hatTopForm.	stretchX := archForm width - 22.	leftForm := archForm copy: (0@0 corner: stretchX@archForm height).	midForm := archForm copy: (stretchX@0 extent: 1@archForm height).	rightForm := archForm copy: ((stretchX + 1)@0 corner: archForm extent).		y := self top.	x := self left.	aCanvas paintImage: leftForm at: x@y.	x := x + leftForm width.	(self width - (leftForm width + rightForm width)) asInteger timesRepeat: [		aCanvas paintImage: midForm at: x@y.		x := x + 1].	aCanvas paintImage: rightForm at: x@y.! !!HatBlockMorph methodsFor: 'drawing' stamp: 'jm 3/31/2005 22:03'!drawBodyOn: aCanvas 	| archBottom |	archBottom := self top + self hatTopForm height.	self drawArchOn: aCanvas.	aCanvas		fillRectangle: (self left@archBottom corner: (self right - 1)@(self bottom - 7))		color: color.	aCanvas		fillRectangle: (self left@archBottom corner: (self left + 2)@(self bottom - 7))		color: highlightColor2.	aCanvas		fillRectangle: ((self right - 1)@(archBottom -  1) corner: self right@(self bottom - 7))		color: shadowColor.! !!HatBlockMorph methodsFor: 'drawing' stamp: 'ee 3/5/2008 16:11'!drawOn: aCanvas 	| c |	self computeHighlightColors.	c := FormCanvas extent: self extent depth: 32.	c := c copyOffset: self topLeft negated.	self drawBodyOn: c.	self drawBottomEdgeOn: c.	self drawFinalOn: aCanvas fromCanvas: c.! !!HatBlockMorph methodsFor: 'event handling' stamp: 'jm 3/28/2005 12:28'!duplicate	"Overridden to pick an unused script name for the duplicate."	| m |	m := self fullCopy.	scriptOwner ifNotNil: [m scriptOwner: scriptOwner].	self world activeHand attachMorph: m.! !!HatBlockMorph methodsFor: 'code generation' stamp: 'EiichiroIto 6/15/2018 07:24'!emitCode: aGenerator indent: indent	aGenerator emitHatBlock: self indent: indent.! !!HatBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:07'!fieldsVersion	^ 1! !!HatBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/22/2019 13:17'!fixBlockLayout	"Update the positions of my submorphs."	| x centerY nextB nonBlockSubmorphs oldExtent oldPos |	blockLayoutNeeded		ifFalse: [ ^ self ].	super fixBlockLayout.	oldExtent := self extent.	oldPos := self position.	x := self left + 8.	centerY := self top + 25.	self nonControlFlowSubmorphs		do: [ :m | 			m isArgMorph				ifTrue: [ m fixArgLayout ].			m position: x @ (centerY - (m height // 2)).			x := x + m width + 5 ].	x + x + 4.	self width: (x - self left max: self hatTopForm width).	nonBlockSubmorphs := self submorphs		select: [ :m | m isBlockMorph not or: [ m isArgMorph ] ].	self		height:			self hatTopForm height				+					(nonBlockSubmorphs						inject: CBlockBracketThickness						into: [ :h :m | h max: m height + 8 ]).	(nextB := self nextBlock)		ifNotNil: [ nextB left: self left.			nextB top: self bottom - 4.			nextB fixBlockLayout ]! !!HatBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 21:25'!hatTopForm	^ ScratchTheme formAt: #hatBlockTop! !!HatBlockMorph methodsFor: 'object i/o' stamp: 'jm 3/28/2005 12:47'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		scriptNameMorph		indicatorMorph		scriptOwner		parameters		isClickable	) from: anObjStream.	parameters := nil.  "procedures with parameters are no longer supported"	"remove the indicator morph when reading in an older project"	indicatorMorph ifNotNil: [		submorphs := submorphs copyWithout: indicatorMorph.		indicatorMorph := nil].! !!HatBlockMorph methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 21:16'!initialize	super initialize.	self color: (Color h: 41 s: 0.85 v: 0.9).	self extent: 92@38.	scriptOwner := nil.	scriptNameMorph := StringMorph new		contents: 'script';		font: (ScratchTheme labelFont);		color: Color white.	self addMorph: scriptNameMorph.! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 12/21/2008 12:22'!isHatBlock	^ true! !!HatBlockMorph methodsFor: 'private' stamp: 'jm 5/8/2007 11:16'!mapReceiver: oldObj to: newObj	"Used in cloning or importing to make blocks that refererred to the original object new refer to the new copy."	scriptOwner == oldObj ifTrue: [scriptOwner := newObj].! !!HatBlockMorph methodsFor: 'private' stamp: 'jm 12/8/2005 19:21'!printHatNameOn: aStream	"Append a human-readable string for this hat block's name to the given stream."	aStream nextPutAll: 'to ', scriptNameMorph contents; cr.! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 6/10/2004 10:47'!receiver	^ scriptOwner! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 3/5/2003 16:52'!scriptOwner	^ scriptOwner! !!HatBlockMorph methodsFor: 'accessing' stamp: 'ee 3/6/2008 18:07'!scriptOwner: anObject	scriptOwner := anObject.	self fixBlockLayout.! !!HatBlockMorph methodsFor: 'processes' stamp: 'EiichiroIto 11/21/2019 22:25'!start	self stop.	scriptOwner ifNil: [ ^ self ].	self applicationDo: [ :app | app startProcessFor: self ].	self changed! !!HatBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/28/2003 18:16'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		scriptNameMorph		indicatorMorph		scriptOwner		parameters		isClickable	) on: anObjStream.! !!SubHatMorph methodsFor: 'converting' stamp: 'EiichiroIto 9/11/2019 20:56'!asBlockTuple	^ Array with: self class name with: self subName! !!SubHatMorph methodsFor: 'code generation' stamp: 'EiichiroIto 9/11/2019 21:45'!emitCode: aGenerator indent: indent	aGenerator emitSubHatBlock: self indent: indent.! !!SubHatMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 9/12/2019 12:53'!fieldsVersion	^ 1! !!SubHatMorph methodsFor: 'private' stamp: 'EiichiroIto 9/11/2019 18:47'!forceLayout	self fixBlockLayout.	(self meOrOwnerThatIsA: ScratchBlockPaletteMorph)		ifNotNil: [ :morph | morph fixLayout ]! !!SubHatMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 9/12/2019 12:54'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		subName	) from: anObjStream! !!SubHatMorph methodsFor: 'initialization' stamp: 'EiichiroIto 9/11/2019 21:12'!initialize	super initialize.	subName := ''.! !!SubHatMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 9/12/2019 12:54'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		subName	) on: anObjStream! !!SubHatMorph methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 21:12'!subName	^ subName! !!SubHatMorph methodsFor: 'accessing' stamp: 'EiichiroIto 11/21/2019 22:26'!subName: aString	subName := aString.	scriptNameMorph contents: ('Sub ', aString).	self fixBlockLayout.	self applicationDo: [ :app | app updateContents ]! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 10/26/2008 17:38'!areasRemainingToFill: aRectangle	"Drawing optimization. Since I completely fill my bounds with opaque pixels, this method tells Morphic that it isn't necessary to draw any morphs covered by me."		^ aRectangle areasOutside: self bounds! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 10/26/2008 10:54'!drawBackgroundOn: aCanvas	"Draw my background."	color isTransparent ifTrue: [^ self].	aCanvas		fillRectangle: ((myBox origin + topLeftForm extent) corner: (myBox corner - bottomRightForm extent))		color: color.! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 10/25/2008 23:58'!drawBottomEdgeOn: aCanvas	"Draw my bottom edge."	| r f |	r := ((myBox left + topLeftForm width) @ (myBox bottom - bottomEdgeForm height)) corner: ((myBox right - bottomRightForm width) @ myBox bottom).	(r intersects: aCanvas clipRect) ifFalse: [^ self].	f := edgeCache at: 3.	(f isNil or: [f extent ~= r extent]) ifTrue: [		f := Form extent: r extent depth: 32.		0 to: r width by: bottomEdgeForm width do: [:x | bottomEdgeForm displayOn: f at: x@0 rule: Form over].		edgeCache at: 3 put: f].	aCanvas translucentImage: f at: r topLeft.! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 10/20/2008 16:02'!drawCornersOn: aCanvas	"Draw my corners if they intersect the canvas clipping box."	| clipR p |	clipR := aCanvas clipRect.	p := myBox topLeft.	((p extent: topLeftForm extent) intersects: clipR) ifTrue: [		aCanvas translucentImage: topLeftForm at: p].	p := (myBox right - topRightForm width)@myBox top.	((p extent: topRightForm extent) intersects: clipR) ifTrue: [		aCanvas translucentImage: topRightForm at: p].	p := myBox left@(myBox bottom - bottomLeftForm height).	((p extent: bottomLeftForm extent) intersects: clipR) ifTrue: [		aCanvas translucentImage: bottomLeftForm at: p].	p := (myBox right - bottomRightForm width)@(myBox bottom - bottomRightForm height).	((p extent: bottomRightForm extent) intersects: clipR) ifTrue: [		aCanvas translucentImage: bottomRightForm at: p].! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 10/26/2008 00:11'!drawFrameOn: aCanvas	"Draw my edges and corners. Draw a simple border if any of my forms is nil."	(topLeftForm isNil | topRightForm isNil | bottomLeftForm isNil | bottomRightForm isNil |	 topEdgeForm isNil | leftEdgeForm isNil | rightEdgeForm isNil | bottomEdgeForm isNil)		ifTrue: [^ aCanvas frameRectangle: self bounds width: 3 color: Color red].	"draw edges"	self drawTopEdgeOn: aCanvas.	self drawLeftEdgeOn: aCanvas.	self drawRightEdgeOn: aCanvas.	self drawBottomEdgeOn: aCanvas.	self drawCornersOn: aCanvas.! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 10/25/2008 23:55'!drawLeftEdgeOn: aCanvas	"Draw my left edge."	| r f |	r := (myBox left @ (myBox top + topLeftForm height)) corner: ((myBox left + leftEdgeForm width) @ (myBox bottom - bottomLeftForm height)).	(r intersects: aCanvas clipRect) ifFalse: [^ self].	f := edgeCache at: 1.	(f isNil or: [f extent ~= r extent]) ifTrue: [		f := Form extent: r extent depth: 32.		0 to: r height by: leftEdgeForm height do: [:y | leftEdgeForm displayOn: f at: 0@y rule: Form over].		edgeCache at: 1 put: f].	aCanvas translucentImage: f at: r topLeft.! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 10/26/2008 10:54'!drawOn: aCanvas	"Draw my background."	"myBox has integer position and extent and has a potentially inset bottom"	myBox := bounds origin truncated corner: (bounds right@self insetBottom) truncated.	self drawBackgroundOn: aCanvas.	frameInFront ifFalse: [self drawFrameOn: aCanvas].! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 10/25/2008 23:54'!drawRightEdgeOn: aCanvas	"Draw my right edge."	| r f |	r := ((myBox right - rightEdgeForm width) @ (myBox top + topRightForm height)) corner: (myBox right @ (myBox bottom - bottomRightForm height)).	(r intersects: aCanvas clipRect) ifFalse: [^ self].	f := edgeCache at: 4.	(f isNil or: [f extent ~= r extent]) ifTrue: [		f := Form extent: r extent depth: 32.		0 to: r height by: rightEdgeForm height do: [:y | rightEdgeForm displayOn: f at: 0@y rule: Form over].		edgeCache at: 4 put: f].	aCanvas translucentImage: f at: r topLeft.! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 10/25/2008 23:57'!drawTopEdgeOn: aCanvas	"Draw my top edge."	| r f |	r := ((myBox left + topLeftForm width) @ myBox top) corner: ((myBox right - topRightForm width) @ (myBox top + topEdgeForm height)).	(r intersects: aCanvas clipRect) ifFalse: [^ self].	f := edgeCache at: 2.	(f isNil or: [f extent ~= r extent]) ifTrue: [		f := Form extent: r extent depth: 32.		0 to: r width by: topEdgeForm width do: [:x | topEdgeForm displayOn: f at: x@0 rule: Form over].		edgeCache at: 2 put: f].	aCanvas translucentImage: f at: r topLeft.! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'EiichiroIto 9/15/2016 12:55'!fullDrawOn: aCanvas	"Draw my frame in front of my submorphs."	| clipC |	self visible ifFalse: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^ self drawErrorOn: aCanvas].	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	"myBox has integer position and extent and has a potentially inset bottom"	myBox := bounds truncated.	clipC := aCanvas copyClipRect: myBox.	frameInFront		ifTrue: [			self drawOn: clipC.			self drawSubmorphsOn: clipC.			self drawFrameOn: clipC]		ifFalse: [			self drawOn: clipC.			self drawSubmorphsOn: clipC].! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 5/14/2005 19:32'!hasTranslucentColor	^ true! !!ImageFrameMorph methodsFor: 'intialization' stamp: 'jm 5/14/2005 16:04'!initFromForm: aForm	"Initialize myself by cutting up the given Form. The corners are taken to extend to one pixel short of the center in each dimension. A one-pixel strip from the center of each edge will be replicated to stretch the edge. The color of the center pixel of the rectangle will be used as the fill color. (You can suppress color filling by setting my color to transparent after calling this method)."	| cornerExtent center |	cornerExtent := (aForm extent - 1) // 2.	center := aForm extent // 2.	topLeftForm := (aForm copy: (0@0 extent: cornerExtent)).	topRightForm := (aForm copy: ((aForm width - cornerExtent x) @ 0 extent: cornerExtent)).	bottomLeftForm := (aForm copy: (0 @ (aForm height - cornerExtent y) extent: cornerExtent)).	bottomRightForm := (aForm copy: ((aForm extent - cornerExtent) extent: cornerExtent)).	topEdgeForm := (aForm copy: ((center x@0) extent: (1 @ cornerExtent y))).	leftEdgeForm := (aForm copy: ((0 @ center y) extent: (cornerExtent x @ 1))).	rightEdgeForm := (aForm copy: (((aForm width - cornerExtent x) @ center y) extent: (cornerExtent x @ 1))).	bottomEdgeForm := (aForm copy: ((center x@(aForm height - cornerExtent y)) extent: (1 @ cornerExtent y))).	color := aForm colorAt: center.! !!ImageFrameMorph methodsFor: 'intialization' stamp: 'EiichiroIto 9/17/2018 09:10'!initFrontFromForm: aForm	"Initialize myself so that my frame is drawn in front of my submorphs, like a picture frame."	| c f |	frameInFront := true.	c := (aForm colorAt: aForm extent // 2).	f := aForm deepCopy.	"f shapeFill: Color transparent interiorPoint: aForm extent // 2."	self initFromForm: f.	color := c.! !!ImageFrameMorph methodsFor: 'intialization' stamp: 'jm 12/9/2008 12:26'!initialize	super initialize.	color := Color transparent.	frameInFront := false.	edgeCache := Array new: 5.	self extent: 100@100.! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 11/29/2006 16:30'!insetBottom	^ self bottom! !!ImageFrameMorph methodsFor: 'accessing' stamp: 'jm 2/7/2008 08:54'!minExtent	"Answer my minimum extent."	^ (topLeftForm width + topEdgeForm width + topRightForm width) @	  (topLeftForm height + leftEdgeForm height + bottomLeftForm height)! !!ImageFrameMorph methodsFor: 'private' stamp: 'EiichiroIto 9/30/2016 17:16'!orgMinExtent	^ super minExtent! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/18/2016 17:18'!allowSubmorphExtraction	"Return true if this morph allows its submorphs to be extracted just by grabbing them."	self isPartsBin ifTrue: [^ false].	^ self dragNDropEnabled or: [self dragEnabled]! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/22/2016 22:25'!beep	"do nothing"! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/19/2016 19:26'!copyRecordingIn: deepCopier	"Recursively copy this entire composite morph, recording the correspondence between old and new morphs in the given dictionary. This dictionary will be used to update intra-composite references in the copy. See updateReferencesUsing:.	Note: This default implementation copies ONLY morphs in the submorph hierarchy. If a subclass stores morphs in instance variables that it wants to copy, then it should override this method to do so. The same goes for subclasses that contain other data that should be copied when the morph is duplicated."	| new |	new := self copyWithoutSubmorphs.	deepCopier references at: self put: new.	submorphs size > 0 ifTrue: [		new privateSubmorphs:			(submorphs collect: [:m |				(m copyRecordingIn: deepCopier) privateOwner: new])].	extension ifNotNil: [new privateExtension: (extension veryDeepCopyWith: deepCopier)].	^ new! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/19/2016 19:29'!copyWithoutSubmorphs	^ self shallowCopy		privateOwner: nil;		privateSubmorphs: Array empty;		privateBounds: (bounds origin corner: bounds corner)  "deep-copy bounds"! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 19:52'!fieldsVersion	^ 1! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/19/2016 19:27'!fullCopy	"Produce a copy of me with my entire tree of submorphs. Morphs mentioned more than once are all directed to a single new copy. Simpleinst vars are not copied, so you must override to copy Arrays, Forms, editable text, etc."	| copier new |	copier := DeepCopier new initialize: 4096.	new := self copyRecordingIn: copier.	new allMorphsDo: [:m | m updateReferencesUsing: copier].	^ new! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/30/2016 20:49'!initFieldsFrom: anObjStream version: classVersion	"Set my instance variables from the given object stream."	self initFieldsNamed: #(		bounds		owner		submorphs		color		flags	) from: anObjStream.	anObjStream nextField.  "placeholder for properties"	fullBounds := nil.! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/21/2019 11:08'!isArgMorph	"True only for ArgMorphs."	^ false! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/21/2019 11:06'!isBlockMorph	"True only for BlockMorphs."	^ false! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/21/2019 07:24'!isBlockPalette	^ false! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/21/2019 11:18'!isCommandBlock	^ false! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/21/2019 11:14'!isCommentMorph	^ false! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/18/2016 17:22'!isPartsBin	^ false! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/18/2016 17:17'!isPartsDonor	^ self valueOfProperty: #isPartsDonor ifAbsentPut: [ false ]! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/18/2016 17:18'!isPartsDonor: aBoolean	self setProperty: #isPartsDonor toValue: aBoolean! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/21/2019 07:24'!isScriptEditor	^ false! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/22/2019 20:58'!isStageMorph	^ false! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/14/2016 22:20'!mayNeedLayout	"Answer true if something has occured that might require my layout to change That is, if layoutChanged has been sent to me or any of my submorphs."	^ fullBounds isNil! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/29/2016 17:33'!meOrOwnerThatIsA: aClass	"Answer this the first morph in the owner chain of the given class, or nil if there isn't one."	| current |	current := self.	[ current == nil ]		whileFalse: [ 			(current isKindOf: aClass)				ifTrue: [ ^ current ].			current := current owner ].	^ current! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/18/2016 17:19'!rootForGrabOf: aMorph	"Answer the root of the morph structure to be picked up when the given morph is grabbed."	(self isSticky and: [self isPartsDonor not])		ifTrue: [^ nil]		ifFalse: [			(owner isNil or: [owner isWorldOrHandMorph])				ifTrue: [^ self]				ifFalse: [					owner allowSubmorphExtraction						ifTrue: [^ self]						ifFalse: [^ owner rootForGrabOf: aMorph]]].! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 10:05'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(		bounds		owner		submorphs		color		flags	) on: anObjStream.	anObjStream putField: nil.  "placeholder for properties"! !!Morph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/19/2016 19:36'!updateReferencesUsing: deepCopier	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot. It may beoverridden to avoid this behavior if so desired."	| old |	Morph instSize + 1 to: self class instSize do: [:i |		old := self instVarAt: i.		old isMorph ifTrue:			[self instVarAt: i put: (deepCopier references at: old ifAbsent: [old])]].	"map morph values in my properties list"	self privateExtension: (extension veryDeepCopyWith: deepCopier)! !!ScratchScrollBar class methodsFor: 'instance creation' stamp: 'jm 5/26/2005 18:17'!newHorizontal	"Answer a new horizontal scrollbar."	^ self new initVertical: false! !!ScratchScrollBar class methodsFor: 'instance creation' stamp: 'jm 5/26/2005 18:17'!newVertical	"Answer a new vertical scrollbar."	^ self new initVertical: true! !!ScratchScrollBar methodsFor: 'drawing' stamp: 'jm 4/5/2005 21:27'!drawHEdge: aForm from: startX to: endX yOffset: yOffset on: aCanvas	"Use the given form starting at the given point to draw a horizontal edge between the given starting and ending x positions. Do nothing if the given form is nil."	| x y |	aForm ifNil: [^ self].	x := startX.	y := bounds top + yOffset.	[x <= endX] whileTrue: [		aCanvas translucentImage: aForm at: x@y.		x := x + aForm width].! !!ScratchScrollBar methodsFor: 'drawing' stamp: 'ee 2/12/2009 16:26'!drawHSliderOn: aCanvas	"Draw a horizontal slider on the given canvas."	| y leftX rightX |	sliderLength = self maxSliderLength ifTrue: [^ self].	y := self top + sliderInsets top.	leftX := self left + sliderInsets left + sliderStart.	rightX := leftX + sliderLength.	self drawHEdge: sliderMiddleForm		from: leftX + sliderStartForm width		to: (rightX - sliderEndForm width)		yOffset: sliderInsets top		on: aCanvas.	aCanvas translucentImage: sliderStartForm at: (leftX @ y).	aCanvas translucentImage: sliderEndForm at: ((rightX - sliderEndForm width + 1) @ y).! !!ScratchScrollBar methodsFor: 'drawing' stamp: 'jm 5/26/2005 18:48'!drawOn: aCanvas	"Draw myself, clipping to my bounds."	| clipC |	clipC := aCanvas copyClipRect: self bounds.	self bounds isWide		ifTrue: [			"draw horizontal frame"			self drawHEdge: frameMiddleForm				from: (self left + frameStartForm width)				to: (self right - frameEndForm width)				yOffset: 0				on: clipC.			clipC translucentImage: frameStartForm at: self topLeft.			clipC translucentImage: frameEndForm at: ((self right + 1 - frameEndForm width) @ self top).			self drawHSliderOn: clipC]			ifFalse: [			"draw vertical frame"			self drawVEdge: frameMiddleForm				from: (self top + frameStartForm height)				to: (self bottom - frameEndForm height)				xOffset: 0				on: clipC.			clipC translucentImage: frameStartForm at: self topLeft.			clipC translucentImage: frameEndForm at: (self left @ (self bottom + 1 - frameEndForm height)).			self drawVSliderOn: clipC].! !!ScratchScrollBar methodsFor: 'drawing' stamp: 'jm 4/5/2005 21:27'!drawVEdge: aForm from: startY to: endY xOffset: xOffset on: aCanvas	"Use the given form starting at the given point to draw a vertical edge between the given starting and ending y positions. Do nothing if the given form is nil."	| x y |	aForm ifNil: [^ self].	x := bounds left + xOffset.	y := startY.	[y <= endY] whileTrue: [		aCanvas translucentImage: aForm at: x@y.		y := y + aForm height].! !!ScratchScrollBar methodsFor: 'drawing' stamp: 'ee 2/11/2009 13:38'!drawVSliderOn: aCanvas	"Draw a vertical slider on the given canvas."	| x topY bottomY |	sliderLength = self maxSliderLength ifTrue: [^ self].	x := self left + sliderInsets left.	topY := self top + sliderInsets top + sliderStart.	bottomY := topY + sliderLength.	self drawVEdge: sliderMiddleForm		from: topY + sliderStartForm height		to: (bottomY - sliderEndForm height)		xOffset: sliderInsets left		on: aCanvas.	aCanvas translucentImage: sliderStartForm at: (x @ topY).	aCanvas translucentImage: sliderEndForm at: (x @ (bottomY - sliderEndForm height + 1)).! !!ScratchScrollBar methodsFor: 'initialization' stamp: 'ee 2/11/2009 13:40'!hFrameForm: frameForm sliderForm: sliderForm	"Initialize myself as a horizontal slider, setting my forms by cutting up the given forms."	| midX h |	"set my forms"	midX := frameForm height // 2.	h := frameForm height.	frameStartForm := frameForm copy: (0@0 extent: midX@h).	frameMiddleForm := frameForm copy: (midX@0 extent: 1@h).	frameEndForm := frameForm copy: ((midX + 1)@0 corner: frameForm extent).	h := sliderForm height.	sliderStartForm := sliderForm copy: (0@0 extent: 7@h).	sliderMiddleForm := sliderForm copy: (7@0 extent: 1@h).	sliderEndForm := sliderForm copy: (8@0 corner: sliderForm extent).	sliderInsets := 3@3 corner: 3@5.	self extent: 200 @ frameStartForm height.! !!ScratchScrollBar methodsFor: 'event handling' stamp: 'jm 3/27/2005 10:53'!handlesMouseDown: evt	^ true! !!ScratchScrollBar methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 21:44'!initVertical: aBoolean	aBoolean		ifTrue: [		 	self vFrameForm: (ScratchTheme formAt: #vScrollFrame)				sliderForm: (ScratchTheme formAt: #vScrollSlider)]		ifFalse: [		 	self hFrameForm: (ScratchTheme formAt: #hScrollFrame)				sliderForm: (ScratchTheme formAt: #hScrollSlider)].! !!ScratchScrollBar methodsFor: 'initialization' stamp: 'jm 5/26/2005 18:32'!initialize	super initialize.	target := nil.	selector := nil.	sliderStart := 0.	sliderLength := 50.	sliderInsets := 3@3 corner: 0@5.	dragOffset := 0.! !!ScratchScrollBar methodsFor: 'event handling' stamp: 'jm 2/1/2005 11:20'!linearOffset: evt	"Answer the linear position of the given event's cursor point along my slider's range. For example, this will be zero at the leftmost/topmost edge of the slider's range."	bounds isWide		ifTrue: [^ evt cursorPoint x - (self left + sliderInsets left)]  "horizontal"		ifFalse: [^ evt cursorPoint y - (self top + sliderInsets top)].  "vertical"! !!ScratchScrollBar methodsFor: 'event handling' stamp: 'jm 3/14/2005 14:54'!maxSliderLength	"Answer the maximum slider length."	bounds isWide		ifTrue: [^ bounds width - (sliderInsets left + sliderInsets right)]		ifFalse: [^ bounds height - (sliderInsets top + sliderInsets bottom)].! !!ScratchScrollBar methodsFor: 'event handling' stamp: 'jm 3/14/2005 14:56'!maxSliderStart	"Answer the maximum sliderStart value given the slider's length."	bounds isWide		ifTrue: [^ bounds width - (sliderLength + sliderInsets left + sliderInsets right)]		ifFalse: [^ bounds height - (sliderLength + sliderInsets top + sliderInsets bottom)].! !!ScratchScrollBar methodsFor: 'event handling' stamp: 'ee 2/12/2009 16:26'!minSliderLength	"Answer the minimum slider length."	bounds isWide		ifTrue: [^ sliderEndForm width + sliderEndForm width]		ifFalse: [^ sliderEndForm height + sliderEndForm height].! !!ScratchScrollBar methodsFor: 'event handling' stamp: 'jm 3/27/2005 11:05'!mouseDown: evt	"Record the offset between the slider's start offset and the relative event's location."	| offset pageDelta |	dragOffset := nil.	self maxSliderLength = sliderLength ifTrue: [^ self].  "do nothing"	offset := self linearOffset: evt.	((offset >= sliderStart) & (offset <= (sliderStart + sliderLength)))		ifTrue: [  "mouse went down on the slider: start dragging it"			dragOffset := sliderStart - offset].	"handle page up or down"	pageDelta := sliderLength / self maxSliderLength.	offset < sliderStart		ifTrue: [self scrollFraction: self scrollFraction - pageDelta; updateTarget]		ifFalse: [self scrollFraction: self scrollFraction + pageDelta; updateTarget]! !!ScratchScrollBar methodsFor: 'event handling' stamp: 'jm 3/27/2005 10:32'!mouseMove: evt	"Update the slider position if in drag mode."	dragOffset ifNil: [^ self].  "not in slider drag mode"	sliderStart := (self linearOffset: evt) + dragOffset.	sliderStart := (sliderStart max: 0) min: (self maxSliderStart).	self updateTarget.	self changed.! !!ScratchScrollBar methodsFor: 'scroll bar protocol' stamp: 'jm 11/12/2005 13:54'!percentVisible: percentVisible	"Supply an optional floating fraction so slider can expand to indicate the percent of the content that is visible."	sliderLength := ((percentVisible min: 1.0) * self maxSliderLength) rounded.	sliderLength := sliderLength max: self minSliderLength.	sliderLength = self maxSliderLength ifTrue: [self scrollFraction: 0].	self changed.! !!ScratchScrollBar methodsFor: 'scroll bar protocol' stamp: 'jm 2/1/2005 14:43'!scrollDelta: ignore1 pageDelta: ignore2	"For compatability with old scrollbars. I don't support paging or scrolling arrows."! !!ScratchScrollBar methodsFor: 'accessing' stamp: 'jm 3/14/2005 14:58'!scrollFraction	"Answer the scroll fraction, a number between 0.0 and 1.0."	| maxStart |	(maxStart := self maxSliderStart) = 0 ifTrue: [^ 0.0].	^ sliderStart asFloat / maxStart! !!ScratchScrollBar methodsFor: 'accessing' stamp: 'jm 2/23/2005 15:02'!scrollFraction: aNumber	"Set my scroll fraction, a number between 0.0 and 1.0."	sliderStart := (((aNumber asFloat min: 1.0) max: 0.0) * self maxSliderStart) rounded.	self changed.! !!ScratchScrollBar methodsFor: 'accessing' stamp: 'jm 2/1/2005 14:41'!selector: aSymbol	selector := aSymbol.! !!ScratchScrollBar methodsFor: 'accessing' stamp: 'jm 2/1/2005 14:41'!target: anObject	target := anObject.! !!ScratchScrollBar methodsFor: 'scroll bar protocol' stamp: 'jm 2/23/2005 14:49'!updateTarget	"Update my target object with my current value, a number between 0.0 and 1.0. Do nothing if either my target or my selector is nil."	target notNil & selector notNil		ifTrue: [target perform: selector with: self scrollFraction].! !!ScratchScrollBar methodsFor: 'initialization' stamp: 'ee 2/11/2009 13:38'!vFrameForm: frameForm sliderForm: sliderForm	"Initialize myself as a vertical slider, setting my forms by cutting up the given forms."	| midY w |	"set my forms"	midY := frameForm height // 2.	w := frameForm width.	frameStartForm := frameForm copy: (0@0 extent: w@midY).	frameMiddleForm := frameForm copy: (0@midY extent: w@1).	frameEndForm := frameForm copy: (0@(midY + 1) corner: frameForm extent).	w := sliderForm width.	sliderStartForm := sliderForm copy: (0@0 extent: w@7).	sliderMiddleForm := sliderForm copy: (0@(7) extent: w@1).	sliderEndForm := sliderForm copy: (0@(11) corner: sliderForm extent).	sliderInsets := 3@3 corner: 0@5.	self extent: frameStartForm width @ 200.! !!ScratchScrollBar methodsFor: 'scroll bar protocol' stamp: 'jm 2/23/2005 15:01'!value: scrollFraction	"Set my scroll fraction (range is 0.0 to 1.0). This method is for compatability with ScrollBar."	self scrollFraction: scrollFraction.! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'ee 7/1/2008 15:06'!action	^ actionSelector! !!ResizableToggleButton2 methodsFor: 'layout' stamp: 'ee 6/13/2008 18:26'!centerLabelOffset: anInteger	"Center the label horizontally with the given offset."	justification := #center.	hOffset := anInteger.	self updateLayout.! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'jm 1/17/2008 13:16'!color	current ifNil: [^ Color white].	^ current color! !!ResizableToggleButton2 methodsFor: 'event handling' stamp: 'jm 2/28/2008 14:54'!copyRecordingIn: dict	"Copy frame morphs for all states."	| result |	result := super copyRecordingIn: dict.	normal ifNotNil: [result normal: (normal copyRecordingIn: dict)].	pressed ifNotNil: [result pressed: (pressed copyRecordingIn: dict)].	over ifNotNil: [result over: (over copyRecordingIn: dict)].	^ result! !!ResizableToggleButton2 methodsFor: 'geometry' stamp: 'ee 6/13/2008 18:26'!extent: aPoint	super extent: aPoint.	current ifNotNil: [current extent: aPoint].	self updateLayout.	iconMorph ifNotNil: [		iconMorph position: self position + ((self extent - iconMorph extent) // 2)].! !!ResizableToggleButton2 methodsFor: 'event handling' stamp: 'nb 1/14/2008 18:35'!handlesMouseOver: evt		^ true! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'jm 2/19/2008 00:02'!icon: aForm	"Add an icon to this button."	iconMorph ifNotNil: [iconMorph delete].  "delete old icon"	iconMorph := ImageMorph new form: aForm.	self addMorph: iconMorph.	self extent: (iconMorph extent + 10).! !!ResizableToggleButton2 methodsFor: 'initialization' stamp: 'jm 7/1/2008 10:20'!initialize	super initialize.	self cornerStyle: #square.	color := Color transparent.	borderWidth := 0.	isOn := false.	toggleButtonMode := false.	toggleMode := true.	justification := #center.	hOffset := 0.	vOffset := 5.	padding := 8@8.	label2 := StringMorph new.	labelColorOff := Color r: (78/255) g: (82/255) b: (82/255).	labelColorOn := Color black.	labelColorOver := labelColorOff.! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'nb 1/8/2008 14:16'!isOn	^ isOn! !!ResizableToggleButton2 methodsFor: 'event handling' stamp: 'EiichiroIto 11/16/2019 17:39'!keyStroke: evt	| ch m |	ch := evt unicodeChar.	ch = 0 ifTrue: [ch := evt keyValue].	ch = 9 ifTrue: [  "tab"		"(m := self meOrOwnerThatIsA: DialogBoxMorph) ifNotNil: [m tabToNextField: evt]."		^ self].	ch = 27 ifTrue: [  "escape key"		"(m := self meOrOwnerThatIsA: DialogBoxMorph) ifNotNil: [m escapeKeyPressed: evt]."		^ self].	(ch = 10) | (ch = 13) ifTrue: [  "cr, lf, or enter key"		"(m := self meOrOwnerThatIsA: DialogBoxMorph) ifNotNil: [^ m enterKeyPressed: evt]."		evt hand newKeyboardFocus: nil.		^ self].! !!ResizableToggleButton2 methodsFor: 'event handling' stamp: 'ee 4/16/2009 13:45'!keyboardFocusChange: aBoolean	aBoolean		ifTrue: [self on]		ifFalse: [self off].! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'nb 3/30/2008 16:51'!label	^ label2! !!ResizableToggleButton2 methodsFor: 'initialization' stamp: 'EiichiroIto 9/15/2016 10:33'!label: aString font: font	label2 delete.	label2		contents: aString;		font: font;		color: (isOn ifTrue: [labelColorOn] ifFalse: [labelColorOff]).	self addMorphFront: label2.	self updateSize.! !!ResizableToggleButton2 methodsFor: 'private' stamp: 'nb 1/14/2008 14:11'!labelColorOn: onColor labelColorOff: offColor labelColorOver: overColor		labelColorOn := onColor.	labelColorOff := offColor.	labelColorOver := overColor.	isOn ifTrue: [ label2 color: onColor ] ifFalse: [ label2 color: offColor ].! !!ResizableToggleButton2 methodsFor: 'layout' stamp: 'ee 6/13/2008 18:27'!leftJustifyInset: anInteger	"Left-justify the label with the given inset from the left edge."	justification := #left.	hOffset := anInteger.	self updateLayout.! !!ResizableToggleButton2 methodsFor: 'event handling' stamp: 'EiichiroIto 9/3/2019 21:24'!mouseDown: evt	"evt hand toolType: nil."	wasOn := isOn.	evt hand newKeyboardFocus: nil.	evt yellowButtonPressed ifTrue: [		Sensor waitNoButton.		^ self rightButtonMenu].	toggleButtonMode		ifTrue: [			toggleMode				ifTrue: [					isOn						ifTrue: [isOn := false. self over]						ifFalse: [self on]]				ifFalse: [					isOn						ifTrue: [^ self]						ifFalse: [self on]]]		ifFalse: [self on].	actWhen = #buttonDown ifTrue: [		self doButtonAction.		self off].! !!ResizableToggleButton2 methodsFor: 'event handling' stamp: 'nb 1/14/2008 19:48'!mouseEnter: evt	self over.! !!ResizableToggleButton2 methodsFor: 'event handling' stamp: 'EiichiroIto 11/21/2019 06:59'!mouseLeave: evt	isOn ifFalse: [ over ifNotNil: [self off] ].! !!ResizableToggleButton2 methodsFor: 'event handling' stamp: 'jm 7/21/2008 08:53'!mouseMove: evt 	| containsPoint |	actWhen = #buttonDown ifTrue: [^ self].	containsPoint := self containsPoint: evt cursorPoint.	toggleButtonMode		ifFalse: [			containsPoint				ifTrue: [isOn ifFalse: [self on]]				ifFalse: [isOn ifTrue: [self off]]]		ifTrue: [			toggleMode				ifTrue: [					containsPoint						ifTrue: [							wasOn								ifTrue: [isOn ifTrue: [isOn := false. self over]]								ifFalse: [isOn ifTrue: [^ self] ifFalse: [self on]]]						ifFalse: [							wasOn								ifTrue: [isOn ifFalse: [self on]]								ifFalse: [isOn ifTrue: [self off]]]]				ifFalse: [					containsPoint						ifTrue: [							wasOn								ifTrue: [^ self]								ifFalse: [isOn ifFalse: [self on]]]						ifFalse: [							wasOn								ifTrue: [^ self]								ifFalse: [isOn ifTrue: [isOn := false. self over]]]]].! !!ResizableToggleButton2 methodsFor: 'event handling' stamp: 'nb 1/14/2008 14:51'!mouseUp: evt		(actWhen = #buttonUp and:	 [self containsPoint: evt cursorPoint])		ifTrue: [self doButtonAction].	toggleButtonMode ifFalse: [ self off ].! !!ResizableToggleButton2 methodsFor: 'private' stamp: 'jm 2/28/2008 14:53'!normal: aMorph	normal := aMorph.! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'jm 2/8/2008 08:23'!off	"Turn myself off."	isOn := false.	self setCurrent: normal.	label2 color: labelColorOff.! !!ResizableToggleButton2 methodsFor: 'initialization' stamp: 'jm 7/1/2008 10:26'!offForm: offForm onForm: onForm	normal := ImageFrameMorph new initFromForm: offForm.	pressed := ImageFrameMorph new initFromForm: onForm.	over := nil.	current := normal.	padding := normal minExtent - (0@5).	toggleMode := false.	self off.! !!ResizableToggleButton2 methodsFor: 'initialization' stamp: 'jm 2/11/2008 11:37'!offForm: offForm onForm: onForm overForm: overForm	self offForm: offForm onForm: onForm.	overForm ifNotNil: [over := ImageFrameMorph new initFromForm: overForm].! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'jm 2/8/2008 08:23'!on	"Turn myself on."	isOn := true.	self setCurrent: pressed.	label2 color: labelColorOn.! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'ee 8/8/2008 20:56'!over	"Show my over skin."	"toggleButtonMode ifFalse: [^ self]."	isOn ifTrue: [^ self].	over ifNil: [^ self].	self setCurrent: over.	label2 color: labelColorOver.! !!ResizableToggleButton2 methodsFor: 'private' stamp: 'jm 2/28/2008 14:53'!over: aMorph	over := aMorph.! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'jm 7/1/2008 10:21'!padding: aPoint	padding := aPoint.! !!ResizableToggleButton2 methodsFor: 'private' stamp: 'jm 2/28/2008 14:53'!pressed: aMorph	pressed := aMorph.! !!ResizableToggleButton2 methodsFor: 'layout' stamp: 'ee 6/13/2008 18:27'!rightJustifyInset: anInteger	"Right-justify the label with the given inset from the right edge."	justification := #right.	hOffset := anInteger.	self updateLayout.! !!ResizableToggleButton2 methodsFor: 'private' stamp: 'jm 2/8/2008 08:23'!setCurrent: aMorph	"Make the given morph be the one currently displayed."	aMorph ifNil: [^ self].  "should not happen"	aMorph		position: self position;		extent: self extent.	current delete.	current := aMorph.	self addMorphBack: current.! !!ResizableToggleButton2 methodsFor: 'initialization' stamp: 'nb 1/8/2008 14:16'!setDefaultLabel	"Overridden to do nothing. I have no label by default, although a label can be added."! !!ResizableToggleButton2 methodsFor: 'initialization' stamp: 'jm 2/7/2008 08:43'!setLabelColor: aColor	"Sets all label colors to the given color."	self labelColorOn: aColor labelColorOff: aColor labelColorOver: aColor.! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'nb 1/14/2008 14:17'!toggleButtonMode: mode	"If set to true, the button switches from on to off with a click, and the button remains in on mode until it is clicked again. If it is set to false, the button goes into on mode only when the mouse button is held down. toggleMode also disables changing the font color when in on mode."	toggleButtonMode := mode.! !!ResizableToggleButton2 methodsFor: 'accessing' stamp: 'nb 1/14/2008 14:19'!toggleMode: mode	"The same as ToggleButton's toggleMode. If set to true, clicking the button when turns it from on to off. If false, clicking the button when on does nothing."	toggleMode := mode.! !!ResizableToggleButton2 methodsFor: 'private' stamp: 'ee 6/13/2008 18:41'!updateLayout	"Update the label position within the button."	| x y top |	x := ((self width - label2 width) // 2) + hOffset.  "center by default"	justification = #left ifTrue: [x := hOffset].	justification = #right ifTrue: [x := self width - hOffset - label2 width].	y := ((self height / 2) - vOffset) rounded.	top := self top + 10.	(self submorphs size = 2)		ifTrue: [label2 position: self position + (x@y)]		ifFalse: [self submorphs reversed do: [:m |			(m isKindOf: ImageFrameMorph) ifFalse: [				m left: self left + ((self width - m width) // 2).				m top: top.				top := m bottom + 6]]].! !!ResizableToggleButton2 methodsFor: 'private' stamp: 'jm 7/1/2008 10:26'!updateSize	"Set this button size based on the label size. Assume the label has already been set."	| trim contentsExtent |	trim := ScratchTranslator verticalTrimForFont: label2 font.	contentsExtent := 0@0.	self submorphsDo: [: m |		(m isKindOf: ImageFrameMorph) ifFalse: [			contentsExtent := (contentsExtent x max: m width)@(contentsExtent y + m height)]].	self extent: contentsExtent + padding - (0@trim).	vOffset := ScratchTranslator centerOffsetForButtonWithFont: label2 font.	self updateLayout.! !!SimpleButtonMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/23/2019 16:22'!fieldsVersion	^ 1! !!SimpleButtonMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 11:44'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		target		actionSelector		arguments		actWhen	) from: anObjStream.! !!SimpleButtonMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 19:59'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		target		actionSelector		arguments		actWhen	) on: anObjStream.! !!ToggleButton class methodsFor: 'instance creation' stamp: 'ee 7/1/2003 14:49'!onForm: f1 offForm: f2	"Set the forms used for my on and off states."	^ self new onForm: f1 offForm: f2! !!ToggleButton class methodsFor: 'instance creation' stamp: 'ee 8/6/2003 16:28'!onForm: f1 offForm: f2 overForm: f3	"Set the forms used for my on and off states."	^ self new onForm: f1 offForm: f2 overForm: f3! !!ToggleButton methodsFor: 'menu' stamp: 'ee 6/24/2003 11:37'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.! !!ToggleButton methodsFor: 'accessing' stamp: 'ee 11/10/2008 15:03'!alphaOn: aBoolean	alphaOn := aBoolean.! !!ToggleButton methodsFor: 'drawing' stamp: 'jm 8/22/2006 09:04'!areasRemainingToFill: aRectangle	"Don't optimize redraw; I may have transparent areas!!"	^ Array with: aRectangle! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 8/22/2006 07:57'!clearIsOver	| f |	isOver ifFalse: [^ self].  "already cleared"	isOver := false.	"update my extent"	f := isOn ifTrue: [onForm] ifFalse: [offForm].	isDisabled ifTrue: [f := disabledForm].	f ifNotNil: [self extent: f extent].! !!ToggleButton methodsFor: 'accessing' stamp: 'ee 1/15/2008 13:03'!color	isOn		ifNotNil:[isOn			ifTrue:[^ onForm colorAt: ((onForm width // 2)@(onForm height // 2))]			ifFalse:[isOver				ifTrue:[^ overForm colorAt: ((overForm width // 2)@(overForm height // 2))]				ifFalse:[^ offForm colorAt: ((offForm width // 2)@(offForm height // 2))]]]		ifNil:[^ super color].! !!ToggleButton methodsFor: 'geometry' stamp: 'jm 8/22/2006 08:53'!containsPoint: aPoint	| f |	(self bounds containsPoint: aPoint) ifFalse: [^ false].	f := isOn ifTrue: [onForm] ifFalse: [offForm].	f ifNil: [^ true].	^ (f isTransparentAt: aPoint - bounds origin) not! !!ToggleButton methodsFor: 'drawing' stamp: 'ee 11/10/2008 15:15'!drawOn: aCanvas	| form |	form := isOn ifTrue: [onForm] ifFalse: [offForm].	isOver & isOn not ifTrue: [form := overForm].	isDisabled ifTrue: [form := disabledForm].	form ifNil: [  "default drawing if nil form"		aCanvas frameRectangle: self bounds			width: 3			color: (isOn ifTrue: [Color veryVeryLightGray] ifFalse: [Color gray]).		^ self].	alphaOn		ifTrue: [aCanvas translucentImage: form at: bounds origin]		ifFalse: [aCanvas paintImage: form at: bounds origin].! !!ToggleButton methodsFor: 'geometry' stamp: 'ee 12/22/2005 00:15'!extent: aRectangle	"Overridden because SimpleButtonMorph tries to center the label, if there is one, and we want manual control."	| label oldP oldPSub |	(label := self findA: StringMorph) ifNil: [		(self submorphCount = 1) ifTrue: [oldPSub := self firstSubmorph position].		super extent: aRectangle.		(self submorphCount = 1) ifTrue: [self firstSubmorph position: oldPSub].		^self].	oldP := label position.	super extent: aRectangle.	label position: oldP.! !!ToggleButton methodsFor: 'object i/o' stamp: 'jm 8/22/2006 07:43'!fieldsVersion	^ 1! !!ToggleButton methodsFor: 'event handling' stamp: 'ee 8/6/2003 16:33'!handlesMouseOver: evt	^ true! !!ToggleButton methodsFor: 'object i/o' stamp: 'jm 8/22/2006 08:24'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		onForm		offForm		overForm		disabledForm		isMomentary		toggleMode		isOn		isDisabled	) from: anObjStream.! !!ToggleButton methodsFor: 'initialization' stamp: 'ee 11/10/2008 15:02'!initialize	super initialize.	self cornerStyle: #square.	isMomentary := false.	toggleMode := true.	isDisabled := false.	isOn := isOver := false.	alphaOn := false.! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 8/22/2006 07:56'!isDisabled	^ isDisabled! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 8/22/2006 07:47'!isDisabled: aBoolean	isDisabled := aBoolean.! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 12/17/2003 13:07'!isMomentary: aBoolean	isMomentary := aBoolean.! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 12/17/2003 13:07'!isOn	^ isOn! !!ToggleButton methodsFor: 'accessing' stamp: 'ee 3/22/2005 00:46'!label	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [^ m]].	! !!ToggleButton methodsFor: 'accessing' stamp: 'EiichiroIto 11/21/2019 06:55'!label: aString font: aFont	"Add the given label in the given font centered in my current extent."	| oldLabel m |	(oldLabel := self findA: StringMorph) ifNotNil: [oldLabel delete].	m := StringMorph contents: aString font: (aFont ifNil: [self error]).	m position: self center - (m extent // 2).	self addMorph: m.	m lock.! !!ToggleButton methodsFor: 'event handling' stamp: 'EiichiroIto 9/3/2019 21:25'!mouseDown: evt	"If I am currently turned on, turn myself off and vice versa. If toggleMode is false, then do nothing if I am already on. If isMomentary, then turn myself off immediately. If I am to act when I'm pressed, then send my target my action selector."	"evt hand toolType: nil."	isDisabled ifTrue: [^ self].	wasOn := isOn.	actWhen == #buttonDown ifTrue: [		self doButtonAction.		self on.		isMomentary ifTrue: [self off]].! !!ToggleButton methodsFor: 'event handling' stamp: 'jm 1/6/2006 10:46'!mouseEnter: evt	isDisabled ifTrue: [^ self].	overForm ifNotNil: [		self changed.		isOver := true.		self extent: overForm extent.		self changed].! !!ToggleButton methodsFor: 'event handling' stamp: 'EiichiroIto 11/21/2019 06:59'!mouseLeave: evt	isDisabled ifTrue: [^ self].	overForm ifNotNil: [		self changed.		isOver := false.		isOn ifTrue: [self on] ifFalse: [self off]].! !!ToggleButton methodsFor: 'event handling' stamp: 'ee 6/17/2005 17:45'!mouseMove: evt	"Give feedback depending on whether the mouse is over me. If I was originally on, show my off image if the mouse is over me and my on image if not. Do the opposite if I was originally off."	isDisabled ifTrue: [^self].	actWhen == #buttonDown ifTrue: [^ self].	(toggleMode not & wasOn) ifTrue: [^ self].  "already on and not toggling"	(self containsPoint: evt cursorPoint)		ifTrue: [wasOn ifTrue: [self off] ifFalse: [self on]]		ifFalse: [wasOn ifTrue: [self on] ifFalse: [self off]].! !!ToggleButton methodsFor: 'event handling' stamp: 'jm 8/22/2006 07:56'!mouseUp: evt	"If I am a momentary button, then turn off. If I am to act on button up, then send my target my action selector."	isDisabled ifTrue:[^ self].	isMomentary ifTrue: [self off].	(actWhen == #buttonUp and:	 [self containsPoint: evt cursorPoint])		ifTrue: [self doButtonAction].! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 8/22/2006 08:40'!off	"Turn myself off."	isOn ifFalse: [^ self].	self changed.	isOn := false.	offForm ifNotNil: [self extent: offForm extent].	self changed.! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 8/22/2006 08:41'!on	"Turn myself on."	isOn ifTrue: [^ self].	self changed.	isOn := true.	onForm ifNotNil: [self extent: onForm extent].	self changed.! !!ToggleButton methodsFor: 'initialization' stamp: 'jm 12/18/2003 12:08'!onForm: f1 offForm: f2	onForm := f1.	offForm := f2.	self on; off.! !!ToggleButton methodsFor: 'initialization' stamp: 'jm 12/18/2003 12:08'!onForm: f1 offForm: f2 overForm: f3	onForm := f1.	offForm := f2.	overForm := f3.	self on; off.! !!ToggleButton methodsFor: 'initialization' stamp: 'ee 6/17/2005 16:38'!onForm: f1 offForm: f2 overForm: f3 disabledForm: f4	onForm := f1.	offForm := f2.	overForm := f3.	disabledForm := f4.	self on; off.! !!ToggleButton methodsFor: 'initialization' stamp: 'jm 12/17/2003 13:07'!setDefaultLabel	"Overridden to do nothing. I have no label by default, although a label can be added."! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 8/22/2006 08:47'!setLabelColor: aColor	| s |	s := self findA: StringMorph.	s color: aColor.! !!ToggleButton methodsFor: 'object i/o' stamp: 'jm 8/22/2006 08:25'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		onForm		offForm		overForm		disabledForm		isMomentary		toggleMode		isOn		isDisabled	) on: anObjStream.! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 12/17/2003 13:02'!toggleMode: aBoolean	toggleMode := aBoolean.! !!SpMorphicTickingWindowAdapter methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/18/2019 23:14'!requestWindowClose	^ true! !!SpFileChooserDialog class methodsFor: 'specs' stamp: 'EiichiroIto 11/14/2019 11:55'!chooseExistingFileSpec	^ SpBoxLayout newHorizontal		spacing: 4;		add: #shortcuts			withConstraints: [ :constraints | constraints width: self shortcutButtonWidth ];		add:			(SpBoxLayout newVertical				spacing: 4;				add: #fileList;				yourself);		yourself! !!SpFileChooserDialog class methodsFor: 'specs' stamp: 'EiichiroIto 11/14/2019 18:26'!chooseNewFileSpec	^ SpBoxLayout newHorizontal		spacing: 4;		add: #shortcuts			withConstraints: [ :constraints | constraints width: self shortcutButtonWidth ];		add:			(SpBoxLayout newVertical				spacing: 4;				add: #fileList;				add: #textFilename					withConstraints: [ :constraints | constraints expand: false ];				yourself);		yourself! !!SpFileChooserDialog class methodsFor: 'specs' stamp: 'EiichiroIto 11/14/2019 11:08'!defaultSpec	^ SpBoxLayout newHorizontal		spacing: 4;		add: #shortcuts			withConstraints: [ :constraints | constraints width: self shortcutButtonWidth ];		add:			(SpBoxLayout newVertical				spacing: 4;				add: #fileList;				add: #filename					withConstraints: [ :constraints | constraints expand: false ];				yourself);		yourself! !!SpFileChooserDialog class methodsFor: 'instance creation' stamp: 'EiichiroIto 11/24/2019 09:38'!extension: aString	^ self basicNew initialize		extension: aString;		yourself! !!SpFileChooserDialog class methodsFor: 'specs' stamp: 'EiichiroIto 11/15/2019 14:19'!openScratchFileSpec	^ SpBoxLayout newHorizontal		spacing: 4;		add: #shortcuts			withConstraints: [ :constraints | constraints width: self shortcutButtonWidth ];		add:			(SpBoxLayout newVertical				spacing: 4;				add: #fileList;				yourself);		add: #fileInfo;		yourself! !!SpFileChooserDialog class methodsFor: 'specs' stamp: 'EiichiroIto 11/15/2019 18:26'!saveScratchFileSpec	^ SpBoxLayout newHorizontal		spacing: 4;		add: #shortcuts			withConstraints: [ :constraints | constraints width: self shortcutButtonWidth ];		add:			(SpBoxLayout newVertical				spacing: 4;				add: #fileList;				add: #textFilename					withConstraints: [ :constraints | constraints expand: false ];				yourself);		add: #fileInfo;		yourself! !!SpFileChooserDialog class methodsFor: 'private' stamp: 'EiichiroIto 11/13/2019 22:51'!shortcutButtonWidth	^ 120! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 18:40'!author	^ fileInfo author! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 18:47'!author: aString	fileInfo author: aString! !!SpFileChooserDialog methodsFor: 'ui dialogs' stamp: 'EiichiroIto 11/24/2019 09:44'!chooseExistingFileType: aSymbol title: aString	| d |	self		title: aString;		pattern: '*.', self extension;		type: aSymbol.	d := self openModalWithSpec: #chooseExistingFileSpec.	d isCancelled		ifTrue: [ ^ nil ].	^ self selectedFile! !!SpFileChooserDialog methodsFor: 'ui dialogs' stamp: 'EiichiroIto 11/24/2019 09:46'!chooseNewFileDefault: filename title: aString type: aSymbol	| d |	self		filename: filename;		title: aString;		pattern: '*.', self extension;		type: aSymbol.	d := self openModalWithSpec: #chooseNewFileSpec.	d isCancelled		ifTrue: [ ^ nil ].	^ self filename! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 18:41'!comment	^ fileInfo comment! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 18:47'!comment: aString	fileInfo comment: aString! !!SpFileChooserDialog methodsFor: 'ui dialogs' stamp: 'EiichiroIto 11/24/2019 09:49'!confirmFileOverwriteIfExisting: aFileReference orCancel: aBlock	| file response |	file := aFileReference withExtension: self extension.	file isFile		ifFalse: [ ^ file ].	response := UIManager default		confirm: 'The file name already exists. Overwrite existing file?' localized		orCancel: aBlock.	^ response		ifTrue: [ file ]		ifFalse: [ nil ]! !!SpFileChooserDialog methodsFor: 'initialization' stamp: 'EiichiroIto 11/15/2019 14:18'!connectPresenters	shortcuts list: fileList! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:31'!extension	^ fileInfo extension! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:30'!extension: aString	fileInfo extension: aString! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/14/2019 18:31'!filename	| ret |	ret := textFilename pendingText asString.	^ ret ifEmpty: [ nil ] ifNotEmpty: [ fileList directory / ret ]! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/14/2019 18:28'!filename: aString	textFilename text: aString! !!SpFileChooserDialog methodsFor: 'initialization' stamp: 'EiichiroIto 11/15/2019 20:42'!initialize	super initialize.	title := self class asString! !!SpFileChooserDialog methodsFor: 'initialization' stamp: 'EiichiroIto 11/15/2019 20:42'!initializeDialogWindow: aDialog	super initializeDialogWindow: aDialog.	aDialog closeOnBackdropClick: false! !!SpFileChooserDialog methodsFor: 'initialization' stamp: 'EiichiroIto 11/15/2019 18:36'!initializePresenters	shortcuts := self instantiate: SpShortcutButtons.	fileList := self instantiate: SpFileList.	textFilename := self instantiate: SpLabelledTextInput.	fileInfo := self instantiate: SpFileInfo.	textFilename		label: 'Filename:' localized;		acceptOnCR: true.	self focusOrder		add: fileList;		add: textFilename! !!SpFileChooserDialog methodsFor: 'initialization' stamp: 'EiichiroIto 11/15/2019 14:27'!initializeWindow: aWindow	aWindow title: title;	initialExtent: 600 @ 400! !!SpFileChooserDialog methodsFor: 'private' stamp: 'EiichiroIto 11/15/2019 18:05'!itemSelected	fileInfo file: fileList selectedFile! !!SpFileChooserDialog methodsFor: 'ui dialogs' stamp: 'EiichiroIto 11/24/2019 09:34'!openScratchFile	| d |	self		setupForFileInfoViewer;		pattern: '*.' , self extension;		title: 'Open Project';		type: #project.	d := self openModalWithSpec: #openScratchFileSpec.	d isCancelled		ifTrue: [ ^ nil ].	^ self selectedFile! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/13/2019 22:04'!pattern: aString	fileList ifNotNil: [ :p | p pattern: aString ]! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 20:51'!project: aProject	fileInfo project: aProject! !!SpFileChooserDialog methodsFor: 'ui dialogs' stamp: 'EiichiroIto 11/24/2019 09:39'!saveScratchFileFor: aFrameMorph	| d |	self		setupForFileInfoEditor;		pattern: '*.' , self extension;		title: 'Save Project';		type: #project.	aFrameMorph		ifNotNil: [ self				author: aFrameMorph author;				comment: aFrameMorph comment ].	d := self openModalWithSpec: #saveScratchFileSpec.	d isCancelled		ifTrue: [ ^ nil ].	aFrameMorph		ifNotNil: [ aFrameMorph				author: self author;				comment: self comment ].	^ self filename! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/14/2019 11:42'!selectedFile	^ fileList selectedFile! !!SpFileChooserDialog methodsFor: 'initialization' stamp: 'EiichiroIto 11/15/2019 18:29'!setupForFileInfoEditor	fileInfo readOnly: false.	textFilename label: 'New filename:' localized! !!SpFileChooserDialog methodsFor: 'initialization' stamp: 'EiichiroIto 11/15/2019 18:16'!setupForFileInfoViewer	fileList whenFileSelectedBlock: [ self itemSelected ].	fileInfo readOnly: true! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/14/2019 11:37'!title: aString	title := aString! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 10:10'!type: aSymbol	shortcuts setDirectory: (ScratchDirectory current getLastFolderForType: aSymbol)! !!SpFileInfo class methodsFor: 'specs' stamp: 'EiichiroIto 11/24/2019 09:24'!defaultSpec	^ SpBoxLayout newVertical		add: #thumbnail			withConstraints: [ :c | c width: SpScratchApp thumbnailExtent x ];		add: #labelAuthor withConstraints: [ :c | c expand: false ];		add: #textAuthor withConstraints: [ :c | c expand: false ];		add: #labelComment withConstraints: [ :c | c expand: false ];		add: #textComment;		yourself! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 18:41'!author	^ textAuthor pendingText asString trimBoth! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 14:12'!author: aString	textAuthor text: aString! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 14:12'!comment	^ textComment pendingText! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 13:49'!comment: aString	textComment text: aString! !!SpFileInfo methodsFor: 'initialization' stamp: 'EiichiroIto 11/15/2019 18:10'!connectPresenters	"thumbnail whenMorphChangedDo: [ Transcript show: 'thumbnail changed'; cr ]"! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:30'!extension	^ extension! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:30'!extension: aString	extension := aString! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 13:57'!file: aFileReference	| dict |	dict := self getFileInfo: aFileReference.	self		author:			((dict notNil and: [ dict includesKey: 'author' ])				ifTrue: [ dict at: 'author' ]				ifFalse: [ '' ]).	self		comment:			((dict notNil and: [ dict includesKey: 'comment' ])				ifTrue: [ dict at: 'comment' ]				ifFalse: [ '' ]).	self		thumbnailForm:			((dict notNil and: [ dict includesKey: 'thumbnail' ])				ifTrue: [ dict at: 'thumbnail' ]				ifFalse: [ (Form extent: 1 @ 1 depth: 1) fillWhite ])! !!SpFileInfo methodsFor: 'private' stamp: 'EiichiroIto 11/29/2019 20:50'!getFileInfo: aFileReference	(aFileReference isNil or: [ aFileReference isFile not ])		ifTrue: [ ^ nil ].	aFileReference extension = extension		ifFalse: [ ^ nil ].	^ project getScratchInfoFrom: aFileReference! !!SpFileInfo methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 09:39'!initialize	super initialize.	extension := '*'! !!SpFileInfo methodsFor: 'initialization' stamp: 'EiichiroIto 11/15/2019 18:37'!initializePresenters	thumbnail := self newImage.	textAuthor := self newTextInput acceptOnCR: true.	textComment := self newText.	labelAuthor := self newLabel label: 'Project author:' localized.	labelComment := self newLabel label: 'About this project:' localized! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 20:50'!project	^ project! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 20:50'!project: aProject	project := aProject! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 18:15'!readOnly: aBoolean	textAuthor enabled: aBoolean not.	textComment enabled: aBoolean not! !!SpFileInfo methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 18:09'!thumbnailForm: aForm	thumbnail image: aForm! !!SpFileList class methodsFor: 'specs' stamp: 'EiichiroIto 11/14/2019 21:37'!defaultSpec	^ SpBoxLayout newVertical		spacing: 4;		add:			(SpBoxLayout newHorizontal				spacing: 4;				add: #current;				add: #buttonParent withConstraints: [ :constraints | constraints expand: false ];				add: #buttonNew withConstraints: [ :constraints | constraints expand: false ];				yourself)			withConstraints: [ :constraints | constraints expand: false ];		add: #entries;		yourself! !!SpFileList methodsFor: 'initialization' stamp: 'EiichiroIto 11/14/2019 22:42'!connectPresenters	entries		display: [ :m | self showEntry: m ];		whenActivatedDo: [ :selection | self entriesChanged: selection ].	current		display: [ :m | m ];		whenSelectedItemChangedDo: [ :selection | self currentChanged: selection ].	buttonParent action: [ self setParent ].	buttonNew action: [ self newFolder ]! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 11/13/2019 22:29'!currentChanged: aString	| dir |	disableChanged		ifTrue: [ ^ self ].	current selectedIndex = 0		ifTrue: [ ^ self ].	dir := directory.	directory path segments size - current selectedIndex		timesRepeat: [ dir := dir parent ].	self directory: dir! !!SpFileList methodsFor: 'accessing' stamp: 'EiichiroIto 11/14/2019 11:39'!directory	^ directory! !!SpFileList methodsFor: 'accessing' stamp: 'EiichiroIto 11/13/2019 22:08'!directory: aFileReference	directory := aFileReference.	self refreshCurrent.	self refreshList! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 12/8/2019 21:28'!entriesChanged: aSelectionMode	| dir |	dir := aSelectionMode selectedItem.	dir isDirectory		ifFalse: [ ^ self ].	self directory: dir asFileReference! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 11/14/2019 06:59'!getEntries	| dirs files stream |	dirs := directory directories asOrderedCollection.	dirs		sort: [ :a :b | a basename asLowercase < b basename asLowercase ].	stream := WriteStream on: OrderedCollection new.	(pattern isNil or: [ pattern isEmpty ])		ifTrue: [ stream nextPutAll: directory files ]		ifFalse: [ stream nextPutAll: (directory filesMatching: pattern) ].	files := stream contents.	files		sort: [ :a :b | a basename asLowercase < b basename asLowercase ].	^ (dirs , files) reject: [ :each | each basename beginsWith: '.' ]! !!SpFileList methodsFor: 'initialization' stamp: 'EiichiroIto 11/13/2019 22:26'!initialize	super initialize.	directory := FileSystem workingDirectory.	disableChanged := false! !!SpFileList methodsFor: 'initialization' stamp: 'EiichiroIto 11/14/2019 21:36'!initializePresenters	current := self newDropList.	entries := self newList		beSingleSelection;		activateOnDoubleClick.	buttonParent := self newButton		icon: (Smalltalk ui icons iconNamed: #up).	buttonNew := self newButton		icon: (Smalltalk ui icons iconNamed: #add).	self focusOrder		add: current;		add: buttonParent;		add: buttonNew;		add: entries! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 11/14/2019 21:39'!newFolder	| name |	name := UIManager default request: 'New folder name:' localized.	(name isNil or: [ name isEmpty ])		ifTrue: [ ^ self ].	[ (directory / name) createDirectory ]		ifError:			[ :err :rcvr | ^ UIManager default alert: 'Could not create folder.' localized ].	self directory: directory / name! !!SpFileList methodsFor: 'accessing' stamp: 'EiichiroIto 11/13/2019 22:04'!pattern	^ pattern! !!SpFileList methodsFor: 'accessing' stamp: 'EiichiroIto 11/13/2019 22:04'!pattern: aCollection	pattern := aCollection! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 11/13/2019 22:26'!refreshCurrent	| list |	list := directory path segments		withIndexCollect:			[ :each :index | (String new: index withAll: Character space) , each ].	disableChanged := true.	current selectIndex: 0.	current items: list.	current selectIndex: list size.	disableChanged := false! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 11/13/2019 22:41'!refreshList	entries unselectAll.	entries items: #().	entries items: self getEntries.! !!SpFileList methodsFor: 'accessing' stamp: 'EiichiroIto 11/14/2019 11:42'!selectedFile	| list |	list := entries selectedItems.	list isEmpty ifTrue: [ ^ nil ].	^ list first! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 11/14/2019 06:58'!setParent	directory isRoot ifTrue: [ ^ self ].	self directory: directory parent! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 11/13/2019 21:34'!showEntry: aFileReference	| base |	base := aFileReference basename.	^ aFileReference isDirectory		ifTrue: [ '<' , base , '>' ]		ifFalse: [ base ]! !!SpFileList methodsFor: 'accessing' stamp: 'EiichiroIto 11/15/2019 14:17'!whenFileSelectedBlock: aBlock	itemSelectedBlock := aBlock.	itemSelectedBlock		ifNotNil: [ entries whenSelectionChangedDo: itemSelectedBlock ]! !!SpScratchEditor class methodsFor: 'specs' stamp: 'EiichiroIto 11/18/2019 22:09'!defaultSpec	^ SpBoxLayout newVertical		add:			(SpBoxLayout newHorizontal				add: #labelName;				add: #labelStatus;				yourself)			withConstraints: [ :c | c expand: false ];		add: #editor;		yourself! !!SpScratchEditor methodsFor: 'accessing' stamp: 'EiichiroIto 11/21/2019 22:03'!cleanUp	^ self editorContents cleanUp! !!SpScratchEditor methodsFor: 'accessing' stamp: 'EiichiroIto 11/20/2019 07:44'!currentTab: aString	self target ifNil: [ ^ self ].	self editorContents: self target blocksBin.	self editorContents color: ScratchTheme scriptsPaneColor! !!SpScratchEditor methodsFor: 'private' stamp: 'EiichiroIto 11/17/2019 19:41'!editorContents	^ editor morph contents! !!SpScratchEditor methodsFor: 'private' stamp: 'EiichiroIto 11/17/2019 19:41'!editorContents: aMorph	editor morph contents: aMorph! !!SpScratchEditor methodsFor: 'initialization' stamp: 'EiichiroIto 11/19/2019 22:00'!initializePresenters	labelName := self newLabel.	labelStatus := self newLabel.	editor := self newMorph.	editor		morph:			(ScrollFrameMorph2 new				growthFraction: 0.1;				color: ScratchTheme scriptsPaneColor)! !!SpScratchEditor methodsFor: 'accessing' stamp: 'EiichiroIto 11/21/2019 22:02'!screenshot	^ self editorContents screenshot! !!SpScratchEditor methodsFor: 'accessing' stamp: 'EiichiroIto 11/17/2019 19:41'!target	^ target! !!SpScratchEditor methodsFor: 'accessing' stamp: 'EiichiroIto 11/20/2019 07:44'!target: aScratchObjectOrNil	target := aScratchObjectOrNil.	aScratchObjectOrNil		ifNil: [ labelName label: 'no object' localized.			self editorContents: (Morph new color: Color red).			^ self ].	labelName label: aScratchObjectOrNil objName.	self currentTab: 'Scripts'! !!SpScratchFrame class methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:17'!libraryPaneHeight	^ self buttonHeight + 23! !!SpScratchFrame class methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:17'!titleButtonHeight	^ 23 + 10! !!SpScratchFrame class methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:17'!viewerPaneWidth	^ 214! !!SpScratchFrame class methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:17'!workPaneHeight	^ 600! !!SpScratchFrame class methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:17'!workPaneWidth	^ 600! !!SpScratchFrame methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 19:19'!aboutTitle	^ application appName! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:19'!currentCategory: aString	viewerPane currentCategory: aString! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:19'!currentTab: aString	scriptsPane currentTab: aString! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:19'!currentTarget	^ scriptsPane target! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:19'!currentTarget: aScript	scriptsPane target: aScript.	viewerPane target: aScript! !!SpScratchFrame methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 19:27'!defaultExtent	self subclassResponsibility! !!SpScratchFrame methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 19:20'!display	^ stageFrame display! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:21'!info: aString	self display info: aString! !!SpScratchFrame methodsFor: 'initialization' stamp: 'EiichiroIto 11/23/2019 19:23'!initializeWindow: aWindow	aWindow		initialExtent: self defaultExtent;		aboutText: application aboutAppString! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:25'!projectName	^ titlePane projectName! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:25'!projectName: aString	titlePane projectName: aString! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:26'!scriptForm	^ scriptsPane screenshot! !!SpScratchFrame methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 19:28'!stageShotSized: size	"Answer a thumbnail of me and my submorphs. Use super fullDrawOn: to avoid drawing the shadows along the top and left edges of the workspace."	| canvas thumbForm bounds display |	display := self display.	bounds := display bounds.	canvas := FormCanvas extent: bounds extent depth: 32.	canvas		translateBy: bounds topLeft negated		during: [ :c | display fullDrawOn: c ].	thumbForm := Form extent: size depth: 32.	(WarpBlt toForm: thumbForm)		sourceForm: canvas form;		cellSize: 2;		combinationRule: Form over;		copyQuad: (0 @ 0 extent: canvas extent) innerCorners			toRect: thumbForm boundingBox.	^ thumbForm! !!SpScratchFrame methodsFor: 'stepping' stamp: 'EiichiroIto 11/23/2019 19:28'!stepTime	^ self display stepTime! !!SpScratchFrame methodsFor: 'stepping' stamp: 'EiichiroIto 11/23/2019 19:26'!stepTime: anInteger	self display stepTime: anInteger! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:26'!target: aScript	viewerPane target: aScript.	scriptsPane target: aScript.	libraryPane selectButton: aScript objName! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:27'!updateContents	viewerPane updateContents! !!SpScratchFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 19:27'!updateDisplay	self display changed! !!SpScratchFrame methodsFor: 'stepping' stamp: 'EiichiroIto 11/24/2019 17:04'!whenStepsDo: aBlock	self display		whenStepsDo: aBlock;		startStepping! !!SpScratchViewer class methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:15'!addButtonsTo: aLayout	| w |	w := SpScratchFrame viewerPaneWidth // 2.	self buttons		pairsDo: [ :each1 :each2 | 			aLayout				add:					(SpBoxLayout newHorizontal						add: each1 first withConstraints: [ :c | c width: w ];						add: each2 first withConstraints: [ :c | c width: w ];						yourself)				withConstraints: [ :c | c height: self buttonHeight ] ]! !!SpScratchViewer class methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:15'!buttons	self subclassResponsibility! !!SpScratchViewer class methodsFor: 'specs' stamp: 'EiichiroIto 11/23/2019 20:15'!defaultSpec	| myLayout |	myLayout := SpBoxLayout newVertical.	self addButtonsTo: myLayout.	myLayout add: #pageViewer.	^ myLayout! !!SpScratchViewer methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:08'!currentCategory	^ currentCategory! !!SpScratchViewer methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:08'!currentCategory: aString	currentCategory := aString asLowercase.	self updateButtonIcon.	self updateContents.	self selectButtons! !!SpScratchViewer methodsFor: 'initialization' stamp: 'EiichiroIto 11/23/2019 20:08'!initialize	currentCategory := #none.	super initialize! !!SpScratchViewer methodsFor: 'initialization' stamp: 'EiichiroIto 11/23/2019 20:09'!initializePresenters	pageViewer := self newMorph.	pageViewer morph: (ScrollFrameMorph2 new growthFraction: 0.1).	self setupButtons.	self updateButtonIcon! !!SpScratchViewer methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:14'!pageViewerContents: aMorph	pageViewer morph contents: aMorph! !!SpScratchViewer methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:14'!selectButton: aSymbol	| button |	button := self instVarNamed: aSymbol.	button state: currentCategory = button label asString asLowercase! !!SpScratchViewer methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:14'!selectButtons	(self class buttons collect: #first)		do: [ :each | self selectButton: each ]! !!SpScratchViewer methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:09'!setupButtons	self subclassResponsibility! !!SpScratchViewer methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:07'!target	^ target! !!SpScratchViewer methodsFor: 'accessing' stamp: 'EiichiroIto 11/23/2019 20:08'!target: anObject	| categories |	target := anObject.	target ifNil: [ ^ self currentCategory: #none ].	categories := target blockCategories.	self		currentCategory:			((categories includes: currentCategory)				ifTrue: [ currentCategory ]				ifFalse: [ categories first ])! !!SpScratchViewer methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:14'!updateButtonIcon	self class buttons		do: [ :each | 			| name |			name := each second.			(self instVarNamed: each first)				icon:					(ScratchTheme						formAt:							(name asLowercase = currentCategory								ifTrue: [ (name , 'Pressed') asSymbol ]								ifFalse: [ name ])) ]! !!SpScratchViewer methodsFor: 'private' stamp: 'EiichiroIto 11/23/2019 20:14'!updateContents	| p |	self target		ifNil: [ self				pageViewerContents: (Morph new color: ScratchTheme palettePaneColor).			^ self ].	p := self target viewerPageForCategory: currentCategory.	p color: ScratchTheme palettePaneColor.	self pageViewerContents: p.	p fixLayout! !!SpShortcutButtons class methodsFor: 'specs' stamp: 'EiichiroIto 11/14/2019 11:08'!defaultSpec	^ SpBoxLayout newVertical		spacing: 2;		add: #buttonComputer;		add: #buttonUser;		add: #buttonDesktop;		add: #buttonExamples;		add: #buttonProjects;		yourself! !!SpShortcutButtons methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 10:14'!connectPresenters	buttonComputer action: [ self setDirectoryType: #computer ].	buttonUser action: [ self setDirectoryType: #user ].	buttonDesktop action: [ self setDirectoryType: #desktop ].	buttonExamples action: [ self setDirectoryType: #examples ].	buttonProjects action: [ self setDirectoryType: #projects ]! !!SpShortcutButtons methodsFor: 'initialization' stamp: 'EiichiroIto 11/13/2019 20:53'!initializePresenters	buttonComputer := self newButton label: 'Computer'.	buttonUser := self newButton label: 'User'.	buttonDesktop := self newButton label: 'Desktop'.	buttonExamples := self newButton label: 'Examples'.	buttonProjects := self newButton label: 'My Projects'.	self focusOrder		add: buttonComputer;		add: buttonUser;		add: buttonDesktop;		add: buttonExamples;		add: buttonProjects! !!SpShortcutButtons methodsFor: 'accessing' stamp: 'EiichiroIto 11/13/2019 21:54'!list	^ list! !!SpShortcutButtons methodsFor: 'accessing' stamp: 'EiichiroIto 11/13/2019 21:49'!list: aSpPresenter	list := aSpPresenter! !!SpShortcutButtons methodsFor: 'private' stamp: 'EiichiroIto 11/13/2019 21:55'!setDirectory: aFileReference	list ifNil: [ ^ self ].	aFileReference ifNil: [ ^ self ].	list directory: aFileReference! !!SpShortcutButtons methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 10:14'!setDirectoryType: aSymbol	| dir |	dir := 	ScratchDirectory current perform: aSymbol.	self setDirectory: dir! !!SpShortcutButtons methodsFor: 'accessing' stamp: 'EiichiroIto 11/13/2019 21:49'!userName: aString	buttonUser label: aString! !!Integer methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/29/2016 20:19'!hhmmss	"Answer a string of the form HH:MM:SS. For displaying a time in seconds as hours, minutes, and seconds."	| hh mm ss |	hh := (self // 3600) printString.	mm := (self // 60 \\ 60) printString.	mm size < 2		ifTrue: [ mm := '0' , mm ].	ss := (self \\ 60) printString.	ss size < 2		ifTrue: [ ss := '0' , ss ].	^ hh , ':' , mm , ':' , ss! !!FreeTypeGlyphRenderer methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 12:45' prior: 26331719!renderGlyph: aCharacter depth: depth subpixelPosition: sub font: aFreeTypeFont	"Glyphs are either 1 or 8 bit deep. For 32 bpp we use 8 bits, otherwise 1"	| em form glyph charCode slant extraWidth extraHeight boldExtra offsetX offsetY s synthBoldStrength face |	charCode := aCharacter asUnicode asInteger.	(aFreeTypeFont face charmaps includes:'unic')		ifTrue:[			(aFreeTypeFont isSymbolFont and:[charCode >= 16r20 and: [charCode <= 16rFF ] ])				ifTrue:[charCode := charCode + 16rF000]]		ifFalse:[			(aFreeTypeFont face charmaps includes:'armn')				ifTrue:[ "select apple roman char map, and map character from unicode to mac encoding"					aFreeTypeFont face setCharMap:'armn'.					charCode := aCharacter unicodeToMacRoman asUnicode asInteger. "check this!!"]].	charCode < $  asUnicode asInteger ifTrue: ["charCode := $  asUnicode asInteger"		^(GlyphForm extent: 0@0 depth: depth)			advance: 0@0;			linearAdvance: 0@0;			offset:0@0;			yourself ].	em := aFreeTypeFont pixelSize.	[ | hintingFlags flags |face := aFreeTypeFont face.	face setPixelWidth: em height: em.	hintingFlags := FreeTypeSettings current hintingFlags.	flags :=  LoadNoBitmap bitOr:( LoadIgnoreTransform bitOr: hintingFlags). 	face loadCharacter:charCode flags: flags]	on: FT2Error do:[:e | 		^(GlyphForm extent: 0@0 depth: depth)			advance: 0@0;			linearAdvance: 0@0;			offset:0@0;			yourself]. 	glyph := face glyph. 	slant := aFreeTypeFont simulatedItalicSlant.	extraWidth := (glyph height * slant) abs ceiling.	synthBoldStrength := aFreeTypeFont simulatedBoldStrength.	boldExtra := 4 * synthBoldStrength abs ceiling.	extraWidth := extraWidth + boldExtra.	sub > 0 ifTrue:[ extraWidth := extraWidth + 1].	extraHeight := boldExtra.	form := GlyphForm extent: (glyph width + extraWidth + 1)@(glyph height + extraHeight+ 1) depth: depth.	s := (glyph height-glyph hBearingY)  * slant.	s := s sign * (s abs ceiling). 	offsetX := glyph hBearingX negated + s + (boldExtra // 2) .	offsetY := glyph height - glyph hBearingY + (boldExtra//2).	synthBoldStrength ~= 0		ifTrue:[face emboldenOutline: synthBoldStrength].	face transformOutlineAngle: 0 scalePoint: 1@1  slant: slant.	face translateOutlineBy: (offsetX+(sub/64))@offsetY.	face renderGlyphIntoForm: form.	form offset: (glyph hBearingX - s - (boldExtra // 2) ) @ (glyph hBearingY + 1 + (boldExtra / 2) ceiling  ) negated.	"When not hinting FreeType sets the advance to the truncated linearAdvance.	The characters appear squashed together. Rounding is probably better, so we fix the advance here"	aFreeTypeFont subPixelPositioned		ifTrue:[ form advance: glyph roundedPixelLinearAdvance]		ifFalse:[ form advance: glyph advance].	form linearAdvance: glyph linearAdvance.	^form! !!Stream methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 21:22'!skipSeparators	[self atEnd]		whileFalse:		[self next isSeparator ifFalse: [^ self position: self position-1]]! !!MenuMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/30/2016 08:17'!localize	self menuItems		do: [ :each | 			(each isKindOf: MenuItemMorph)				ifTrue: [ each localize ] ]! !!MenuMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/26/2016 22:19'!updateTarget: anObject	self items do: [ :each | each target ifNil: [ each target: anObject ] ]! !!AlignmentMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 11:20'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		orientation		centering		hResizing		vResizing		inset	) from: anObjStream.! !!AlignmentMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/18/2016 17:06'!rootForGrabOf: aMorph	| root |	self dragNDropEnabled ifFalse: [^ super rootForGrabOf: aMorph].	root := aMorph.	[root == self] whileFalse:		[root owner = self ifTrue: [^ root].		root := root owner].	^ super rootForGrabOf: aMorph! !!AlignmentMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 19:56'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		orientation		centering		hResizing		vResizing		inset	) on: anObjStream.! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/14/2016 22:13'!colorNoAlphaAt: aPoint	"Answer the color in the pixel at the given point, ignoring alpha."	^ Color colorFromPixelValue: (self pixelValueNoAlphaAt: aPoint) depth: depth! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 11:33'!couldBeColorReduced	"Answer true if this Form has few enough colors to be converted to a ColorForm, but answer false if quantizing it's colors in the process of creating the ColorForm would result in fewer colors than the original. (Note: Converting to a ColorForm may still result in small color shifts due to color quantization, buf if all the colors remain unique these shifts should not be too noticable.)"	| colors pixel |	self depth < 32 ifTrue: [^ false].	self unhibernate.	colors := Set new: 1000.	1 to: bits size do: [:i |		pixel := (bits at: i) bitAnd: 16rFFFFFF.		pixel = 0 ifFalse: [			colors add: pixel.			colors size > 255 ifTrue: [^ false]]].	^ colors size <= self colorsUsed size! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 09:46'!equals: aForm	"Answer true if the receiver is exactly the same as the given Form."	self == aForm ifTrue: [^ true].	self class = aForm class ifFalse: [^ false].	self class = ColorForm ifTrue: [		self colors = aForm colors  ifFalse: [^ false]].	(width = aForm width) & (height = aForm height) ifFalse: [^ false].	(depth = aForm depth) & (offset = aForm privateOffset) ifFalse: [^ false].	bits class = aForm bits class ifFalse: [		self hibernate.		aForm hibernate].	^ bits = aForm bits! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/4/2016 18:46'!fillRadialFromXColorBlock: colorBlock center: aPoint	"Horizontal Gradient Fill. Supply relative x in [0.0 ... 1.0] to colorBlock, and paint each pixel with the color that comes back."	| canvas m div t |	canvas := self getCanvas.	self fill: self boundingBox fillColor: (colorBlock value: 1).	m := width max: height.	m > 1		ifFalse: [ ^ self ].	div := (m - 1) asFloat.	(m - 1) negated to: 0 do: [ :x | 		t := x abs.		canvas frameOval: (Rectangle center: aPoint extent: t @ t) color: (colorBlock value: t asFloat / div) ]! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 10:22' prior: 26133277!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	self assert: [self depth = 1]. "Only meaningful for B/W forms."	all := self boundingBox.	smearForm := Form extent: self extent.	smearPort := BitBlt toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0 @ 0 rule: Form erase.  "Clear any in black"	previousSmear := smearForm deepCopy.	count := 1.	[count = 10 and:   "check for no change every 10 smears"		[count := 1.		previousSmear copy: all from: 0 @ 0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1 @ 0 rule: Form under.			smearPort copyForm: smearForm to: -1 @ 0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0 @ 0 rule: Form erase.			smearPort copyForm: smearForm to: 0 @ 1 rule: Form under.			smearPort copyForm: smearForm to: 0 @ -1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0 @ 0 rule: Form erase.			count := count+1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0 @ 0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/14/2016 22:10'!oneBitShapeFill: aColor interiorPoint: aPoint	depth > 1 ifTrue: [self error: 'This call only meaningful for 1-bit forms'].	(self findShapeAroundSeedBlock: [:f | f pixelValueAt: aPoint put: 1])		displayOn: self		at: 0@0		clippingBox: self boundingBox		rule: Form under		fillColor: aColor.! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 22:35'!outlineWidth: w color: outlineColor depth: resultDepth	"Answer a Form containing the outline of this Form."	| mask cm outline neg result |	"make a mask form with black for all non-transparent pixels"	mask := Form extent: (self extent + w + w) depth: 2.	cm := self newColorMap.	cm atAllPut: (Color black pixelValueForDepth: mask depth).	cm at: 1 put: 0.	mask copyBits: self boundingBox from: self at: w@w colorMap: cm.	"stamp the mask form onto a new form at various offsets"	outline := Form extent: mask extent depth: mask depth.	1 to: w do: [:pos |		neg := pos negated.		mask displayOn: outline at: pos@0 rule: Form paint.		mask displayOn: outline at: neg@0 rule: Form paint.		mask displayOn: outline at: 0@pos rule: Form paint.		mask displayOn: outline at: 0@neg rule: Form paint.		mask displayOn: outline at: pos@pos rule: Form paint.		mask displayOn: outline at: pos@neg rule: Form paint.		mask displayOn: outline at: neg@pos rule: Form paint.		mask displayOn: outline at: neg@neg rule: Form paint].	"cut out a hole with the original form"	mask displayOn: outline at: 0@0 rule: Form erase.	"copy the outline in the desired color onto the result form"	result := Form extent: mask extent depth: resultDepth.	cm := outline newColorMap.	cm		at: (Color black pixelValueForDepth: outline depth) + 1		put: (outlineColor pixelValueForDepth: result depth).	result copyBits: outline boundingBox from: outline at: 0@0 colorMap: cm.	^ result! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 10:18'!pixelValueNoAlphaAt: aPoint 	"Answer the raw pixel value at the given point. The pixel value depends on the receiver's depth. If the depth is 32 and the pixel is not transparent, ignore alpha."	| pixel |	depth < 32 ifTrue: [^ self pixelValueAt: aPoint].	pixel := (BitBlt bitPeekerFromForm: self) pixelAt: aPoint.	pixel > 0 ifTrue: [pixel := pixel bitOr: 16rFF000000].  "treat as opaque"	^ pixel! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/27/2016 21:45'!privateOffset	^ offset! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/14/2016 22:11'!shapeFill: aColor interiorPoint: aPoint	"Fill the area of similar colors around the given point with the given solid color."	| mapDepth maskForm map c bb |	mapDepth := 9.  "can be 9 or 12"	depth = 1 ifTrue: [^ self oneBitShapeFill: aColor interiorPoint: aPoint].	"map this form into a B/W mask form with 0's in areas of matching color"	maskForm := Form extent: self extent depth: 1.	map := Bitmap new: (1 bitShift: (depth min: mapDepth)) withAll: 1.	depth <= 8		ifTrue: [			map at: (self pixelValueAt: aPoint) + 1 put: 0]		ifFalse: [			c := self colorNoAlphaAt: aPoint.			map at: (c pixelValueForDepth: mapDepth) + 1 put: 0].	maskForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.	"now fill the shape in the mask"	maskForm := maskForm findShapeAroundSeedBlock: [:f | f pixelValueAt: aPoint put: 1].	"use mask to fill with solid color"	bb := (BitBlt toForm: self)		destOrigin: 0@0;		sourceForm: maskForm;		sourceRect: maskForm boundingBox;		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	aColor isTransparent		ifTrue: [bb combinationRule: Form erase1bitShape; copyBits]		ifFalse: [bb fillColor: aColor; combinationRule: Form paint; copyBits].	^ maskForm! !!Form methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/4/2016 19:47'!shapeFillGradientFrom: fromColor to: toColor at: aPoint type: aSymbol	"Fill the area of similar colors around the given point with a gradient of the given type."	| mapDepth maskForm map r newForm c |	mapDepth := 9.	"can be 9 or 12"	depth = 1		ifTrue: [ ^ self oneBitShapeFill: fromColor interiorPoint: aPoint ].	"map this form into a B/W mask form with 0's in areas of matching color"	maskForm := Form extent: self extent depth: 1.	map := Bitmap new: (1 bitShift: (depth min: mapDepth)) withAll: 1.	depth <= 8		ifTrue: [ map at: (self pixelValueAt: aPoint) + 1 put: 0 ]		ifFalse: [ 			c := self colorNoAlphaAt: aPoint.			map at: (c pixelValueForDepth: mapDepth) + 1 put: 0 ].	maskForm		copyBits: self boundingBox		from: self		at: 0 @ 0		colorMap: map.	"now fill the shape"	maskForm := maskForm findShapeAroundSeedBlock: [ :form | form pixelValueAt: aPoint put: 1 ].	r := maskForm rectangleEnclosingPixelsNotOfColor: Color white.	r area = 0		ifTrue: [ ^ self ].	"zero width or height"	newForm := Form extent: r extent depth: 32.	aSymbol = #radial		ifTrue: [ newForm fillRadialFromXColorBlock: [ :m | toColor mixed: m with: fromColor ] center: aPoint - r origin ]		ifFalse: [ 			aSymbol = #horizontal				ifTrue: [ newForm fillFromXColorBlock: [ :m | toColor mixed: m with: fromColor ] ]				ifFalse: [ newForm fillFromYColorBlock: [ :m | toColor mixed: m with: fromColor ] ] ].	"use the mask to cut out the shape"	((BitBlt		destForm: newForm		sourceForm: maskForm		fillColor: nil		combinationRule: Form erase1bitShape		destOrigin: maskForm offset		sourceOrigin: r origin		extent: self extent		clipRect: self boundingBox) colorMap: (Bitmap with: 16rFFFFFFFF with: 0)) copyBits.	"Cut a hole in the picture with my mask"	"copy the masked gradient shape into myself"	self		copy: newForm boundingBox		from: newForm		to: r origin		rule: Form paint! !!ZnBufferedReadStream methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/13/2019 16:55'!uint24	^ self nextIntegerOfSize: 3 signed: false bigEndian: true ! !!True methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 22:26'!asNumberNoError	^ 1! !!StrikeFont class methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/14/2016 22:53'!fontName: arg1 size: arg2	^ self familyName: arg1 size: arg2! !!MenuItemMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/30/2016 08:19'!localize	self contents: self contents localized! !!Slider methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 11:49'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		slider		value		setValueSelector		sliderShadow		sliderColor		descending		model	) from: anObjStream.! !!Slider methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 20:00'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		slider		value		setValueSelector		sliderShadow		sliderColor		descending		model	) on: anObjStream.! !!SmallInteger methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 11:28'!asUnicode	^ self! !!AbstractFont methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/16/2016 23:31'!xRangesFor: aString	"Anwer an array of (leftX, rightX) pairs for the given string."	"(StrikeFont fontName: 'New York' size: 12) xRangesFor: 'Hello'"	"| f | f := StrikeFont fontName: 'New York' size: 12. (1 to: 5) collect: [:i | f widthOfString: ('Hello' copyFrom: 1 to: i)]"	| result lastX w right |	result := Array new: aString size.	lastX := 0.	1 to: aString size do: [:i |		w := self widthOf: (aString at: i).		right := lastX + w.		result at: i put: (Array with: lastX with: right).		lastX := right].	^ result! !!MouseClickState methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/18/2016 17:00'!cursorPoint	^ firstClickDown cursorPoint! !!HandMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/18/2016 17:21'!firstClickCursorPoint	mouseClickState ifNil: [ ^ nil ].	^ mouseClickState cursorPoint! !!HandMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 22:46'!rejectDropMorph: aMorph event: evt	aMorph rejectDropMorphEvent: evt! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/26/2016 22:32' prior: 65657204!drawOn: aCanvas	| bnd gap |	bnd := self bounds.	gap := self layoutInset.	bnd := (bnd topLeft + gap) corner: (bnd bottomRight + gap).	aCanvas drawString: contents in: bnd font: self fontToUse color: color.! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/23/2019 16:20'!fieldsVersion	^ 1! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 10/1/2016 11:51'!initFieldsFrom: anObjStream version: classVersion	| fontSpec |	super initFieldsFrom: anObjStream version: classVersion.	fontSpec := anObjStream nextField.	fontSpec ifNotNil: [		font := StrikeFont fontName: fontSpec first size: fontSpec second].	self initFieldsNamed: #(		emphasis		contents	) from: anObjStream.! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/24/2019 15:35'!isArgMorph	^ false! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/24/2019 15:34'!isBlockMorph	^ false! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/16/2016 23:24'!leftMargin	"Answer the left edge of this StringMorph. For a left-justified string, this the left edge of its bounding box, but for a right-justified string it may be inset."	^ self left "+ (self justificationOffsetFor: contents)"! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/14/2018 07:36'!storeFieldsOn: anObjStream	"self closeEditor."	super storeFieldsOn: anObjStream.	font		ifNil: [anObjStream putField: nil]		ifNotNil: [anObjStream putField: (Array with: font familyName with: font pointSize)].	self storeFieldsNamed: #(		emphasis		contents	) on: anObjStream.! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 10:46'!stringHeight: aString	^ (font ifNil: [ TextStyle defaultFont ]) height ceiling! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/16/2016 23:25'!stringToDisplay	"Answer the string that is displayed. In password mode, this will be all asterisks."	^ contents! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/26/2016 12:37'!stringWidth: aString	^(((self fontToUse widthOfString: aString) max: self minimumWidth) + (self layoutInset * 2)) ceiling! !!StringMorph methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/27/2016 16:11'!xRangesFor: s	"Anwer an array of (leftX, rightX) pairs for the given string. For Unicode, there will be an entry in the resulting array for each UTF character in the input string, even when characters combine, so the x ranges for characters may overlap."	"StringMorph new xRangesFor: 'Hello' asUTF8"	^ self font xRangesFor: s! !!String methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2016 21:20'!asNumberNoError	"Convert the given string to a number without giving errors about its format. Ignore non-digit characters and allow a leading '+', which kids sometimes type. Answer zero if empty."	| s sign ch body |	self size = 0 ifTrue: [^ 0].	s := ReadStream on: self.	s skipSeparators.	"read sign character, if any"	sign := 1.	ch := s peek.	(ch = $+) | (ch = $-) ifTrue: [		ch = $- ifTrue: [sign := -1].		s skip: 1].	body := WriteStream on: (String new: 40).	body nextPut: $0.	[s atEnd not and: [s peek isDigit]] whileTrue: [body nextPut: s next].  "read digits before decimal point"	('.,' includes: s peek) ifTrue: [  "read decimal point (period or comma) and following digits, if any"		s skip: 1.		body nextPut: $..		[s atEnd not and: [s peek isDigit]] whileTrue: [body nextPut: s next]].	"read exponent"	(s atEnd not and: ['eE' includes: s peek]) ifTrue: [		s next.		body nextPut: $e.		(s atEnd not and: [s peek = $-]) ifTrue: [body nextPut: s next].		 "exponent sign"		[s atEnd not and: [s peek isDigit]] whileTrue: [body nextPut: s next]].  "exponent"	^ sign * (body contents asNumber)! !!String methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/26/2016 20:40'!indexOfSeparatorStartingAt: index	"Answer the index of the next separator character found starting at the given index. Answer size + 1 if none is found."	^ self		indexOfAnyOf: CSSeparators		startingAt: index 		ifAbsent: [self size + 1]! !!String methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/15/2018 18:01'!isNumberString	| aStream d pointNumber digitAppears |	pointNumber := false.	digitAppears := false.	aStream := ReadStream on: self.	aStream peek = $- ifTrue: [aStream next].	[aStream atEnd]		whileFalse: 			[d := aStream next.			d = $.				ifTrue: 					[pointNumber ifTrue: [^ false].					pointNumber := true]				ifFalse: [(d < $0 or: [d > $9])						ifTrue: [^ false]						ifFalse: [digitAppears := true]]].	^ digitAppears! !!String methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/24/2019 21:54'!isScriptable	^ false! !!String methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/14/2016 22:46'!isUnicode	^ false! !!String methodsFor: '*FromScratch' stamp: 'EiichiroIto 11/22/2019 15:22'!localized	"Answer myself translated into the current Scratch language. If there is no translation for me, then answer myself."	"| selfAsString |	selfAsString := self asString.	ScratchTranslator addUITranslation: selfAsString.	^ ScratchTranslator translationFor: selfAsString."	^ self! !!String methodsFor: '*FromScratch' stamp: 'EiichiroIto 9/26/2016 19:13'!trailingDigits	"Answer the trailing digits of a string such as 'foo123' If the string does not end in a digit, answer the empty string."	"'foo123' trailingDigits"	"'foo' trailingDigits"	| i |	i := self size.	[(i > 0) and: [(self at: i) isDigit]] whileTrue: [i := i - 1].	^ self copyFrom: i + 1 to: self size! !"FromScratch"!!SBreedIdTest commentStamp: '<historical>' prior: 0!A SBreedIdTest is a test class for testing the behavior of SBreedId!!SBreedTest commentStamp: '<historical>' prior: 0!A SBreedTest is a test class for testing the behavior of SBreed!!SDiffuser2Test commentStamp: '<historical>' prior: 0!A SDiffuser2Test is a test class for testing the behavior of SDiffuser2!!SDiffuserTest commentStamp: '<historical>' prior: 0!A SDiffuserTest is a test class for testing the behavior of SDiffuser!!SDisplayTest commentStamp: '<historical>' prior: 0!A SDisplayTest is a test class for testing the behavior of SDisplay!!SEntryPointsTest commentStamp: '<historical>' prior: 0!A SEventCodesTest is a test class for testing the behavior of SEventCodes!!SExporterTest commentStamp: '<historical>' prior: 0!A SExporterTest is a test class for testing the behavior of SExporter!!SMicroWorldTest commentStamp: '<historical>' prior: 0!A SMicroWorldTest is a test class for testing the behavior of SMicroWorld!!SObserverTest commentStamp: '<historical>' prior: 0!A SObserverTest is a test class for testing the behavior of SObserver!!SObserverVarDefTest commentStamp: '<historical>' prior: 0!A SObserverVarIdTest is a test class for testing the behavior of SObserverVarId!!SPatchesTest commentStamp: '<historical>' prior: 0!A SPatchesTest is a test class for testing the behavior of SPatches!!SProcessTest commentStamp: '<historical>' prior: 0!A SProcessorTest is a test class for testing the behavior of SProcessor!!SProgramTest commentStamp: '<historical>' prior: 0!A SProgramTest is a test class for testing the behavior of SProgram!!SThreadTest commentStamp: '<historical>' prior: 0!A SEngineTest is a test class for testing the behavior of SEngine!!STurtleVarDefTest commentStamp: '<historical>' prior: 0!A STurtleVarIdTest is a test class for testing the behavior of STurtleVarId!!STurtlesTest commentStamp: '<historical>' prior: 0!A STurtlesTest is a test class for testing the behavior of STurtles!!SteloBytecodeGeneratorTest commentStamp: '<historical>' prior: 0!A SBytecodeGeneratorTest is a test class for testing the behavior of SBytecodeGenerator!!SteloLibCallTest commentStamp: '<historical>' prior: 0!A SteloLibCallTest is a test class for testing the behavior of SteloLibCall!!SteloProcessTest commentStamp: '<historical>' prior: 0!A SteloProcessTest is a test class for testing the behavior of SteloProcess!!SpStelo class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 21:35'!appFolderName	^ 'stelo'! !!SpStelo class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 21:36'!appName	^ 'Stelo'! !!SpStelo class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 21:36'!extension	^ 'sl'! !!SpStelo class methodsFor: 'class initialization' stamp: 'EiichiroIto 11/24/2019 21:38'!initialize	ScratchDirectory current appName: self appFolderName! !!SpStelo class methodsFor: 'world menu' stamp: 'EiichiroIto 11/24/2019 21:35'!menuCommandOn: aBuilder	<worldMenu>	(aBuilder item: #Stelo)		order: 0.5;		target: self;		action: [self new open]; 		icon: self icon! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 08:57'!aboutAppString	^ self appName		,			'Copyright © 2019 Eiichiro Ito (ghc02331@nifty.com)All rights reserved.Based on Scratch from the MIT Media Lab, v' , self basedVersion		,			'Copyright © 2009 Massachusetts Institute of Technology.All rights reserved.'! !!SpStelo methodsFor: 'variables' stamp: 'EiichiroIto 11/24/2019 21:57'!addVariable: aString var: vno breed: bno	sworld addVariable: aString var: vno breed: bno! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 08:57'!appName	^ 'Stelo'! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 12/5/2019 21:08'!backupProject	sworld backupBreeds: project breeds! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 16:46'!changeMicroWorld	sworldMode = #SMicroWorld		ifTrue: [ ^ self ].	sworldMode := #SMicroWorld.	self sworld: self newWorld! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 16:46'!changePluginWorld	sworldMode = #SPluginWorld		ifTrue: [ ^ self ].	sworldMode := #SPluginWorld.	self sworld: self newWorld! !!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 11/24/2019 21:29'!clearPatches	sworld clearBreed: project patches breedNo! !!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 11/24/2019 21:31'!clearTurtles	project turtleBreeds do: [ :each | sworld clearBreed: each ]! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 12:00'!createProject	^ SteloProject new! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 16:47'!defaultSWorldMode	^ #SMicroWorld! !!SpStelo methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 21:57'!eventIdFor: aSymbol	^ events at: aSymbol! !!SpStelo methodsFor: 'menu actions' stamp: 'EiichiroIto 11/24/2019 21:33'!exportSexpCode	self export: (ScratchSexpExporter appName: self appName) extension: self sexpExtension! !!SpStelo methodsFor: 'menu actions' stamp: 'EiichiroIto 11/24/2019 21:32'!importSexpCode		self import: (ScratchSexpImporter appName: self appName) extension: self sexpExtension! !!SpStelo methodsFor: 'initialization' stamp: 'EiichiroIto 11/30/2019 17:14'!initialize	super initialize.	lastMSec := nil.	lastTicks := 0.	sworldMode := self defaultSWorldMode.	presenter sworldMode: sworldMode! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 12/5/2019 22:23'!installNewProject: aProject	self stopAllProcesses.	self sworld: self newWorld.	project := aProject.	project application: self.	project setupScripts.	project fixVars.	project modified: false.	self restoreProject.	self setupView.	Smalltalk garbageCollect! !!SpStelo methodsFor: 'processes' stamp: 'EiichiroIto 11/24/2019 16:24'!newCode	^ SteloCode new! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 12:19'!newObserver	^ SObserver new! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 12:19'!newPatches	^ SPatches new! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 08:58'!newPresenter	^ SpSteloFrame basicNew		application: self;		initialize;		whenStepsDo: [ self stepProcesses ]! !!SpStelo methodsFor: 'processes' stamp: 'EiichiroIto 11/24/2019 16:15'!newProgram	^ SProgram new! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 12:19'!newTurtles	^ sworld newBreed! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 16:47'!newWorld	^ (Smalltalk at: sworldMode) new! !!SpStelo methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 15:03'!observerScript	^ project scriptOf: SBreedId observerBreedNo! !!SpStelo methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 15:03'!patchesScript	^ project scriptOf: SBreedId patchBreedNo! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 12:03'!restoreProject	sworld restoreBreeds: project breeds! !!SpStelo methodsFor: 'processes' stamp: 'EiichiroIto 11/24/2019 16:12'!runLoop	| program |	self setupEvents.	program := project programOf: events.	process := sworld newProcess program: program.	process loop.	^ process! !!SpStelo methodsFor: 'processes' stamp: 'EiichiroIto 11/24/2019 16:12'!runSetup	| program |	self setupEvents.	program := project programOf: events.	process := sworld newProcess program: program.	process startup.	^ process! !!SpStelo methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 16:45'!scriptOf: anInteger	^ project scriptOf: anInteger! !!SpStelo methodsFor: 'processes' stamp: 'EiichiroIto 11/24/2019 16:11'!setupEvents	| result eventId |	eventId := EventId new.	result := Dictionary new.	result at: #startup put: EventId startupEventNo.	result at: #setup put: EventId setupEventNo.	result at: #loop put: EventId loopEventNo.	result at: #single put: EventId singleEventNo.	project allEventNames do: [ :each | result at: each asSymbol put: eventId newNo ].	events := result.	^ events! !!SpStelo methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 21:33'!sexpExtension	^ 'sts'! !!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 11/24/2019 16:43'!startLoop	self stopAllProcesses.	presenter stepTime: 0.	self runLoop! !!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 11/24/2019 16:43'!startLoopSlow	self stopAllProcesses.	presenter stepTime: 500.	self runLoop! !!SpStelo methodsFor: 'processes' stamp: 'EiichiroIto 11/24/2019 16:10'!startProcessFor: topBlock	| code program |	self stopAllProcesses.	self setupEvents.	code := self newCode parse: topBlock target: presenter target.	program := self newProgram.	program		addCode: code;		addEntryPoint: 1			eventNo: EventId singleEventNo			breedNo: topBlock receiver breedNo.	process := sworld newProcess program: program.	process single.	^ process! !!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 11/24/2019 16:43'!startSetup	self stopAllProcesses.	presenter stepTime: 0.	self runSetup! !!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 11/24/2019 16:44'!stepLoop	self stopAllProcesses.	presenter stepTime: 0.	self runLoop.	self stepProcesses.	self stopAllProcesses! !!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 11/24/2019 16:44'!stopAll	presenter stepTime: 1000.	self stopAllProcesses! !!SpStelo methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 12:03'!sworld	^ sworld! !!SpStelo methodsFor: 'accessing' stamp: 'EiichiroIto 12/5/2019 21:12'!sworld: aWorld	sworld ifNotNil: [ self backupProject ].	sworld := aWorld.	project ifNotNil: [ self restoreProject ].	presenter sworld: aWorld! !!SpStelo methodsFor: 'menu actions' stamp: 'EiichiroIto 11/30/2019 17:10'!toggleSWorld	sworldMode = #SMicroWorld		ifTrue: [ self changePluginWorld ]		ifFalse: [ self changeMicroWorld ].	presenter sworldMode: sworldMode! !!SpStelo methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 15:04'!turtlesScript: bno	^ project scriptOf: bno! !!SpStelo methodsFor: 'processes' stamp: 'EiichiroIto 11/24/2019 17:08'!updateInfo	| msec ticks fps info |	msec := Time millisecondClockValue.	ticks := sworld ticks.	lastMSec		ifNotNil: [ fps := ((ticks - lastTicks) * 1000 / (msec - lastMSec)) truncated.			info := 'ticks=' , ticks truncated asString , ' (' , fps asString				, 'fps)'.			presenter info: info ].	lastMSec := msec.	lastTicks := ticks! !!SBenchmark methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 17:28'!diffuseAndMultiply: anInteger	"SBenchmark new diffuseAndMultiply: 100000. --> "	"SBenchmark new diffuseAndMultiply: 1000. --> 16237"	"SBenchmark new diffuseAndMultiply: 1000. --> 9770"	"SBenchmark new diffuseAndMultiply: 1000. --> 9229"	"SBenchmark new diffuseAndMultiply: 1000. --> 14574"	"SBenchmark new diffuseAndMultiply: 1000. --> 9254"	"SBenchmark new diffuseAndMultiply: 1000. 15080"	"SBenchmark new diffuseAndMultiply: 1000. 15398"	"SBenchmark new diffuseAndMultiply: 1000. 16743"	"SBenchmark new diffuseAndMultiply: 1000. 9618"	"SBenchmark new diffuseAndMultiply: 1000. 11163"	"SBenchmark new diffuseAndMultiply: 1000. 11057"	"SBenchmark new diffuseAndMultiply: 1000. 8669"	"SBenchmark new diffuseAndMultiply: 1000. 10050 "	| w p pr ret v |	w := SMicroWorld new.	w addBreed: (SObserver new sworld: w).	w addBreed: SPatches new.	w createPatch: 100.	v := w patches addVariable: 'a'.	w var: v breed: SBreedId patchBreedNo putAll: 100.	pr := SProgram new.	pr		addCode:			{v.			20.			#diffuse.			v.			0.95.			#multiplyBy}.	pr		addEntryPoint: 1		eventNo: EventId loopEventNo		breedNo: SBreedId observerBreedNo.	p := w newProcess program: pr.	p loop.	Smalltalk garbageCollect.	ret := Time millisecondsToRun: [ anInteger timesRepeat: [ p step ] ].	^ ret! !!SBenchmark methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 17:28'!forwardAndTurn: anInteger	"SBenchmark new forwardAndTurn: 10000. --> 25618"	"SBenchmark new forwardAndTurn: 10000. --> 28503"	"SBenchmark new forwardAndTurn: 10000. --> 2679"	"SBenchmark new forwardAndTurn: 100000. --> 30937"	"SBenchmark new forwardAndTurn: 100000. --> 30463"	"SBenchmark new forwardAndTurn: 100000. --> 28387"	"SBenchmark new forwardAndTurn: 100000. 74578"	"SBenchmark new forwardAndTurn: 100000. 61745"	"SBenchmark new forwardAndTurn: 100000. 66739"	"SBenchmark new forwardAndTurn: 100000. 98973"	"SBenchmark new forwardAndTurn: 100000. 103008"	"SBenchmark new forwardAndTurn: 100000. 111147"	"SBenchmark new forwardAndTurn: 100000. 61259"	"SBenchmark new forwardAndTurn: 100000. 60514"	"SBenchmark new forwardAndTurn: 100000. 56667"	"SBenchmark new forwardAndTurn: 100000. 55183"	"SBenchmark new forwardAndTurn: 100000. 38644"	"SBenchmark new forwardAndTurn: 100000. 46125"	"SBenchmark new forwardAndTurn: 100000. 44769 "	"SBenchmark new forwardAndTurn: 100000. 32495"	"SBenchmark new forwardAndTurn: 100000. 31757 "	"SBenchmark new forwardAndTurn: 100000. "	"42847 33955 30555 "	| w p pr ret |	w := SMicroWorld new.	w addBreed: (SObserver new sworld: w).	w addBreed: SPatches new.	w addBreed: (STurtles new breedNo: 3).	w		createPatch: 100;		create: 3 turtles: anInteger.	pr := SProgram new.	pr addCode: #(#pushShort 10 0 #forward #pushShort 15 0 #pushShort 5 0 #getVar #plus #setHeading #stop).	pr addEntryPoint: 1 eventNo: EventId loopEventNo breedNo: 3.	p := w newProcess program: pr.	p loop.	Smalltalk garbageCollect.	ret := Time millisecondsToRun: [ 100 timesRepeat: [ p step ] ].	^ ret! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 21:44'!addVariable: aString	| id |	id := varId addVariable: aString.	variables updateVarDef: varId.	^ id! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:25'!breedName	self subclassResponsibility! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:20'!breedNo	self subclassResponsibility! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:20'!breedNo: anInteger	self subclassResponsibility! !!SBreed methodsFor: 'microworld' stamp: 'EiichiroIto 11/28/2019 21:54'!clear	"clear means clear all variable values with keeping its definition"	variables ifNil: [ ^ self ].	variables clear.	"self halt.	variables updateVarDef: varId"! !!SBreed methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/15/2019 19:56'!colorAt: anInteger	^ variables var: varId class colorVarNo at: anInteger! !!SBreed methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/15/2019 19:56'!colorAt: index put: anInteger	self var: varId class colorVarNo at: index put: anInteger! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 9/28/2019 19:10'!colors	^ variables realArrayAt: varId class colorVarNo! !!SBreed methodsFor: 'microworld' stamp: 'EiichiroIto 8/16/2019 17:06'!countAlive	^ self size! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 21:33'!deleteVariable: aString	varId delete: aString.	variables updateVarDef: varId.! !!SBreed methodsFor: 'object i/o' stamp: 'EiichiroIto 9/13/2018 20:50'!fieldsVersion	^ 1! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 9/25/2019 20:25'!fixVars	varId fixVars.	variables ifNotNil: [ variables fixVars: varId ].! !!SBreed methodsFor: 'accessing variable' stamp: 'EiichiroIto 9/28/2019 19:10'!flag: anInteger at: id	| vars v b |	vars := variables varAt: varId class flagVarNo.	b := 1 << anInteger.	v := vars at: id.	^ (v bitAnd: b) > 0! !!SBreed methodsFor: 'accessing variable' stamp: 'EiichiroIto 9/28/2019 19:10'!flag: anInteger at: id put: aBoolean	| vars v b |	vars := variables varAt: varId class flagVarNo.	b := 1 << anInteger.	v := vars at: id.	v := aBoolean		ifTrue: [ v bitOr: b ]		ifFalse: [ v bitClear: b ].	vars at: id put: v! !!SBreed methodsFor: 'object i/o' stamp: 'EiichiroIto 9/13/2018 21:32'!initFieldsFrom: anObjStream version: classVersion	self initFieldsNamed: #(varId variables) from: anObjStream.! !!SBreed methodsFor: 'initialization' stamp: 'EiichiroIto 9/23/2019 21:03'!initialize	self reset.! !!SBreed methodsFor: 'microworld' stamp: 'EiichiroIto 3/13/2019 21:19'!livingOnesDo: aBlock	self subclassResponsibility.! !!SBreed methodsFor: 'private' stamp: 'EiichiroIto 9/10/2018 20:04'!privVariables	^ variables! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 9/29/2019 17:10'!realVarNames	^ varId realVarNames! !!SBreed methodsFor: 'initialization' stamp: 'EiichiroIto 11/28/2019 22:15'!reset	"reset means clear all variable with its definitions"	varId := SBreedVarDef new.	variables := Variables new updateVarDef: varId.! !!SBreed methodsFor: 'microworld' stamp: 'EiichiroIto 3/13/2019 15:40'!scaleValue: v color: anInteger from: aNumber1 to: aNumber2	(aNumber1 < aNumber2 and: [ v < aNumber1 ])		ifTrue: [ ^ SColorList black ].	(aNumber1 < aNumber2 and: [ v > aNumber2 ])		ifTrue: [ ^ SColorList white ].	(aNumber1 > aNumber2 and: [ v > aNumber1 ])		ifTrue: [ ^ SColorList black ].	(aNumber1 > aNumber2 and: [ v < aNumber2 ])		ifTrue: [ ^ SColorList white ].	^ (anInteger - 5 interpolateTo: anInteger + 4 at: (v - aNumber1) / (aNumber2 - aNumber1))		truncated! !!SBreed methodsFor: 'microworld' stamp: 'EiichiroIto 3/15/2019 19:56'!scaleVarNo: vid color: anInteger from: aNumber1 to: aNumber2 index: id	| v c |	v := variables var: vid at: id.	c := self		scaleValue: v		color: anInteger		from: aNumber1		to: aNumber2.	self colorAt: id put: c! !!SBreed methodsFor: 'microworld' stamp: 'EiichiroIto 9/23/2019 21:08'!size	self subclassResponsibility.! !!SBreed methodsFor: 'object i/o' stamp: 'EiichiroIto 9/13/2018 21:32'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(varId variables) on: anObjStream.! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 12:37'!userDefinedListNames	^ varId listNames! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2018 06:38'!userDefinedVarNames	^ varId userDefinedVarNames! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 8/11/2019 14:44'!userDefinedVarNoAndNames	^ varId userDefinedVarNoAndNames! !!SBreed methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/15/2019 19:56'!var: anInteger at: id	^ variables var: anInteger at: id! !!SBreed methodsFor: 'accessing variable' stamp: 'EiichiroIto 9/28/2019 19:11'!var: anInteger at: id put: aNumber	(variables varAt: anInteger) at: id put: aNumber.! !!SBreed methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/15/2019 19:56'!var: anInteger putAll: anObject	variables setVar: anInteger toAll: anObject.! !!SBreed methodsFor: 'accessing variable' stamp: 'EiichiroIto 9/29/2019 15:41'!varArrayNamed: aString	| vno |	vno := self varNoFor: aString.	^ variables realArrayAt: vno! !!SBreed methodsFor: 'accessing variable' stamp: 'EiichiroIto 8/22/2019 18:33'!varArrayNamed: aString put: aCollection	| vno |	vno := self varNoFor: aString.	^ variables setVar: vno toArray: aCollection! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 9/22/2018 08:17'!varId	^ varId! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2018 06:37'!varNames	^ varId varNames! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:47'!varNoFor: aString	^ varId varNoFor: aString! !!SBreed methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2018 06:39'!variableNameInUse: aString	^ varId includes: aString! !!SObserver methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 08:57'!breedId	^ breedId! !!SObserver methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:25'!breedName	^ 'Observer'! !!SObserver methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:20'!breedNo	^ SBreedId observerBreedNo! !!SObserver methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:20'!breedNo: anInteger	"do nothing"! !!SObserver methodsFor: 'microworld' stamp: 'EiichiroIto 9/3/2019 21:55'!clearTicks	ticks := 0.! !!SObserver methodsFor: 'accessing' stamp: 'EiichiroIto 8/16/2019 18:56'!colors	self shouldNotImplement.! !!SObserver methodsFor: 'object i/o' stamp: 'EiichiroIto 9/3/2019 20:36'!fieldsVersion	^ 1! !!SObserver methodsFor: 'microworld' stamp: 'EiichiroIto 9/3/2019 21:54'!incrementTicks	ticks := ticks + 1.! !!SObserver methodsFor: 'object i/o' stamp: 'EiichiroIto 9/3/2019 21:44'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(breedId ticks) from: anObjStream.! !!SObserver methodsFor: 'initialization' stamp: 'EiichiroIto 9/23/2019 21:03'!initialize	super initialize.	breedId := SBreedId new.	ticks := 0.! !!SObserver methodsFor: 'enumerating' stamp: 'EiichiroIto 8/1/2019 13:27'!livingOnesDo: aBlock	aBlock value: 1.! !!SObserver methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 08:58'!newTurtle	| bid breed |	bid := breedId newNo.	breed := STurtles new breedNo: bid.	^ breed! !!SObserver methodsFor: 'initialization' stamp: 'EiichiroIto 11/28/2019 22:09'!reset	varId := SObserverVarDef new.	variables := nil. "SVariables new updateVarId: varId."! !!SObserver methodsFor: 'microworld' stamp: 'EiichiroIto 9/23/2019 21:08'!size	^ 1! !!SObserver methodsFor: 'object i/o' stamp: 'EiichiroIto 9/3/2019 21:44'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(breedId ticks) on: anObjStream.! !!SObserver methodsFor: 'microworld' stamp: 'EiichiroIto 9/3/2019 21:51'!ticks	^ ticks! !!SObserver methodsFor: 'microworld' stamp: 'EiichiroIto 11/29/2019 20:24'!var: anInteger at: id	self shouldNotImplement! !!SObserver methodsFor: 'microworld' stamp: 'EiichiroIto 11/29/2019 20:24'!var: anInteger at: dummy put: anObject	self shouldNotImplement! !!SObserver methodsFor: 'microworld' stamp: 'EiichiroIto 11/29/2019 20:24'!var: anInteger at: dummy put: anObject sworld: aWorld	anInteger = varId ticksVarNo		ifTrue: [ ^ ticks := anObject ]! !!SObserver methodsFor: 'microworld' stamp: 'EiichiroIto 11/29/2019 20:24'!var: anInteger at: id sworld: aWorld	| v |	v := varId class.	anInteger = v widthVarNo		ifTrue: [ ^ aWorld extent x ].	anInteger = v heightVarNo		ifTrue: [ ^ aWorld extent y ].	anInteger = v maxBreedNoVarNo		ifTrue: [ ^ aWorld maxBreedNo ].	anInteger = v ticksVarNo		ifTrue: [ ^ ticks ].	anInteger = v countAliveVarNo		ifTrue: [ ^ aWorld countAliveOf: id ].	anInteger = v sizeVarNo		ifTrue: [ ^ aWorld sizeOf: id ].	anInteger = v maxVarVarNo		ifTrue: [ ^ self ].	^ 0! !!SObserver methodsFor: 'accessing variable' stamp: 'EiichiroIto 8/22/2019 18:33'!varArrayNamed: aString	^ nil! !!SObserver methodsFor: 'accessing variable' stamp: 'EiichiroIto 8/22/2019 18:34'!varArrayNamed: aString put: aCollection	"do nothing"! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 3/15/2019 19:56'!aimHighVarNo: vid atPoint: aPoint direction: heading	| pos id delta forward left right |	delta := Point r: 1.5 degrees: heading \\ 360.	pos := aPoint + delta.	id := self indexAtPoint: pos.	forward := variables var: vid at: id.	delta := Point r: 1.5 degrees: (heading + 45) \\ 360.	pos := aPoint + delta.	id := self indexAtPoint: pos.	left := variables var: vid at: id.	delta := Point r: 1.5 degrees: (heading - 45) \\ 360.	pos := aPoint + delta.	id := self indexAtPoint: pos.	right := variables var: vid at: id.	^ (forward >= left and: [ forward >= right ])		ifTrue: [ 0 ]		ifFalse: [ left >= right				ifTrue: [ 45 ]				ifFalse: [ -45 ] ].! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:26'!breedName	^ 'Patch'! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:20'!breedNo	^ SBreedId patchBreedNo! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:20'!breedNo: anInteger	"do nothing"! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 9/23/2019 22:18'!clear	super clear.	variables forceSize: self size.! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 14:26'!colorAtPoint: aPoint	| index |	index := self indexAtPoint: aPoint.	^ self colorAt: index! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 14:30'!colorAtPoint: aPoint put: anInteger	| index |	index := self indexAtPoint: aPoint.	self colorAt: index put: anInteger! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 14:35'!cols	^ order! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 9/26/2019 11:01'!create: anInteger	order := anInteger.	self setupCaches.	self clear.! !!SPatches methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 14:34'!defaultOrder	^ 100! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 9/28/2019 19:12'!diffuse4: anInteger1 varNo: anInteger2	| buf |	buf := variables realArrayAt: anInteger2.	diffuser diffuse: buf order: order percent: anInteger1 neighborSize: 4.! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 9/28/2019 19:12'!diffuse8: anInteger1 varNo: anInteger2	| buf |	buf := variables realArrayAt: anInteger2.	diffuser diffuse: buf order: order percent: anInteger1 neighborSize: 8.! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 14:35'!extent	^ order @ order! !!SPatches methodsFor: 'object i/o' stamp: 'EiichiroIto 9/13/2018 21:03'!fieldsVersion	^ 1! !!SPatches methodsFor: 'private' stamp: 'EiichiroIto 8/27/2019 15:45'!indexAtCol: c row: r	| i |	i := (r - 1) * order + c.	^ ((i - 1) \\ self size) + 1! !!SPatches methodsFor: 'private' stamp: 'EiichiroIto 8/27/2019 15:46'!indexAtPoint: aPoint	| r c |	c := aPoint x floor + (order // 2) + 1.	r := aPoint y floor + (order // 2) + 1.	^ self indexAtCol: c row: r! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 3/16/2019 19:15'!indexAtX: x y: y	| x1 y1 |	x1 := self normalize: x.	y1 := self normalize: y.	^ self indexAtPoint: x1 @ y1! !!SPatches methodsFor: 'object i/o' stamp: 'EiichiroIto 9/26/2019 11:02'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(order) from: anObjStream.	self setupCaches.! !!SPatches methodsFor: 'initialization' stamp: 'EiichiroIto 9/23/2019 21:04'!initialize	super initialize.	diffuser := SDiffuser2 new.	self create: self defaultOrder.! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 8/16/2019 17:14'!livingOnesDo: aBlock	1 to: self size do: [ :each | aBlock value: each ].! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 9/28/2019 19:12'!multiplyBy: aNumber varNo: anInteger	| src |	src := variables realArrayAt: anInteger.	src *= aNumber.! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 14:36'!normalize: aNumber	| h x |	x := aNumber.	h := order / 2.	x := x \\ order.	x >= h ifTrue: [ x := x - order ].	^ x! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 9/28/2019 19:12'!nsum4: anInteger1 to: anInteger2	| src dst |	src := variables realArrayAt: anInteger1.	dst := variables realArrayAt: anInteger2.	diffuser nsum: src dst: dst order: order neighborSize: 4.! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 9/28/2019 19:12'!nsum8: anInteger1 to: anInteger2	| src dst |	src := variables realArrayAt: anInteger1.	dst := variables realArrayAt: anInteger2.	diffuser nsum: src dst: dst order: order neighborSize: 8.! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 14:35'!order	^ order! !!SPatches methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 14:39'!pointOfRow: r col: c	^ (r - 1 - (order // 2)) @ (c - 1 - (order // 2))! !!SPatches methodsFor: 'printing' stamp: 'EiichiroIto 3/13/2019 14:39'!printOn: aStream	aStream		nextPutAll: 'Patches(';		nextPutAll: order asString;		nextPut: $x;		nextPutAll: order asString;		nextPut: $).! !!SPatches methodsFor: 'initialization' stamp: 'EiichiroIto 11/28/2019 22:09'!reset	varId := SPatchVarDef new.	variables := Variables new updateVarDef: varId.! !!SPatches methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 14:35'!rows	^ order! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 9/28/2019 19:13'!scaleVarNo: vid color: baseColor from: from to: to	| v c |	v := variables realArrayAt: vid.	v		withIndexDo: [ :each :index | 			c := self				scaleValue: each				color: baseColor				from: from				to: to.			self colorAt: index put: c ]! !!SPatches methodsFor: 'private' stamp: 'EiichiroIto 9/28/2019 19:27'!setupCaches	halfOrder := (order / 2) asFloat.	negatedHalfOrder := halfOrder negated.! !!SPatches methodsFor: 'microworld' stamp: 'EiichiroIto 9/23/2019 20:23'!size	^ order * order! !!SPatches methodsFor: 'object i/o' stamp: 'EiichiroIto 3/18/2019 16:23'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(order) on: anObjStream.! !!SPatches methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:21'!var: anInteger1 at: anInteger2	anInteger1 = varId class xVarNo		ifTrue: [ ^ self xAt: anInteger2 ].	anInteger1 = varId class yVarNo		ifTrue: [ ^ self yAt: anInteger2 ].	^ super var: anInteger1 at: anInteger2! !!SPatches methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/18/2019 15:50'!var: anInteger at: id put: aNumber	| data |	data := aNumber.	anInteger = varId class colorVarNo		ifTrue: [ data := SColorList default normalize: data ].	super var: anInteger at: id put: data.! !!SPatches methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/13/2019 14:39'!xAt: anInteger"0 1 2 3-2 -1 0 1 0  1  2  3  4-2 -1  0  1  2"	^ (anInteger - 1 \\ order) - (order // 2)! !!SPatches methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/13/2019 14:39'!yAt: anInteger"0 1 2 3-2 -1 0 1 0  1  2  3  4-2 -1  0  1  2"	^ (anInteger - 1 // order) - (order // 2)! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:22'!aliveAt: index	^ self flag: varId class aliveFlagNo at: index! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:22'!aliveAt: index put: aBoolean	self flag: varId class aliveFlagNo at: index put: aBoolean.! !!STurtles methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:26'!breedName	^ 'Turtle', breedNo asString! !!STurtles methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:22'!breedNo	^ breedNo! !!STurtles methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 07:22'!breedNo: anInteger	breedNo := anInteger.! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 3/18/2019 16:15'!copyTurtleFrom: anInteger1 to: anInteger2	variables copyElementFrom: anInteger1 to: anInteger2! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 8/16/2019 17:20'!countAlive	| ret |	ret := 0.	self livingOnesDo: [ :each | ret := ret + 1 ].	^ ret! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 10/18/2019 07:26'!create: anInteger	| rest tno list |	rest := anInteger.	list := OrderedCollection new.	tno := 1.	[ rest > 0 ]		whileTrue: [ (self aliveAt: tno)				ifFalse: [ self setupAt: tno.					list add: tno.					rest := rest - 1 ].				tno := tno + 1 ].	^ list! !!STurtles methodsFor: 'accessing' stamp: 'EiichiroIto 3/16/2019 12:38'!defaultColor	^ defaultColor! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 8/27/2019 16:27'!defaultPosition	^ defaultPosition! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 8/27/2019 16:28'!defaultPosition: aPoint	defaultPosition := aPoint.! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/14/2019 20:43'!deltaAt: anInteger	| h |	h := self headingAt: anInteger.	^ Point r: 1.0 degrees: h! !!STurtles methodsFor: 'object i/o' stamp: 'EiichiroIto 9/15/2018 16:46'!fieldsVersion	^ 1! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:22'!headingAt: anInteger	^ self var: varId class headingVarNo at: anInteger! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:22'!headingAt: anInteger put: aNumber	self var: varId class headingVarNo at: anInteger put: aNumber.! !!STurtles methodsFor: 'object i/o' stamp: 'EiichiroIto 8/8/2019 07:20'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(defaultColor #breedNo) from: anObjStream.! !!STurtles methodsFor: 'initialization' stamp: 'EiichiroIto 9/23/2019 21:05'!initialize	super initialize.	defaultColor := SColorList atRandom.	defaultPosition := 0 @ 0.	self clear.! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 3/13/2019 16:07'!killAt: anIndex	self aliveAt: anIndex put: false.! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 10/18/2019 07:22'!livingOnesDo: aBlock	1 to: self size do: [ :each | 		(self flag: varId class aliveFlagNo at: each)			ifTrue: [ aBlock value: each ] ]! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:23'!penDownAt: anInteger	^ self flag: varId class penDownFlagNo at: anInteger! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:23'!penDownAt: anInteger put: aBoolean	self flag: varId class penDownFlagNo at: anInteger put: aBoolean.! !!STurtles methodsFor: 'printing' stamp: 'EiichiroIto 8/16/2019 17:16'!printOn: aStream	aStream		nextPutAll: 'Turtles(';		nextPutAll: self countAlive asString;		nextPut: $).! !!STurtles methodsFor: 'initialization' stamp: 'EiichiroIto 11/28/2019 22:09'!reset	varId := STurtleVarDef new.	variables := Variables new updateVarDef: varId.! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 10/18/2019 07:26'!setupAt: index	self colorAt: index put: self defaultColor.	self aliveAt: index put: true.	self xAt: index put: self defaultPosition x.	self yAt: index put: self defaultPosition y.	self headingAt: index put: 360 atRandom - 1.0.	self penDownAt: index put: false! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 9/23/2019 21:09'!size	^ variables max! !!STurtles methodsFor: 'object i/o' stamp: 'EiichiroIto 8/8/2019 07:20'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(defaultColor #breedNo) on: anObjStream.! !!STurtles methodsFor: 'microworld' stamp: 'EiichiroIto 3/13/2019 21:18'!turtlesAtPoint: aPoint	| list x y |	x := aPoint x truncated.	y := aPoint y truncated.	list := OrderedCollection new.	self		livingOnesDo: [ :index | 			((self xAt: index) truncated = x and: [ (self yAt: index) truncated = y ])				ifTrue: [ list add: index ] ].	^ list! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 9/12/2019 18:03'!var: anInteger at: id put: aNumber	| data |	data := aNumber.	anInteger = varId class colorVarNo		ifTrue: [ data := SColorList default normalize: data.			defaultColor := data ].	anInteger = varId class headingVarNo		ifTrue: [ data := aNumber \\ 360 ].	super var: anInteger at: id put: data! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:23'!xAt: anInteger	^ self var: varId class xVarNo at: anInteger! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:23'!xAt: anInteger put: aNumber	self var: varId class xVarNo at: anInteger put: aNumber.! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:23'!yAt: anInteger	^ self var: varId class yVarNo at: anInteger! !!STurtles methodsFor: 'accessing variable' stamp: 'EiichiroIto 10/18/2019 07:23'!yAt: anInteger put: aNumber	self var: varId class yVarNo at: anInteger put: aNumber.! !!SColorList class methodsFor: 'accessing' stamp: 'EiichiroIto 9/9/2018 10:05'!atRandom	^ self default random! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:35'!black	^ 0! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:35'!blue	^ 105! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:35'!brown	^ 35! !!SColorList class methodsFor: 'accessing' stamp: 'EiichiroIto 9/4/2018 09:30'!clear	"SColorList clear."	DefaultList := nil.! !!SColorList class methodsFor: 'accessing' stamp: 'EiichiroIto 9/4/2018 11:49'!colorAt: anInteger	^ self default colorAt: anInteger! !!SColorList class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 15:45'!colorNames	^ #(black gray white red orange brown yellow green lime turquoise cyan sky blue purple magenta pink)! !!SColorList class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 17:10'!colorOf: aSymbol	^ self perform: aSymbol! !!SColorList class methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 17:21'!colorOf: baseColor lightness: anInteger	^ Color h: baseColor hue s: baseColor saturation l: (self lightness at: anInteger + 6)! !!SColorList class methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 17:20'!colors	| colors c |	colors := Array new: 140.	1 to: 10 do: [ :each | 		c := Color h: Color black hue s: Color black saturation l: (each - 1) / 9.0.		colors at: each put: c ].	11 to: 20 do: [ :each | colors at: each put: (self colorOf: Color red lightness: each - self red - 1) ].	21 to: 30 do:		[ :each | colors at: each put: (self colorOf: Color orange lightness: each - self orange - 1) ].	31 to: 40 do:		[ :each | colors at: each put: (self colorOf: Color brown lightness: each - self brown - 1) ].	41 to: 50 do:		[ :each | colors at: each put: (self colorOf: Color yellow lightness: each - self yellow - 1) ].	51 to: 60 do:		[ :each | colors at: each put: (self colorOf: Color green lightness: each - self green - 1) ].	61 to: 70 do: [ :each | 		colors			at: each			put:				(self					colorOf:						(Color							r: 50							g: 205							b: 50							range: 255)					lightness: each - self lime - 1) ].	71 to: 80 do: [ :each | 		colors			at: each			put:				(self					colorOf:						(Color							r: 64							g: 224							b: 208							range: 255)					lightness: each - self turquoise - 1) ].	81 to: 90 do:		[ :each | colors at: each put: (self colorOf: Color cyan lightness: each - self cyan - 1) ].	91 to: 100 do: [ :each | 		colors			at: each			put:				(self					colorOf:						(Color							r: 178							g: 255							b: 255							range: 255)					lightness: each - self sky - 1) ].	101 to: 110 do:		[ :each | colors at: each put: (self colorOf: Color blue lightness: each - self blue - 1) ].	111 to: 120 do:		[ :each | colors at: each put: (self colorOf: Color purple lightness: each - self purple - 1) ].	121 to: 130 do:		[ :each | colors at: each put: (self colorOf: Color magenta lightness: each - self magenta - 1) ].	131 to: 140 do:		[ :each | colors at: each put: (self colorOf: Color pink lightness: each - self pink - 1) ].	^ colors! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:35'!cyan	^ 85! !!SColorList class methodsFor: 'accessing' stamp: 'EiichiroIto 9/4/2018 09:30'!default	"SColorList default."	DefaultList ifNil: [ DefaultList := self new ].	^ DefaultList! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:36'!gray	^ 5! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:36'!green	^ 55! !!SColorList class methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 17:21'!lightness	^ #(0.25 0.3 0.35 0.4 0.45 0.5 0.6 0.7 0.8 0.9)! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:36'!lime	^ 65! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:36'!magenta	^ 125! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:36'!orange	^ 25! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:36'!pink	^ 135! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:36'!purple	^ 115! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:36'!red	^ 15! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:36'!sky	^ 95! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:37'!turquoise	^ 75! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:37'!white	^ 9! !!SColorList class methodsFor: 'constants' stamp: 'EiichiroIto 3/13/2019 15:37'!yellow	^ 45! !!SColorList methodsFor: 'accessing' stamp: 'EiichiroIto 3/18/2019 16:01'!colorAt: anInteger	| index |	index := self normalize: anInteger.	^ colors at: index + 1! !!SColorList methodsFor: 'private' stamp: 'EiichiroIto 2/24/2019 19:08'!generateSource	| w |	w := WriteStream on: ''.	colors		withIndexDo: [ :each :index | 			w				nextPutAll: 'color[';				nextPutAll: (index - 1) asString;				nextPutAll: '] = RGB(';				nextPutAll: (each red * 255) truncated asString;				nextPutAll: ',';				nextPutAll: (each green * 255) truncated asString;				nextPutAll: ',';				nextPutAll: (each blue * 255) truncated asString;				nextPutAll: ');';				nextPutAll: String lf ].	^ w contents! !!SColorList methodsFor: 'initialization' stamp: 'EiichiroIto 3/13/2019 17:21'!initialize	colors := self class colors.! !!SColorList methodsFor: 'accessing' stamp: 'EiichiroIto 9/12/2018 19:55'!normalize: aNumber	^ aNumber floor \\ colors size! !!SColorList methodsFor: 'accessing' stamp: 'EiichiroIto 9/15/2018 17:14'!random	^ colors size atRandom - 2 + 1! !!SColorList methodsFor: 'accessing' stamp: 'EiichiroIto 9/15/2018 17:20'!size	^ colors size! !!SDiffuser class methodsFor: 'instance creation' stamp: 'EiichiroIto 10/17/2018 18:11'!neighbor4	^ self basicNew		setupSelector: #setupNeighbor4;		yourself.! !!SDiffuser class methodsFor: 'instance creation' stamp: 'EiichiroIto 10/17/2018 18:11'!neighbor8	^ self basicNew		setupSelector: #setupNeighbor8;		yourself.! !!SDiffuser class methodsFor: 'instance creation' stamp: 'EiichiroIto 10/17/2018 18:14'!new	self shouldNotImplement.! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/25/2018 13:42'!borders	^ #(top left right bottom)! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/25/2018 13:42'!corners	^ #(topLeft topRight bottomLeft bottomRight)! !!SDiffuser methodsFor: 'accessing' stamp: 'EiichiroIto 10/25/2018 13:50'!diffuse: anInteger array: anArray	self privSrc: anArray.	self diffuseInner: anInteger.	self borders do: [ :each | self diffuseBorder: anInteger at: each ].	self corners do: [ :each | self diffuseCorner: anInteger at: each ].	^ dst! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 19:04'!diffuseBorder: anInteger at: aSymbol	| srcIndex dstIndex data use distributes size list |	list := indexesDict at: aSymbol.	size := neighbor size.	rows + 2 to: list size - rows - 1 do: [ :i | 		srcIndex := list at: i.		data := src at: srcIndex.		use := data / 100.0 * anInteger.		distributes := use / size.		dst at: srcIndex put: (dst at: srcIndex) + data - use.		neighbor + i			do: [ :i2 | 				dstIndex := list at: i2.				dst at: dstIndex put: (dst at: dstIndex) + distributes ] ].! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 19:04'!diffuseCorner: anInteger at: aSymbol	| index data use distributes list |	list := indexesDict at: aSymbol.	index := list at: 5.	data := src at: index.	use := data / 100.0 * anInteger.	distributes := use / cornerIndexes size.	dst at: index put: (dst at: index) + data - use.	cornerIndexes		do: [ :i | 			index := list at: i.			dst at: index put: (dst at: index) + distributes ].! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 14:08'!diffuseInner: anInteger	| use distributes size data |	size := neighbor size.	(indexesDict at: #inner)		do: [ :index | 			data := src at: index.			use := data / 100.0 * anInteger.			distributes := use / size.			dst at: index put: ((dst at: index) + data - use).			neighbor + index				do: [ :dstIndex | dst at: dstIndex put: ((dst at: dstIndex) + distributes) ] ].! !!SDiffuser methodsFor: 'accessing' stamp: 'EiichiroIto 10/25/2018 13:51'!nsum: anArray	self privSrc: anArray.	self nsumInner.	self borders do: [ :each | self nsumBorderAt: each ].	self corners do: [ :each | self nsumCornerAt: each ].	^ dst! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/25/2018 13:30'!nsumBorderAt: aSymbol	| list index index2 sum |	list := indexesDict at: aSymbol.	rows + 2 to: list size - rows - 1 do: [ :i | 		index := list at: i.		sum := neighbor + i			sum: [ :i2 | 				index2 := list at: i2.				src at: index2 ].		dst at: index put: sum ].! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/25/2018 13:27'!nsumCornerAt: aSymbol	| list index sum |	list := indexesDict at: aSymbol.	sum := cornerIndexes		sum: [ :i | 			index := list at: i.			src at: index ].	index := list at: 5.	dst at: index put: sum.! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/25/2018 13:31'!nsumInner	| list sum |	list := indexesDict at: #inner.	list		do: [ :index | 			sum := neighbor + index sum: [ :i | src at: i ].			dst at: index put: sum ].! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 08:43'!privCols	^ cols! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 17:55'!privCornerIndexes	^ cornerIndexes! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 08:41'!privDst: aFloatArray	dst := aFloatArray.! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 14:08'!privIndexesDict	^ indexesDict! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 11:17'!privNeighbor	^ neighbor! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 08:43'!privRows	^ rows! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 08:41'!privSrc	^ src! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 19:06'!privSrc: aFloatArray	src := aFloatArray.	dst := FloatArray new: src size.! !!SDiffuser methodsFor: 'accessing' stamp: 'EiichiroIto 10/17/2018 18:20'!result	^ dst! !!SDiffuser methodsFor: 'accessing' stamp: 'EiichiroIto 10/17/2018 18:11'!rows: anInteger1 cols: anInteger2	rows := anInteger1.	cols := anInteger2.	self setupIndexes.	self perform: setupSelector.! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 14:08'!setupIndexes	| dict left right index inner tleft tright bleft bright top bottom |	dict := Dictionary new.	tleft := 1.	tright := rows.	top := (1 to: rows) asArray.	left := OrderedCollection new.	inner := OrderedCollection new.	right := OrderedCollection new.	index := rows.	left add: 1.	right add: rows.	cols - 2		timesRepeat: [ left add: index + 1.			inner addAll: (index + 2 to: index + rows - 1).			right add: index + rows.			index := index + rows ].	left add: index + 1.	right add: index + rows.	bleft := index + 1.	bottom := (index + 1 to: index + rows) asArray.	bright := index + rows.	dict at: #inner put: inner asArray.	dict at: #top put: bottom , top , (top collect: [ :each | each + rows ]).	dict at: #bottom put: (bottom collect: [ :each | each - rows ]) , bottom , top.	dict at: #left put: (right , left , (left collect: [ :each | each + 1 ])) asArray.	dict at: #right put: ((right collect: [ :each | each - 1 ]) , right , left) asArray.	dict		at: #topLeft		put:			{bright.			bleft.			(bleft + 1).			tright.			tleft.			(tleft + 1).			tright + rows.			rows + 1.			(rows + 2).}.	dict		at: #topRight		put:			{(bright - 1).			bright.			bleft.			(tright - 1).			tright.			tleft.			(tright + rows - 1).			(tright + rows).			(tleft + rows).}.	dict		at: #bottomLeft		put:			{(bright - rows).			(bleft - rows).			(bleft - rows + 1).			bright.			bleft.			(bleft + 1).			tright.			tleft.			(tleft + 1).}.	dict		at: #bottomRight		put:			{(bright - rows - 1).			(bright - rows).			(bleft - rows).			(bright - 1).			bright.			bleft.			(tright - 1).			tright.			tleft.}.	indexesDict := dict.! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 17:55'!setupNeighbor4	| list |	list := OrderedCollection new.	list add: 1.	list add: -1.	list add: rows negated.	list add: rows.	neighbor := list asArray.	cornerIndexes := #(2 4 6 8).! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 17:55'!setupNeighbor8	| list |	list := OrderedCollection new.	list add: 1.	list add: -1.	list add: rows negated - 1.	list add: rows negated.	list add: rows negated + 1.	list add: rows - 1.	list add: rows.	list add: rows + 1.	neighbor := list asArray.	cornerIndexes := #(1 2 3 4 6 7 8 9).! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 18:09'!setupSelector	^ setupSelector! !!SDiffuser methodsFor: 'private' stamp: 'EiichiroIto 10/17/2018 18:09'!setupSelector: aSymbol	setupSelector := aSymbol.! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/18/2019 10:32'!allocateExtended: anInteger	(extented notNil and: [anInteger <= extented size])		ifTrue: [ ^ self ].	extented := FloatArray new: anInteger.! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 21:45'!clearExtended	extented atAllPut: 0.! !!SDiffuser2 methodsFor: 'accessing' stamp: 'EiichiroIto 3/18/2019 10:17'!diffuse: anArray order: anInteger1 percent: aNumber neighborSize: anInteger2	self setupDiffuseOrder: anInteger1 neighborSize: anInteger2.	self diffuse: anArray percent: aNumber.	self restoreExtended: anArray.! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/18/2019 11:12'!diffuse: anArray percent: aNumber	| src dst data use distributes n |	n := neighbor copyFrom: 1 to: neighborSize.	0 to: order - 1 do: [ :y | 		src := self indexOfNormalX: 0 y: y.		dst := self indexOfExtendedX: 0 y: y.		order			timesRepeat: [ data := anArray at: src.				use := data / 100.0 * aNumber.				distributes := use / neighborSize.				extented at: dst incrementBy: data - use.				n do: [ :each | extented at: each + dst incrementBy: distributes ].				src := src + 1.				dst := dst + 1 ] ]! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/16/2019 19:56'!indexOfExtendedX: x y: y	^ x + 2 + ((y + 1) * (order + 2))! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/16/2019 19:56'!indexOfNormalX: x y: y	^ x + 1 + (y * order)! !!SDiffuser2 methodsFor: 'initialization' stamp: 'EiichiroIto 3/18/2019 10:32'!initialize	order := 0.	neighborSize := 0.! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/18/2019 10:18'!nsum: anArray	| src dst n sum |	n := neighbor copyFrom: 1 to: neighborSize.	0 to: order - 1 do: [ :y | 		src := self indexOfExtendedX: 0 y: y.		dst := self indexOfNormalX: 0 y: y.		order			timesRepeat: [ sum := n sum: [ :each | extented at: src + each ].				anArray at: dst put: sum.				src := src + 1.				dst := dst + 1 ] ]! !!SDiffuser2 methodsFor: 'accessing' stamp: 'EiichiroIto 3/18/2019 10:20'!nsum: anArray1 dst: anArray2 order: anInteger1 neighborSize: anInteger2	self setupNSumSrc: anArray1 order: anInteger1 neighborSize: anInteger2.	self nsum: anArray2.! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 18:38'!privExtended	^ extented! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 18:38'!privExtended: anArray	extented := anArray! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 18:39'!privNeighbor	^ neighbor! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 18:39'!privNeighbor: anArray	neighbor := anArray! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 18:39'!privNeighborSize	^ neighborSize! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 18:40'!privNeighborSize: anInteger	neighborSize := anInteger! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 18:40'!privOrder	^ order! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 18:40'!privOrder: anInteger	order := anInteger! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/18/2019 11:13'!restoreExtended: anArray	| src dst |	0 to: order - 1 do: [ :y | 		src := self indexOfExtendedX: 0 y: y.		dst := self indexOfNormalX: 0 y: y.		order			timesRepeat: [ anArray at: dst put: (extented at: src).				src := src + 1.				dst := dst + 1 ] ].	src := self indexOfExtendedX: 0 y: -1.	dst := self indexOfNormalX: 0 y: order - 1.	order		timesRepeat: [ anArray at: dst incrementBy: (extented at: src).			src := src + 1.			dst := dst + 1 ].	src := self indexOfExtendedX: 0 y: order.	dst := self indexOfNormalX: 0 y: 0.	order		timesRepeat: [ anArray at: dst incrementBy: (extented at: src).			src := src + 1.			dst := dst + 1 ].	src := self indexOfExtendedX: -1 y: 0.	dst := self indexOfNormalX: order - 1 y: 0.	order		timesRepeat: [ anArray at: dst incrementBy: (extented at: src).			src := src + order + 2.			dst := dst + order ].	src := self indexOfExtendedX: order y: 0.	dst := self indexOfNormalX: 0 y: 0.	order		timesRepeat: [ anArray at: dst incrementBy: (extented at: src).			src := src + order + 2.			dst := dst + order ].	src := self indexOfExtendedX: order y: order.	dst := self indexOfNormalX: 0 y: 0.	anArray at: dst incrementBy: (extented at: src).	src := self indexOfExtendedX: -1 y: -1.	dst := self indexOfNormalX: order - 1 y: order - 1.	anArray at: dst incrementBy: (extented at: src).	src := self indexOfExtendedX: -1 y: order.	dst := self indexOfNormalX: order - 1 y: 0.	anArray at: dst incrementBy: (extented at: src).	src := self indexOfExtendedX: order y: -1.	dst := self indexOfNormalX: 0 y: order - 1.	anArray at: dst incrementBy: (extented at: src)! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 19:29'!setupBorder	| src dst |	src := self indexOfExtendedX: 0 y: 0.	dst := self indexOfExtendedX: 0 y: order.	order		timesRepeat: [ extented at: dst put: (extented at: src).			src := src + 1.			dst := dst + 1 ].	src := self indexOfExtendedX: 0 y: order - 1.	dst := self indexOfExtendedX: 0 y: -1.	order		timesRepeat: [ extented at: dst put: (extented at: src).			src := src + 1.			dst := dst + 1 ].	src := self indexOfExtendedX: order - 1 y: 0.	dst := self indexOfExtendedX: -1 y: 0.	order		timesRepeat: [ extented at: dst put: (extented at: src).			src := src + order + 2.			dst := dst + order + 2 ].	src := self indexOfExtendedX: 0 y: 0.	dst := self indexOfExtendedX: order y: 0.	order		timesRepeat: [ extented at: dst put: (extented at: src).			src := src + order + 2.			dst := dst + order + 2 ].	src := self indexOfExtendedX: 0 y: 0.	dst := self indexOfExtendedX: order y: order.	extented at: dst put: (extented at: src).	src := self indexOfExtendedX: order - 1 y: order - 1.	dst := self indexOfExtendedX: -1 y: -1.	extented at: dst put: (extented at: src).	src := self indexOfExtendedX: order - 1 y: 0.	dst := self indexOfExtendedX: -1 y: order.	extented at: dst put: (extented at: src).	src := self indexOfExtendedX: 0 y: order - 1.	dst := self indexOfExtendedX: order y: -1.	extented at: dst put: (extented at: src)! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/18/2019 10:15'!setupDiffuseOrder: anInteger1 neighborSize: anInteger2	self allocateExtended: (anInteger1 + 2) * (anInteger1 + 2).	order := anInteger1.	self setupNeighbor.	self clearExtended.	neighborSize := anInteger2.! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 19:01'!setupExtended: anArray	| src dst |	src := ReadStream on: anArray.	dst := WriteStream on: extented.	order + 2 timesRepeat: [ dst nextPut: 0 ].	order		timesRepeat: [ dst nextPut: 0.			order timesRepeat: [ dst nextPut: src next ].			dst nextPut: 0 ].	order + 2 timesRepeat: [ dst nextPut: 0 ]! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/18/2019 10:19'!setupNSumSrc: anArray1 order: anInteger1 neighborSize: anInteger2	| sz |	sz := (anInteger1 + 2) * (anInteger1 + 2).	self allocateExtended: sz.	order := anInteger1.	self setupNeighbor.	self setupExtended: anArray1.	self setupBorder.	neighborSize := anInteger2.! !!SDiffuser2 methodsFor: 'private' stamp: 'EiichiroIto 3/17/2019 18:53'!setupNeighbor	neighbor := {1.	-1.	(order + 2).	(order + 2) negated.	(order + 1).	(order + 3).	(order + 1) negated.	(order + 3) negated}! !!SEntryPoints methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 09:40'!addEntryPoint: anInteger forBreedNo: bno	| list |	list := breeds at: bno ifAbsentPut: [ OrderedCollection new ].	list add: anInteger.! !!SEntryPoints methodsFor: 'accessing' stamp: 'EiichiroIto 8/9/2019 08:26'!breedNoList	^ breeds keys! !!SEntryPoints methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 14:54'!entryPointList	| stream list |	stream := WriteStream on: Array new.	breeds keys sort		do: [ :bno | 			list := self forBreedNo: bno.			list				do: [ :address | stream nextPut: (Array with: bno with: address) ] ].	^ stream contents! !!SEntryPoints methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 21:12'!forBreedNo: anInteger	^ breeds at: anInteger ifAbsent: [ #() ]! !!SEntryPoints methodsFor: 'initialization' stamp: 'EiichiroIto 3/13/2019 20:19'!initialize	breeds := Dictionary new.! !!SEntryPoints methodsFor: 'testing' stamp: 'EiichiroIto 3/14/2019 09:01'!isEmpty	^ breeds isEmpty! !!SEntryPoints methodsFor: 'printing' stamp: 'EiichiroIto 9/11/2019 10:49'!printOn: aStream	aStream nextPut: $(.	self breedNoList		do: [ :each | 			aStream				nextPutAll: each asString;				nextPutAll: '->('.			(self forBreedNo: each)				do: [ :list | aStream nextPutAll: list asString ]				separatedBy: [ aStream nextPut: Character space ].			aStream nextPut: $) ]		separatedBy: [ aStream nextPut: Character space ].	aStream nextPut: $)! !!SEntryPoints methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 20:22'!privBreeds	^ breeds! !!SProgram methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 09:32'!addCode: anArray	codes := codes, anArray.! !!SProgram methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 09:41'!addEntryPoint: anInteger eventNo: eno breedNo: bno	(self forEventNo: eno) addEntryPoint: anInteger forBreedNo: bno.! !!SProgram methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 14:40'!bytecode	^ codes		collect: [ :each | 			each isSymbol				ifTrue: [ SThread indexOfSymbol: each ]				ifFalse: [ each ] ]! !!SProgram methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 09:57'!codes	^ codes! !!SProgram methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 14:58'!entryPointList	| stream list |	stream := WriteStream on: Array new.	entryPoints keys sort		do: [ :eno | 			list := (self forEventNo: eno) entryPointList.			list do: [ :each | stream nextPut: ({eno} , each) ] ].	^ stream contents! !!SProgram methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 10:51'!eventNoList	^ entryPoints keys! !!SProgram methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 10:51'!forEventNo: anInteger	^ entryPoints at: anInteger ifAbsentPut: [ SEntryPoints new ]! !!SProgram methodsFor: 'initialization' stamp: 'EiichiroIto 9/11/2019 10:51'!initialize	entryPoints := Dictionary new.	codes := Array new.! !!SProgram methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 09:25'!nextAddress	^ codes size + 1! !!SProgram methodsFor: 'printing' stamp: 'EiichiroIto 9/12/2019 12:36'!printOn: aStream	aStream		nextPutAll: 'SProgram(';		nextPutAll: codes size asString;		nextPut: $)! !!SProgram methodsFor: 'private' stamp: 'EiichiroIto 9/11/2019 10:22'!privCodes: aCollection	codes := aCollection.! !!SProgram methodsFor: 'private' stamp: 'EiichiroIto 9/11/2019 10:52'!privEntryPoints	^ entryPoints! !!SProgramToBytecode methodsFor: 'private' stamp: 'EiichiroIto 9/10/2019 22:00'!addCode: anArray eventNo: eno breed: bno	| code |	code := anArray		collect: [ :each | 			each isSymbol				ifTrue: [ SThread indexOfSymbol: each ]				ifFalse: [ each ] ].	stream		nextPut:			{eno.			bno.			code asByteArray}! !!SProgramToBytecode methodsFor: 'private' stamp: 'EiichiroIto 9/10/2019 21:42'!convert: aProgram	aProgram eventNoList		do: [ :each | self convert: (aProgram forEventNo: each) eventNo: each ]! !!SProgramToBytecode methodsFor: 'private' stamp: 'EiichiroIto 9/10/2019 21:53'!convert: anEventCodes eventNo: anInteger	anEventCodes breedNoList		do: [ :each | 			(anEventCodes forBreedNo: each)				do: [ :code | self addCode: code eventNo: anInteger breed: each ] ]! !!SProgramToBytecode methodsFor: 'accessing' stamp: 'EiichiroIto 9/10/2019 21:45'!fromProgram: aProgram	stream := WriteStream on: Array new.	self convert: aProgram.	^ stream contents! !!SRecorder methodsFor: 'accessing' stamp: 'EiichiroIto 10/9/2018 19:26'!close	writer ifNil: [ ^ self ].	writer close.	writer := nil.! !!SRecorder methodsFor: 'private' stamp: 'EiichiroIto 9/13/2019 16:26'!defaultFrameDelay	^ 10! !!SRecorder methodsFor: 'accessing' stamp: 'EiichiroIto 10/9/2018 20:06'!extent	^ extent! !!SRecorder methodsFor: 'accessing' stamp: 'EiichiroIto 10/9/2018 20:06'!extent: aPoint	extent := aPoint.! !!SRecorder methodsFor: 'initialization' stamp: 'EiichiroIto 10/9/2018 19:40'!initialize	super initialize.	rate := 1.	count := 0.! !!SRecorder methodsFor: 'testing' stamp: 'EiichiroIto 10/9/2018 19:25'!isOpen	^ writer notNil! !!SRecorder methodsFor: 'private' stamp: 'EiichiroIto 9/13/2019 16:26'!makeForm	| form x0 x y colors index tc frame |	self modelChanged		ifTrue: [ self updateCache ].	form := ColorForm extent: extent depth: 32.	frame := AnimatedImageFrame new		delay: self defaultFrameDelay;		form: form.	colors := microworld colors.	x0 := offset x.	y := offset y + (cell y * (modelExtent y - 1)).	index := 1.	modelExtent y		timesRepeat: [ x := x0.			modelExtent x				timesRepeat: [ tc := SColorList colorAt: (colors at: index).					form fill: (x @ y extent: cell) fillColor: tc.					index := index + 1.					x := x + cell x ].			y := y - cell y ].	^ frame! !!SRecorder methodsFor: 'private' stamp: 'EiichiroIto 10/9/2018 20:04'!modelChanged	^ modelExtent ~= microworld extent! !!SRecorder methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2019 16:28'!openFileNamed: aString	self close.	writer := GIFReadWriter on: aString asFileReference binaryWriteStream.	writer ifNil: [ ^ self ].	count := 0.! !!SRecorder methodsFor: 'private' stamp: 'EiichiroIto 10/9/2018 20:06'!privCell	^ cell! !!SRecorder methodsFor: 'private' stamp: 'EiichiroIto 10/9/2018 20:06'!privOffset	^ offset! !!SRecorder methodsFor: 'accessing' stamp: 'EiichiroIto 10/9/2018 20:45'!rate: anInteger	rate := anInteger.	count := 0.! !!SRecorder methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 08:01'!sworld: aMicroWorld	microworld := aMicroWorld.! !!SRecorder methodsFor: 'private' stamp: 'EiichiroIto 10/9/2018 20:05'!updateCache	modelExtent := microworld extent.	cell := self extent // modelExtent.	offset := (self extent - (modelExtent * cell)) // 2.! !!SRecorder methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2019 16:24'!writeForced: aBoolean	self isOpen		ifFalse: [ ^ self ].	count := count + 1.	(aBoolean or: [ count >= rate ])		ifFalse: [ ^ self ].	writer nextPutFrame: self makeForm.	count := 0.! !!SMicroWorld class methodsFor: 'samples' stamp: 'EiichiroIto 8/8/2019 08:01'!sample1	"SMicroWorld sample1."	| world d |	world := SMicroWorld new.	d := SDisplay sworld: world.	world create: 10000 turtles: 2.	"world turtlesDo: [ :ts :w :i | ts penDownAt: i put: true ].	world turtlesDo: [ :ts :w :i | ts forward: 30 world: w at: i ]."	d openInWorld.	^ d.! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 11:36'!addBreed: aBreed	| bno |	bno := aBreed breedNo.	breeds size < bno		ifTrue: [ breeds := breeds forceTo: bno paddingWith: nil ].	(breeds at: bno) ifNotNil: [ self error ].	breeds at: bno put: aBreed! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 17:39'!addVariable: aString var: vno breed: bno	"do nothing"! !!SMicroWorld methodsFor: 'command' stamp: 'EiichiroIto 3/13/2019 15:09'!aimHighPatchVar: vid breed: bid id: id	| x y heading |	x := (breeds at: bid) xAt: id.	y := (breeds at: bid) yAt: id.	heading := (breeds at: bid) headingAt: id.	^ self patches aimHighVarNo: vid atPoint: x @ y direction: heading! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 12:10'!backupBreeds: aCollection	"do nothing"! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 18:21'!breedOf: bid	^ breeds at: bid! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/21/2019 15:49'!clearBreed: bno	(self breedOf: bno) clear.! !!SMicroWorld methodsFor: 'processing' stamp: 'EiichiroIto 10/9/2018 16:43'!clearRaisedEvents	raisedEvents := Set new.! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/3/2019 21:58'!clearTicks	self observer clearTicks.! !!SMicroWorld methodsFor: 'command' stamp: 'EiichiroIto 9/21/2019 12:13'!clearTurtles	self turtleBreedsDo: [ :each | each clear ].! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/23/2019 21:57'!colors	| colors x y c index |	colors := self patches colors copy.	self		turtlesDo: [ :ts :id | 			x := ts xAt: id.			y := ts yAt: id.			c := ts colorAt: id.			index := self patches indexAtPoint: x @ y.			colors at: index put: c ].	^ colors! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2019 22:45'!countAliveOf: bno	^ (self breedOf: bno) countAlive! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 3/18/2019 14:42'!create: bid turtles: anInteger	bid < SBreedId defaultUserNo		ifTrue: [ self error: 'breedId must be more than 2' ].	^ (breeds at: bid) create: anInteger! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/21/2019 15:52'!createPatch: anInteger	self clearTurtles.	self patches create: anInteger.! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/14/2019 20:44'!delta: bno at: index	^ (breeds at: bno) deltaAt: index! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 10/6/2018 17:51'!extent	^ self patches extent! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 8/27/2019 20:11'!flag: anInteger breed: bid at: id	^ (breeds at: bid) flag: anInteger at: id! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 8/27/2019 20:11'!flag: anInteger breed: bid at: id put: aNumber	(breeds at: bid) flag: anInteger at: id put: aNumber! !!SMicroWorld methodsFor: 'command' stamp: 'EiichiroIto 3/14/2019 20:42'!forward: aNumber breed: bid id: anInteger	| c x y delta dx dy penDown rest h d ps ts |	ps := breeds at: SBreedId patchBreedNo.	ts := breeds at: bid.	penDown := ts penDownAt: anInteger.	c := ts colorAt: anInteger.	x := ts xAt: anInteger.	y := ts yAt: anInteger.	h := ts headingAt: anInteger.	delta := Point r: 1.0 degrees: h.	dx := delta x.	dy := delta y.	aNumber truncated		timesRepeat: [ penDown				ifTrue: [ ps colorAtPoint: x @ y put: c ].			x := x + dx.			y := y + dy.			x := ps normalize: x.			y := ps normalize: y ].	penDown		ifTrue: [ ps colorAtPoint: x @ y put: c ].	rest := aNumber - aNumber truncated.	(rest closeTo: 0.0)		ifFalse: [ d := Point r: rest degrees: h.			x := x + d x.			y := y + d y.			x := ps normalize: x.			y := ps normalize: y ].	ts xAt: anInteger put: x.	ts yAt: anInteger put: y! !!SMicroWorld methodsFor: 'command' stamp: 'EiichiroIto 3/18/2019 16:16'!hatch: bid id: anInteger	| list |	list := self create: bid turtles: 1.	list do: [ :each | (breeds at: bid) copyTurtleFrom: anInteger to: each ].! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/3/2019 22:03'!incrementTicks	self observer incrementTicks.! !!SMicroWorld methodsFor: 'initialization' stamp: 'EiichiroIto 11/30/2019 17:43'!initialize	super initialize.	self reset! !!SMicroWorld methodsFor: 'command' stamp: 'EiichiroIto 3/13/2019 16:07'!kill: bid index: anInteger	(breeds at: bid) killAt: anInteger.! !!SMicroWorld methodsFor: 'processing' stamp: 'EiichiroIto 8/27/2019 16:47'!livingBreed: bno do: aBlock	(breeds at: bno) livingOnesDo: aBlock.! !!SMicroWorld methodsFor: 'processing' stamp: 'EiichiroIto 8/8/2019 17:50'!maxBreedNo	^ breeds size! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 11:56'!newBreed	| breed |	breed := self observer newTurtle.	self addBreed: breed.	^ breed! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 8/1/2019 13:43'!observer	^ breeds at: SBreedId observerBreedNo! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 3/16/2019 19:16'!patchIndexAtX: x y: y	^ self patches indexAtX: x y: y! !!SMicroWorld methodsFor: 'processing' stamp: 'EiichiroIto 3/13/2019 15:47'!patches	^ breeds at: SBreedId patchBreedNo! !!SMicroWorld methodsFor: 'printing' stamp: 'EiichiroIto 9/14/2018 09:15'!printOn: aStream	aStream		nextPutAll: 'MicroWorld(';		print: self identityHash;		nextPut: $).! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 10/6/2018 22:44'!privBreeds	^ breeds! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 10/9/2018 16:42'!privRaisedEvents	^ raisedEvents! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 10/9/2018 16:42'!privRaisedEvents: aCollection	raisedEvents := aCollection! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 22:00'!processClass	^ SProcess! !!SMicroWorld methodsFor: 'processing' stamp: 'EiichiroIto 10/9/2018 16:41'!raiseEvent: anInteger	raisedEvents add: anInteger.! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 3/14/2019 11:20'!raisedEvents	^ raisedEvents! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 11/30/2019 17:43'!reset	raisedEvents := Set new.	breeds := Array new! !!SMicroWorld methodsFor: 'command' stamp: 'EiichiroIto 8/8/2019 18:35'!scaleVar: v color: c breed: bid from: f to: t id: id	bid = SBreedId observerBreedNo		ifTrue: [ self patches				scaleVarNo: v				color: c				from: f				to: t ]		ifFalse: [ (breeds at: bid)				scaleVarNo: v				color: c				from: f				to: t				index: id ]! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 16:36'!setDefaultTurtle: bno at: aPoint	(self breedOf: bno) defaultPosition: aPoint.! !!SMicroWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2019 22:48'!sizeOf: bno	^ (self breedOf: bno) size! !!SMicroWorld methodsFor: 'command' stamp: 'EiichiroIto 8/27/2019 16:49'!turtle: bno x: x y: y exceptBreed: myBno index: myIndex	| list |	list := (self breedOf: bno) turtlesAtPoint: x @ y.	bno = myBno		ifTrue: [ list remove: myIndex ifAbsent: [  ] ].	^ list isEmpty		ifTrue: [ 0 ]		ifFalse: [ list anyOne ].! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 18:21'!turtleBreedsDo: aBlock	SBreedId defaultUserNo to: breeds size do: [ :each | 		| turtle |		turtle := self breedOf: each.		turtle ifNotNil: [ aBlock value: turtle ] ]! !!SMicroWorld methodsFor: 'command' stamp: 'EiichiroIto 10/13/2018 18:46'!turtleVarNames	| list |	list := Set new.	self turtleBreedsDo: [ :each | list addAll: each userDefinedVarNames ].	^ list asSortedCollection asArray.! !!SMicroWorld methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 21:18'!turtlesDo: aBlock	self		turtleBreedsDo: [ :ts | ts livingOnesDo: [ :index | aBlock value: ts value: index ] ].! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 11/29/2019 20:23'!var: anInteger breed: bid at: id	^ bid = SBreedId observerBreedNo		ifTrue: [ self observer var: anInteger at: id sworld: self ]		ifFalse: [ (breeds at: bid) var: anInteger at: id ]! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 11/29/2019 20:26'!var: anInteger breed: bid at: id put: aNumber	bid = SBreedId observerBreedNo		ifTrue: [ self observer				var: anInteger				at: id				put: aNumber				sworld: self ]		ifFalse: [ (breeds at: bid) var: anInteger at: id put: aNumber ]! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 11/29/2019 20:27'!var: anInteger breed: bid putAll: anObject	bid = SBreedId observerBreedNo		ifTrue: [ self error: 'cannot set variables to observer' ]		ifFalse: [ (breeds at: bid) var: anInteger putAll: anObject ]! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/15/2019 18:26'!x: breed at: id	^ (breeds at: breed) xAt: id! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/15/2019 18:33'!x: bid at: anInteger put: aNumber	| c x y dx penDown ps ts |	ps := breeds at: SBreedId patchBreedNo.	ts := breeds at: bid.	penDown := ts penDownAt: anInteger.	c := ts colorAt: anInteger.	x := ts xAt: anInteger.	y := ts yAt: anInteger.	dx := (aNumber - x) sign.	(aNumber - x) truncated abs		timesRepeat: [ penDown				ifTrue: [ ps colorAtPoint: x @ y put: c ].			x := x + dx.			x := ps normalize: x ].	penDown		ifTrue: [ ps colorAtPoint: x @ y put: c ].	(x closeTo: aNumber)		ifFalse: [ x := ps normalize: aNumber ].	ts xAt: anInteger put: x! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/15/2019 18:27'!y: breed at: id	^ (breeds at: breed) yAt: id! !!SMicroWorld methodsFor: 'accessing variable' stamp: 'EiichiroIto 3/15/2019 18:33'!y: bid at: anInteger put: aNumber	| c x y dy penDown ps ts |	ps := breeds at: SBreedId patchBreedNo.	ts := breeds at: bid.	penDown := ts penDownAt: anInteger.	c := ts colorAt: anInteger.	x := ts xAt: anInteger.	y := ts yAt: anInteger.	dy := (aNumber - y) sign.	(aNumber - y) truncated abs		timesRepeat: [ penDown				ifTrue: [ ps colorAtPoint: x @ y put: c ].			y := y + dy.			y := ps normalize: y ].	penDown		ifTrue: [ ps colorAtPoint: x @ y put: c ].	(y closeTo: aNumber)		ifFalse: [ y := ps normalize: aNumber ].	ts yAt: anInteger put: y! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 12/5/2019 20:24'!addBreed: aBreed	| bno |	bno := aBreed breedNo.	plugin setupBreed: bno.	bno = SBreedId patchBreedNo		ifTrue: [ plugin createPatch: aBreed order ].	bno = SBreedId turtleBreedNo		ifTrue: [ plugin create: bno turtles: aBreed size ].	self addVariablesFor: aBreed.	self setAllVariables: aBreed! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/21/2019 12:48'!addVariable: aString var: vno breed: bno	plugin addVariable: vno breed: bno! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 9/21/2019 12:49'!addVariablesFor: aBreed	| bno |	bno := aBreed breedNo.	aBreed userDefinedVarNoAndNames		do: [ :each | plugin addVariable: each first breed: bno ].! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 12:10'!backupBreeds: aCollection	aCollection do: [ :each | self getAllVariables: each ].! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/21/2019 15:51'!clearBreed: anInteger	plugin clearBreed: anInteger.! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/16/2019 20:20'!colors	| num ext |	num := self sizeOf: SBreedId patchBreedNo.	ext := plugin getScreen.	^ [ ext copyFrom: 1 to: num ]		ensure: [ ext release ]! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!countAliveOf: bno	^ (plugin		getFloat: SObserverVarDef countAliveVarNo		breed: SBreedId observerBreedNo		id: bno) truncated! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/24/2019 12:45'!create: bno turtles: anInteger	plugin create: bno turtles: anInteger! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 16:51'!createPatch: anInteger	plugin createPatch: anInteger.! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/14/2019 18:18'!extent	^ self getCols @ self getRows! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 9/29/2019 15:43'!getAllVariable: vno breed: bno	| type |	bno = SBreedId observerBreedNo ifTrue: [ ^ nil ].	type := plugin getType: vno breed: bno.	"type = SteloLibCall word		ifTrue: [ ^ self getWordAll: vno breed: bno ]."	type = SteloLibCall float		ifTrue: [ ^ self getFloatAll: vno breed: bno ].	type = SteloLibCall byte		ifTrue: [ ^ self getByteAll: vno breed: bno ].	^ nil! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 9/29/2019 17:10'!getAllVariables: aBreed	| bno |	bno := aBreed breedNo.	aBreed realVarNames		do: [ :each | 			| vno list |			vno := aBreed varNoFor: each.			list := self getAllVariable: vno breed: bno.			list ifNotNil: [ aBreed varArrayNamed: each put: list ] ]! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 9/16/2019 20:18'!getByteAll: vno breed: bno	| size ptr |	size := self sizeOf: bno.	ptr := plugin getByteAll: vno breed: bno.	ptr isNull		ifTrue: [ ^ nil ].	^ [ ptr copyFrom: 1 to: size ]		ensure: [ ptr autoRelease ]! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 22:09'!getCols	^ (plugin		getFloat: SObserverVarDef widthVarNo		breed: SBreedId observerBreedNo		id: 1) truncated! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 9/16/2019 20:18'!getFloatAll: vno breed: bno	| size ptr ext arr |	size := self sizeOf: bno.	ptr := plugin getFloatAll: vno breed: bno.	ptr isNull		ifTrue: [ ^ nil ].	ext := FFIExternalArray		fromHandle: ptr getHandle		type: ExternalType float.	[ arr := FloatArray new: size withAll: 0.0.	1 to: size do: [ :each | arr at: each put: (ext at: each) ] ]		ensure: [ ptr autoRelease ].	^ arr! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 22:09'!getRows	^ (plugin		getFloat: SObserverVarDef heightVarNo		breed: SBreedId observerBreedNo		id: 1) truncated! !!SPluginWorld methodsFor: 'initialization' stamp: 'EiichiroIto 9/21/2019 11:47'!initialize	super initialize.	plugin := SteloLibCall new.! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 15:51'!patchIndexAtX: x y: y	^ plugin patchIndexAtX: x y: y! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:36'!plugin	^ plugin! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 22:14'!processClass	^ SPluginProcess! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 11/30/2019 17:43'!reset	plugin reset! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 9/29/2019 15:42'!setAllVariable: vno breed: bno list: list	| type |	list ifNil: [ ^ self ].	type := plugin getType: vno breed: bno.	"type = SteloLibCall word		ifTrue: [ ^ self setWordAll: vno breed: bno from: list ]."	type = SteloLibCall float		ifTrue: [ ^ self setFloatAll: vno breed: bno from: list ].	type = SteloLibCall byte		ifTrue: [ ^ self setByteAll: vno breed: bno from: list ]! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 9/29/2019 17:10'!setAllVariables: aBreed	| bno |	bno := aBreed breedNo.	aBreed realVarNames		do: [ :each | 			| vno list |			vno := aBreed varNoFor: each.			list := aBreed varArrayNamed: each.			self setAllVariable: vno breed: bno list: list ]! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 8/24/2019 20:20'!setByteAll: vno breed: bno from: aByteArray	| ext |	ext := FFIExternalArray externalNewType: 'byte' size: aByteArray size.	aByteArray withIndexDo: [ :each :index | ext at: index put: each ].	plugin setByteAll: vno breed: bno extArray: ext size: aByteArray size! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 16:35'!setDefaultTurtle: bno at: aPoint	plugin setDefaultTurtle: bno x: aPoint x y: aPoint y.! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 8/24/2019 20:20'!setFloatAll: vno breed: bno from: aFloatArray	| ext |	ext := FFIExternalArray externalNewType: 'float' size: aFloatArray size.	aFloatArray withIndexDo: [ :each :index | ext at: index put: each ].	plugin setFloatAll: vno breed: bno extArray: ext size: aFloatArray size.! !!SPluginWorld methodsFor: 'private' stamp: 'EiichiroIto 9/11/2019 15:05'!setProgram: aProgram	| bytecode ext |	bytecode := aProgram bytecode.	ext := FFIExternalArray externalNewType: 'byte' size: bytecode size.	bytecode withIndexDo: [ :each :index | ext at: index put: each ].	plugin setProgram: ext size: bytecode size.	aProgram entryPointList		do: [ :each | 			plugin				addEntryPoint: each third				eventNo: each first				breedNo: each second ]! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!sizeOf: bno	^ (plugin		getFloat: SObserverVarDef sizeVarNo		breed: SBreedId observerBreedNo		id: bno) truncated! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/29/2019 15:43'!var: vno breed: bno at: tno	| t |	t := plugin getType: vno breed: bno.	t = SteloLibCall float		ifTrue: [ ^ plugin getFloat: vno breed: bno id: tno ].	t = SteloLibCall byte		ifTrue: [ ^ plugin getByte: vno breed: bno id: tno ].	"t = SteloLibCall word		ifTrue: [ ^ plugin getWord: vno breed: bno id: tno ]."	t = SteloLibCall computedFloat		ifTrue: [ ^ plugin getFloat: vno breed: bno id: tno ].	t = SteloLibCall none		ifTrue: [ self error ]! !!SPluginWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/29/2019 15:43'!var: vno breed: bno at: tno put: value	| t |	t := plugin getType: vno breed: bno.	t = SteloLibCall float		ifTrue: [ ^ plugin				setFloat: vno				breed: bno				id: tno				value: value ].	t = SteloLibCall byte		ifTrue: [ ^ plugin				setByte: vno				breed: bno				id: tno				value: value ].	"t = SteloLibCall word		ifTrue: [ ^ plugin				setWord: vno				breed: bno				id: tno				value: value ]."	t = SteloLibCall computedFloat		ifTrue: [ self error ].	t = SteloLibCall none		ifTrue: [ self error ]! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 17:47'!addBreed: aBreed	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/11/2019 17:39'!addVariable: aString var: vno breed: bno	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 12:10'!backupBreeds: aCollection	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/21/2019 15:50'!clearBreed: anInteger	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 17:53'!colors	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2019 22:45'!countAliveOf: bno	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/24/2019 12:42'!create: bid turtles: anInteger	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 16:51'!createPatch: anInteger	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 17:54'!extent	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:04'!newProcess	^ self processClass sworld: self! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 15:51'!patchIndexAtX: x y: y	self subclassResponsibility.! !!SWorld methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 22:00'!processClass	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 11/30/2019 17:42'!reset	self subclassResponsibility! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 12/5/2019 22:22'!restoreBreeds: aCollection	self reset.	aCollection do: [ :each | self addBreed: each ]! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 16:35'!setDefaultTurtle: bno at: aPoint	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 9/13/2019 22:48'!sizeOf: bno	self subclassResponsibility.! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!ticks	^ self var: SObserverVarDef ticksVarNo breed: SBreedId observerBreedNo at: 1! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/24/2019 18:17'!var: vno breed: bno at: tno	self subclassResponsibility! !!SWorld methodsFor: 'accessing' stamp: 'EiichiroIto 8/24/2019 18:17'!var: vno breed: bno at: tno put: value	self subclassResponsibility! !!SteloLibCall class methodsFor: 'constants' stamp: 'EiichiroIto 8/10/2019 22:47'!byte	^ 2! !!SteloLibCall class methodsFor: 'constants' stamp: 'EiichiroIto 8/10/2019 22:47'!computedFloat	^ 4! !!SteloLibCall class methodsFor: 'resources' stamp: 'EiichiroIto 8/8/2019 18:50'!ffiLibrary	^ SteloLibrary! !!SteloLibCall class methodsFor: 'constants' stamp: 'EiichiroIto 8/10/2019 22:47'!float	^ 1! !!SteloLibCall class methodsFor: 'constants' stamp: 'EiichiroIto 8/10/2019 22:47'!none	^ 0! !!SteloLibCall class methodsFor: 'constants' stamp: 'EiichiroIto 8/28/2019 12:42'!word	^ 3! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 9/11/2019 15:04'!addEntryPoint: address eventNo: eno breedNo: bno	^ self ffiCall: #(bool addEntryPoint(int eno, int bno, int address))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 9/21/2019 12:48'!addVariable: vno breed: bno	^ self ffiCall: #(bool addVariable(int bno, int vno))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 9/21/2019 11:49'!clearBreed: anInteger	^ self ffiCall: #(void clearBreed(int anInteger))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/21/2019 18:38'!clearErrorMessage	self ffiCall: #(void clearError()).! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/24/2019 12:45'!create: bno turtles: size	self ffiCall: #(void createTurtles(int bno, int size)).	self primitiveFailed.! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/27/2019 16:51'!createPatch: anInteger	self ffiCall: #(void createPatch(int anInteger)).	self primitiveFailed! !!SteloLibCall methodsFor: 'resources' stamp: 'EiichiroIto 8/8/2019 18:50'!ffiLibrary	^ self class ffiLibrary! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/11/2019 09:19'!forward: step breed: bno id: index	self ffiCall: #(void forward(int bno, int index, float step))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/10/2019 22:41'!getByte: vno breed: bno id: tno	^ self ffiCall: #(byte getByte(int bno, int vno, int tno))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/20/2019 20:21'!getByteAll: vno breed: bno	^ self ffiCall: #(byte *getByteAll(int bno, int vno))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/20/2019 20:32'!getErrorMessage	^ self ffiCall: #(String getError())! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/10/2019 22:41'!getFloat: vno breed: bno id: tno	^ self ffiCall: #(float getFloat(int bno, int vno, int tno))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/20/2019 20:51'!getFloatAll: vno breed: bno	^ self ffiCall: #(ExternalAddress getFloatAll(int bno, int vno))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/8/2019 19:56'!getScreen	^ self ffiCall: #(byte *getScreen())! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/10/2019 22:45'!getType: vno breed: bno	^ self ffiCall: #(int getType(int bno, int vno))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/8/2019 22:42'!isRunning	^ self ffiCall: #(bool isRunning())! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/8/2019 20:03'!loop	self ffiCall: #(void loop()).	self primitiveFailed.! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/8/2019 20:02'!parseProgram: aString	self ffiCall: #(void parseProgram(String aString)).	self primitiveFailed.! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/27/2019 15:54'!patchIndexAtX: x y: y	^ self ffiCall: #(int patchIndex(float x, float y))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/10/2019 18:00'!reset	self ffiCall: #(void reset()).	self primitiveFailed.! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/10/2019 22:42'!setByte: vno breed: bno id: tno value: value	^ self ffiCall: #(void setByte(int bno, int vno, int tno, byte value))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/24/2019 20:19'!setByteAll: vno breed: bno extArray: list size: size	^ self ffiCall: #(void setByteAll(int bno, int vno, FFIExternalArray list, int size))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/27/2019 16:22'!setDefaultTurtle: bno x: x y: y	self ffiCall: #(void setDefaultTurtleXY(int bno, float x, float y)).! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/10/2019 22:43'!setFloat: vno breed: bno id: tno value: value	^ self ffiCall: #(void setFloat(int bno, int vno, int tno, float value))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/24/2019 20:20'!setFloatAll: vno breed: bno extArray: list size: size	^ self ffiCall: #(void setFloatAll(int bno, int vno, FFIExternalArray list, int size))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 9/11/2019 14:35'!setProgram: list size: size	self ffiCall: #(void setProgram(FFIExternalArray list, int size))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/28/2019 15:13'!setWord: vno breed: bno id: tno value: value	^ self ffiCall: #(void setWord(int bno, int vno, int tno, uint32 value))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/28/2019 12:39'!setWordAll: vno breed: bno extArray: list size: size	^ self ffiCall: #(void setWordAll(int bno, int vno, FFIExternalArray list, int size))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/10/2019 18:02'!setupBreed: anInteger	self ffiCall: #(void setupBreed(int anInteger))! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 9/9/2019 20:16'!single	self ffiCall: #(void single()).	self primitiveFailed.! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/8/2019 20:03'!startup	self ffiCall: #(void startup()).	self primitiveFailed.! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/8/2019 20:03'!step	self ffiCall: #(void step()).	self primitiveFailed.! !!SteloLibCall methodsFor: 'stelo funcs' stamp: 'EiichiroIto 8/8/2019 22:46'!stop	self ffiCall: #(void stop()).	self primitiveFailed.! !!SpSteloViewer class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 13:07'!buttons	^ #(#(buttonBasic basic) #(buttonControl control) #(buttonColor color) #(buttonSensing sensing) #(buttonPatch patch) #(buttonOperators operators) #(buttonPen pen) #(buttonVariables variables))! !!SpSteloViewer methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 13:07'!connectPresenters	buttonBasic action: [ self currentCategory: #basic ].	buttonControl action: [ self currentCategory: #control ].	buttonColor action: [ self currentCategory: #color ].	buttonPatch action: [ self currentCategory: #patch ].	buttonOperators action: [ self currentCategory: #operators ].	buttonPen action: [ self currentCategory: #pen ].	buttonVariables action: [ self currentCategory: #variables ].	buttonSensing action: [ self currentCategory: #sensing ]! !!SpSteloViewer methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 13:06'!setupButtons	buttonBasic := self newButton		label: 'Basic';		yourself.	buttonControl := self newButton		label: 'Control';		yourself.	buttonColor := self newButton		label: 'Color';		yourself.	buttonSensing := self newButton		label: 'Sensing';		yourself.	buttonPatch := self newButton		label: 'Patch';		yourself.	buttonOperators := self newButton		label: 'Operators';		yourself.	buttonPen := self newButton		label: 'Pen';		yourself.	buttonVariables := self newButton		label: 'Variables';		yourself! !!SBreedVarDef methodsFor: 'as yet unclassified' stamp: 'EiichiroIto 11/25/2019 12:52'!listNames	^ #(a b c)! !!SBreedVarDef methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 22:12'!setupReservedVarNames	self setupVarNames! !!SObserverVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 9/16/2019 17:17'!countAliveVarNo	^ 5! !!SObserverVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:52'!heightVarNo	^ 2! !!SObserverVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 22:19'!maxBreedNoVarNo	^ 3! !!SObserverVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 11/28/2019 22:20'!maxVarVarNo	^ 7! !!SObserverVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 9/16/2019 17:17'!sizeVarNo	^ 6! !!SObserverVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 9/3/2019 21:45'!ticksVarNo	^ 4! !!SObserverVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:53'!widthVarNo	^ 1! !!SObserverVarDef methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 22:04'!setupReservedVarNames	#(width height maxBreedNo ticks countAlive size maxVar)		do: [ :each | 			self				addComputedVariable: each				varNo: (self class perform: each , 'VarNo') ].	self setupVarNames! !!SPatchVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 19:26'!colorVarNo	^ 1! !!SPatchVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:55'!screenVarNo	^ 2! !!SPatchVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:56'!xVarNo	^ 3! !!SPatchVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:56'!yVarNo	^ 4! !!SPatchVarDef methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 22:08'!setupReservedVarNames	self		addReserved: 'color'		varNo: self class colorVarNo		className: #ByteArray.	self		addReserved: 'screen'		varNo: self class screenVarNo		className: #ByteArray.	self addReservedVariable: 'x' varNo: self class xVarNo.	self addReservedVariable: 'y' varNo: self class yVarNo.	self setupVarNames! !!STurtleVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 17:21'!aliveFlagNo	^ 0! !!STurtleVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 19:26'!colorVarNo	^ 1! !!STurtleVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 17:26'!flagVarNo	^ 2! !!STurtleVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 12:07'!headingVarNo	^ 5! !!STurtleVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 8/27/2019 17:21'!penDownFlagNo	^ 1! !!STurtleVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 12:06'!xVarNo	^ 3! !!STurtleVarDef class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 12:06'!yVarNo	^ 4! !!STurtleVarDef methodsFor: 'private' stamp: 'EiichiroIto 11/28/2019 22:08'!setupReservedVarNames	self		addReserved: 'color'		varNo: self class colorVarNo		className: #ByteArray.	self		addReserved: 'flag'		varNo: self class flagVarNo		className: #ByteArray.	self addReservedVariable: 'x' varNo: self class xVarNo.	self addReservedVariable: 'y' varNo: self class yVarNo.	self addReservedVariable: 'heading' varNo: self class headingVarNo.	self setupVarNames! !!SpSteloFrame class methodsFor: 'specs' stamp: 'EiichiroIto 11/24/2019 08:53'!defaultSpec	^ SpBoxLayout newVertical		add:			(SpBoxLayout newHorizontal				add: #logo withConstraints: [ :c | c width: 154 ];				add: #buttonSave withConstraints: [ :c | c expand: false ];				add: #menu;				yourself)			withConstraints: [ :c | c height: self toolbarHeight ];		add:			(SpBoxLayout newHorizontal				add: #viewerPane					withConstraints: [ :c | c width: self viewerPaneWidth ];				add: #scriptsPane;				add:					(SpBoxLayout newVertical						add: #titlePane withConstraints: [ :c | c height: self titleButtonHeight ];						add: #stageFrame;						add: #libraryPane							withConstraints: [ :c | c height: self libraryPaneHeight ];						yourself);				yourself);		yourself! !!SpSteloFrame methodsFor: 'initialization' stamp: 'EiichiroIto 11/29/2019 22:43'!connectPresenters	buttonSave action: [ application saveProjectNoDialog ].	libraryPane		observerAction: [ self observerSelected ];		patchesAction: [ self patchesSelected ];		turtlesAction: [ :bno | self turtlesSelected: bno ].	self		updateThumbnail! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 08:52'!defaultExtent	^ 1024 @ 768! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 13:21'!exportMenu	^ self newMenu		addItem: [ :item | 			item				name: 'Export S-EXP';				action: [ application exportSexpCode ] ];		yourself! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 13:13'!fileMenu	^ self newMenu		addItem: [ :item | 			item				name: 'New';				action: [ application newProject ] ];		addItem: [ :item | 			item				name: 'Open';				action: [ application openProject ] ];		addItem: [ :item | 			item				name: 'Save';				action: [ application saveProjectNoDialog ] ];		addItem: [ :item | 			item				name: 'Save As';				action: [ application saveProject ] ];		addItem: [ :item | 			item				name: 'Import';				subMenu: self importMenu ];		addItem: [ :item | 			item				name: 'Export';				subMenu: self exportMenu ];		addItem: [ :item | 			item				name: 'Project Notes';				action: [ application editNotes ] ];		addItem: [ :item | 			item				name: 'Close';				action: [ application close ] ];		addItem: [ :item | 			item				name: 'Quit';				action: [ application quit ] ];		yourself! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/30/2019 17:30'!helpMenu	^ self newMenu		addItem: [ :item | 			item				name: 'About ' , application appName;				action: [ owner window showAbout ] ];		addItem: [ :item | 			menuChangeWorld := item.			item				name: 'Change world';				action: [ application toggleSWorld ];				autoRefresh: true ];		yourself! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 13:20'!importMenu	^ self newMenu		addItem: [ :item | 			item				name: 'Import S-EXP';				action: [ application importSexpCode ] ];		yourself! !!SpSteloFrame methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 14:53'!initializePresenters	logo := self newImage.	buttonSave := self newButton.	menu := self newMenuBar.	viewerPane := self instantiate: SpSteloViewer.	scriptsPane := self instantiate: SpScratchEditor.	titlePane := self instantiate: SpSteloTitle.	stageFrame := self instantiate: SpSteloStage.	libraryPane := self instantiate: SpSteloLibrary.	self setupTopPane.	self setupTitlePane.	self focusOrder		add: scriptsPane! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/29/2019 22:43'!observerSelected	self currentTarget: application observerScript.	self updateThumbnail! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 14:57'!patchesSelected	self currentTarget: application patchesScript! !!SpSteloFrame methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 13:12'!setupTitlePane	titlePane		projectName: 'New Project';		clearTurtlesAction: [ application clearTurtles ];		clearPatchesAction: [ application clearPatches ];		startSetupAction: [ application startSetup ];		stopAllAction: [ application stopAll ];		stepLoopAction: [ application stepLoop ];		startLoopSlowAction: [ application startLoopSlow ];		startLoopAction: [ application startLoop ]! !!SpSteloFrame methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 13:13'!setupTopPane	logo image: (ScratchTheme formAt: #scratchLogo).	buttonSave		icon: (ScratchTheme formAt: #saveButton);		help: 'Save this project'.	menu		addItem: [ :item | 			item				name: 'File';				subMenu: self fileMenu ];		addItem: [ :item | 			item				name: 'Help';				subMenu: self helpMenu ].	menu applyTo: self! !!SpSteloFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 13:18'!sworld: aWorld	| display |	display := self display.	display		sworld: aWorld;		changed! !!SpSteloFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/30/2019 17:08'!sworldMode: aSymbol	menuChangeWorld		name:			(aSymbol = #SMicroWorld				ifTrue: [ 'Change to Pluginworld' ]				ifFalse: [ 'Change to Microworld' ])! !!SpSteloFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 16:25'!target	^ viewerPane target! !!SpSteloFrame methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 22:45'!target: anObject	super target: anObject.	self updateThumbnail! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/29/2019 22:41'!thumbnailExtent	^ 40 @ 40! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 15:03'!turtlesSelected: bno	self currentTarget: (application scriptOf: bno)! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 11/29/2019 22:43'!updateThumbnail	libraryPane thumbnail: (self stageShotSized: self thumbnailExtent)! !!SPluginProcess methodsFor: 'testing' stamp: 'EiichiroIto 8/8/2019 22:44'!isRunning	^ sworld plugin isRunning! !!SPluginProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:38'!loop	sworld plugin loop.! !!SPluginProcess methodsFor: 'accessing' stamp: 'EiichiroIto 9/10/2019 21:36'!program: aProgram	super program: aProgram.	sworld setProgram: program.! !!SPluginProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:38'!single	sworld plugin single.! !!SPluginProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:36'!startup	sworld plugin startup.! !!SPluginProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:38'!step	sworld plugin step.! !!SPluginProcess methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 22:38'!stop	sworld plugin stop.! !!SProcess class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/8/2018 18:02'!new	self shouldNotImplement! !!SProcess methodsFor: 'transitions' stamp: 'EiichiroIto 9/9/2019 15:50'!afterLoop	runningEvents isEmpty		ifTrue: [ self loop ]! !!SProcess methodsFor: 'transitions' stamp: 'EiichiroIto 9/9/2019 15:50'!afterSetup	runningEvents isEmpty		ifTrue: [ self stop ]! !!SProcess methodsFor: 'transitions' stamp: 'EiichiroIto 9/9/2019 15:50'!afterSingle	runningEvents isEmpty		ifTrue: [ self stop ]! !!SProcess methodsFor: 'transitions' stamp: 'EiichiroIto 9/9/2019 15:51'!afterStartup	runningEvents isEmpty		ifTrue: [ self setup ]! !!SProcess methodsFor: 'execution' stamp: 'EiichiroIto 3/14/2019 12:44'!doOneCycle	runningEvents		do: [ :eventNo | 			| eventCodes |			eventCodes := program forEventNo: eventNo.			eventCodes isEmpty				ifFalse: [ self						executeEventCodes: eventCodes						ifTerminatedDo: [ self stop.							^ false ] ] ].	^ false! !!SProcess methodsFor: 'execution' stamp: 'EiichiroIto 8/27/2019 16:47'!executeEventCodes: anEventCodes ifTerminatedDo: aBlock	1 to: sworld maxBreedNo do: [ :bno | 		| codes |		codes := anEventCodes forBreedNo: bno.		codes			do: [ :code | 				sworld					livingBreed: bno					do: [ :index | 						self							executeThread: code							breedNo: bno							index: index							ifTerminatedDo: aBlock ] ] ].! !!SProcess methodsFor: 'execution' stamp: 'EiichiroIto 9/11/2019 09:57'!executeThread: entryPoint breedNo: bno index: index ifTerminatedDo: aBlock	| thread |	thread := SThread sworld: sworld.	thread forBreedNo: bno index: index.	thread codes: program codes.	thread execute: entryPoint.	thread isTerminated		ifTrue: [ aBlock value ].! !!SProcess methodsFor: 'transitions' stamp: 'EiichiroIto 9/9/2018 20:31'!idle	"do nothing"! !!SProcess methodsFor: 'initialization' stamp: 'EiichiroIto 3/14/2019 08:43'!initialize	super initialize.	self stop.! !!SProcess methodsFor: 'testing' stamp: 'EiichiroIto 3/14/2019 12:12'!isRunning	^ transition ~= #idle! !!SProcess methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 17:29'!loop	transition := #afterLoop.	runningEvents := {EventId loopEventNo}.! !!SProcess methodsFor: 'private' stamp: 'EiichiroIto 3/14/2019 11:16'!privRunningEvents	^ runningEvents! !!SProcess methodsFor: 'private' stamp: 'EiichiroIto 3/14/2019 11:16'!privRunningEvents: aCollection	runningEvents := aCollection.! !!SProcess methodsFor: 'private' stamp: 'EiichiroIto 3/14/2019 12:14'!privTransition	^ transition! !!SProcess methodsFor: 'private' stamp: 'EiichiroIto 3/14/2019 12:14'!privTransition: aSymbol	transition := aSymbol.! !!SProcess methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 17:29'!setup	transition := #afterSetup.	runningEvents := {EventId setupEventNo}.! !!SProcess methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 17:29'!single	transition := #afterSingle.	runningEvents := {EventId singleEventNo}.! !!SProcess methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 17:29'!startup	transition := #afterStartup.	runningEvents := {EventId startupEventNo}.	sworld clearTicks.! !!SProcess methodsFor: 'accessing' stamp: 'EiichiroIto 9/9/2019 15:40'!step	self isRunning		ifFalse: [ ^ self ].	sworld		clearRaisedEvents;		incrementTicks.	[ self doOneCycle ] whileTrue.	self isRunning		ifFalse: [ ^ self ].	runningEvents := sworld raisedEvents copy.	self perform: transition.! !!SProcess methodsFor: 'accessing' stamp: 'EiichiroIto 3/14/2019 12:12'!stop	transition := #idle.	runningEvents := #().! !!SteloProcess class methodsFor: 'instance creation' stamp: 'EiichiroIto 8/8/2019 22:34'!sworld: aSWorld	^ self basicNew		initialize;		privSWorld: aSWorld;		yourself! !!SteloProcess methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 22:21'!privSWorld	^ sworld! !!SteloProcess methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 22:21'!privSWorld: anObject	sworld := anObject.! !!SpSteloLibrary class methodsFor: 'specs' stamp: 'EiichiroIto 11/24/2019 15:00'!defaultSpec	^ SpBoxLayout newHorizontal		add: #buttonObserver;		add: #buttonPatches;		add: #buttonTurtles;		yourself! !!SpSteloLibrary methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 14:59'!initializePresenters	buttonObserver := self newButton.	buttonPatches := self newButton.	buttonTurtles := self newButton.	buttonObserver label: 'Observer'.	buttonPatches		label: 'Patches';		icon: (ScratchTheme formAt: #clearGraphicsButtonPressed).	buttonTurtles		label: 'Turtles';		icon: (ScratchTheme formAt: #clearTurtlesButtonPressed).	self selectButton: 'Observer'.	self focusOrder		add: buttonObserver;		add: buttonPatches;		add: buttonTurtles! !!SpSteloLibrary methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 22:39'!observerAction: aBlock	buttonObserver		action: [ self selectButton: buttonObserver label asString.			aBlock cull: SBreedId observerBreedNo ]! !!SpSteloLibrary methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 22:39'!patchesAction: aBlock	buttonPatches		action: [ self selectButton: buttonPatches label asString.			aBlock cull: SBreedId patchBreedNo ]! !!SpSteloLibrary methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 14:50'!selectButton: aString	buttonObserver state: aString = buttonObserver label asString.	buttonPatches state: aString = buttonPatches label asString.	buttonTurtles state: aString = buttonTurtles label asString! !!SpSteloLibrary methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 22:38'!thumbnail: aForm	buttonObserver icon: aForm! !!SpSteloLibrary methodsFor: 'accessing' stamp: 'EiichiroIto 11/29/2019 22:28'!turtlesAction: aBlock	buttonTurtles		action: [ self selectButton: buttonTurtles label asString.			aBlock cull: SBreedId turtleBreedNo ]! !!SpSteloStage class methodsFor: 'specs' stamp: 'EiichiroIto 11/24/2019 09:02'!defaultSpec	^ SpBoxLayout newHorizontal		add: #display;		yourself! !!SpSteloStage methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:01'!display	^ display morph! !!SpSteloStage methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 09:00'!initializePresenters	display := self newMorph.	display morph: SDisplay new.	"self focusOrder		add: buttonZoomIn;		add: buttonZoomFit;		add: buttonZoomOut"! !!SpSteloTitle class methodsFor: 'private' stamp: 'EiichiroIto 11/19/2019 12:15'!buttonWidth	^ 28 + 5! !!SpSteloTitle class methodsFor: 'specs' stamp: 'EiichiroIto 11/24/2019 11:55'!defaultSpec	^ SpBoxLayout newHorizontal		add: #labelName;		add: #buttonClearTurtles			withConstraints: [ :c | c width: self buttonWidth ];		add: #buttonClearPatches			withConstraints: [ :c | c width: self buttonWidth ];		add: #buttonStartSetup			withConstraints: [ :c | c width: self buttonWidth ];		add: #buttonStopAll			withConstraints: [ :c | c width: self buttonWidth ];		add: #buttonStepLoop			withConstraints: [ :c | c width: self buttonWidth ];		add: #buttonStartLoopSlow			withConstraints: [ :c | c width: self buttonWidth ];		add: #buttonStartLoop			withConstraints: [ :c | c width: self buttonWidth ];		yourself! !!SpSteloTitle methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 11:54'!clearPatchesAction: aBlock	buttonClearPatches action: aBlock! !!SpSteloTitle methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 11:54'!clearTurtlesAction: aBlock	buttonClearTurtles action: aBlock! !!SpSteloTitle methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 11:54'!initializePresenters	labelName := self newLabel.	buttonClearTurtles := self newButton.	buttonClearPatches := self newButton.	buttonStartSetup := self newButton.	buttonStopAll := self newButton.	buttonStepLoop := self newButton.	buttonStartLoopSlow := self newButton.	buttonStartLoop := self newButton.	labelName label: 'new project'.	self setupButtons.	self focusOrder		add: buttonClearTurtles;		add: buttonClearPatches;		add: buttonStartSetup;		add: buttonStopAll;		add: buttonStepLoop;		add: buttonStartLoopSlow;		add: buttonStartLoop! !!SpSteloTitle methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 15:52'!projectName	^ labelName label asString! !!SpSteloTitle methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 15:52'!projectName: aString	labelName label: aString asString! !!SpSteloTitle methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 11:56'!setupButtons	buttonClearTurtles icon: (ScratchTheme formAt: #clearTurtlesButtonGray).	buttonClearPatches icon: (ScratchTheme formAt: #clearGraphicsButtonGray).	buttonStartSetup icon: (ScratchTheme formAt: #setupButtonGray).	buttonStopAll icon: (ScratchTheme formAt: #stopButtonGray).	buttonStepLoop icon: (ScratchTheme formAt: #stepButtonGray).	buttonStartLoopSlow icon: (ScratchTheme formAt: #loopSlowButtonGray).	buttonStartLoop icon: (ScratchTheme formAt: #loopButtonGray)! !!SpSteloTitle methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 12:03'!startLoopAction: aBlock	buttonStartLoop action: aBlock! !!SpSteloTitle methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 12:03'!startLoopSlowAction: aBlock	buttonStartLoopSlow action: aBlock! !!SpSteloTitle methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 12:03'!startSetupAction: aBlock	buttonStartSetup action: aBlock! !!SpSteloTitle methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 12:03'!stepLoopAction: aBlock	buttonStepLoop action: aBlock! !!SpSteloTitle methodsFor: 'accessing' stamp: 'EiichiroIto 11/19/2019 12:03'!stopAllAction: aBlock	buttonStopAll action: aBlock! !!ObserverScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/24/2019 15:09'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	| blocks |	blocks := #(		'basic'			('set patch size to %n'		- createPatchesSize: 100)			('create %n %m'			-	createTurtleSize:breedId: 100)			-			('clear all'				-	clearAll)			('clear graphics'		-	clearGraphics)			('clear turtles'			-	clearTurtles)			('clear turtle %m'		-	clearTurtle:)		'patch'			('scale patch''s %p color %c from %n to %n'  - scalePatch:color:from:to: '' 15 1 100)			('multiply patch''s %p by %n'	- multiplyVar:by: '' 0.9)			-			('diffuse patch''s %p %n'			- diffuseVar:percentage: '' 20)			('diffuse4 patch''s %p %n'		- diffuse4Var:percentage: '' 20)			('nsum patch''s %p to %p'			- nsumVar:to: '' '')			('nsum4 patch''s %p to %p'		- nsum4Var:to: '' '')		'control'			('when setup'					T	-)	).	^ blocks, super blockSpecs! !!ObserverScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 12:10'!objName	^ 'Observer'! !!PatchesScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/25/2019 16:26'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	| blocks |	blocks := #(		'sensing'			('id'									r	getId)			('x position'						r	getXpos)			('y position'						r	getYpos)			('one of %m at %n'				r	turtle:at: '' 'where')			('distance to %n'				r	distanceTo: 'where')			('direction to %n'				r	directionTo: 'where')			-			('here'								r	here)			('x %n y %n from here'	r	relativeToX:y:		0 0)			('r %n theta %n from here'	r	relativeToR:theta:		0 0)		'control'			('when setup'						S	-)		'patch'			('patch color at %n' 			r 	getPatchColorAt: 'where')			('set patch color at %n to %c'			- setPatchColorAt:to: 'where' 15)	).	^ blocks, self colorBlocks, self variablesBlocks, super blockSpecs! !!PatchesScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 15:57'!objName	^ 'Patches'! !!SteloScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/24/2019 15:11'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	^ super blockSpecs, #(		'basic'			('kill %n of %m'				-	kill:breed:)		'sensing'			('x %n y %n'					r	patchAtX:y:	0 0)			-			('turtles %m count'			r turtlesCount:)			('screen width'				r 	screenWidth)			('screen height'				r 	screenHeight)			('ticks'							r 	ticks)	)! !!SteloScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/24/2019 15:08'!colorBlocks	^ #(		'color'			('color'					r	getColor)			('set color to %c'			- setColor: 15)			('scale %v color %c from %n to %n'  - #scaleValue:color:from:to: '' 15 0 100 )			-			('random'				r	colorRandom)			('black'				r	colorBlack)			('gray'				r	colorGray)			('white'				r	colorWhite)			('red'					r	colorRed)			('orange'			r	colorOrange)			('brown'				r	colorBrown)			('yellow'			r	colorYellow)			('green'				r	colorGreen)			('lime'				r	colorLime)			('turquoise'		r	colorTurquoise)			('cyan'				r	colorCyan)			('sky'					r	colorSky)			('blue'				r	colorBlue)			('purple'			r	colorPurple)			('magenta'			r	colorMagenta)			('pink'				r	colorPink)	)! !!SteloScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/25/2019 16:25'!variablesBlocks	^ #(		'list'			('add %n to %L'									-	append:toList: 10 'list')			('delete %n of %L'								-	deleteLine:ofList: 1 'list')			('replace item %n of %L with %n'		-	setLine:ofList:to: 1 'list' 10)			-			('item %n of %L'									r	getLine:ofList: 1 'list')			('length of %L'									r	lineCountOfList: 'list')			('%L contains %n'								b	list:contains: 'list' 10)			-			('set all nodes to %L'						- setAllNodesTo: 'list')			('set all edges to %L'						- setAllEdgesTo: 'list')			('connected nodes from %n into %L'	- connectedNodesFrom:into: 0 'list')	)! !!SteloScript methodsFor: 'variables' stamp: 'EiichiroIto 11/24/2019 21:58'!addList: aString	| vno |	vno := breed addList: aString.	self project addList: aString var: vno breed: breed breedNo! !!SteloScript methodsFor: 'variables' stamp: 'EiichiroIto 11/24/2019 21:55'!addVariable: aString	| vno |	vno := breed addVariable: aString.	self project addVariable: aString var: vno breed: breed breedNo! !!SteloScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 12:21'!breed	^ breed! !!SteloScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 12:21'!breed: aBreed	breed := aBreed! !!SteloScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 16:28'!breedNo	^ breed breedNo! !!SteloScript methodsFor: 'variables' stamp: 'EiichiroIto 11/24/2019 21:58'!deleteVariable: aString	breed deleteVariable: aString! !!SteloScript methodsFor: 'object i/o' stamp: 'EiichiroIto 11/29/2019 13:30'!fieldsVersion	^ 1! !!SteloScript methodsFor: 'object i/o' stamp: 'EiichiroIto 11/29/2019 13:30'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self		initFieldsNamed: #(breed)		from: anObjStream! !!SteloScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/25/2019 12:37'!listVarNames	^ breed userDefinedListNames sort! !!SteloScript methodsFor: 'program' stamp: 'EiichiroIto 11/24/2019 16:24'!newCode	^ SteloCode new! !!SteloScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 12:21'!objName	^ 'None'! !!SteloScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 21:55'!patchVarId	^ self project patches varId! !!SteloScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/25/2019 07:38'!patchVarNamesMenu	^ self project patchVarNamesMenu! !!SteloScript methodsFor: 'program' stamp: 'EiichiroIto 11/24/2019 15:24'!setupEvent: aHatBlock program: aProgram table: aDictionary events: aDictionary2	| code addr |	aDictionary2		at: aHatBlock eventName asSymbol		ifPresent: [ :eventNo | 			addr := aProgram nextAddress.			code := self newCode				startAddress: addr;				subTable: aDictionary;				parse: aHatBlock target: self.			aProgram				addCode: code;				addEntryPoint: addr eventNo: eventNo breedNo: self breedNo ]! !!SteloScript methodsFor: 'program' stamp: 'EiichiroIto 11/24/2019 15:24'!setupSub: aHatBlock program: aProgram table: aDictionary	| code addr |	addr := aProgram nextAddress.	code := self newCode		startAddress: addr;		subTable: aDictionary;		parse: aHatBlock target: self.	aProgram addCode: code.	aDictionary at: aHatBlock subName put: addr! !!SteloScript methodsFor: 'object i/o' stamp: 'EiichiroIto 11/29/2019 13:30'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(breed) on: anObjStream.! !!SteloScript methodsFor: 'private' stamp: 'EiichiroIto 11/25/2019 08:52'!toggleWatcher: aToggleButton for: aBlockMorph	! !!SteloScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/25/2019 12:32'!turtleVarNamesMenu	^ self project turtleVarNamesMenu! !!SteloScript methodsFor: 'argument menus' stamp: 'EiichiroIto 11/25/2019 16:36'!uncoloredArgMorphFor: specString	"Answer an argument morph for the given argument specification string."	| code |	code := specString at: 2.	"$a = code ifTrue: [^ AttributeArgMorph new choice: 'volume']."	$b = code ifTrue: [^ BooleanArgMorph new].	$c = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '15'; menuSelector: #colorMenu].	"$c = code ifTrue: [^ ColorArgMorph new showPalette: true].	$C = code ifTrue: [^ ColorArgMorph new showPalette: false]."  "don't use palette; pick from screen"	$d = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #directionMenu].	"$D = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '48'; menuSelector: #midiDrumMenu]."	$e = code ifTrue: [^ EventTitleMorph new].	$f = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #mathFunctionNames; choice: 'sqrt'].	"$g = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #graphicEffectNames; choice: 'color']."	"$H = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #hookupSensorNames]."	"$h = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #hookupBooleanSensorNames]."	"$I = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '1'; menuSelector: #midiInstrumentMenu]."	"$i = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '1'; menuSelector: #listIndexMenu]."	$k = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #keyNames; choice: 'space'].	$L = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #listVarNames].	"$l = code ifTrue: [^ ChoiceOrExpressionArgMorph new getOptionsSelector: #costumeNames; choice: 'costume1']."	$m = code ifTrue: [^ SpriteArgMorph new].	"$M = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #motorNames]."	$n = code ifTrue: [^ ExpressionArgMorph new numExpression: '10'].	$p = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #patchVarNamesMenu; choice: ''].	"$N = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '60'; menuSelector: #noteSelector]."	$S = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #subNames; choice: ''].	$s = code ifTrue: [^ ExpressionArgMorph new stringExpression: ''].	$t = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #turtleVarNamesMenu; choice: ''].	"$S = code ifTrue: [^ ChoiceOrExpressionArgMorph new getOptionsSelector: #soundNames; choice: 'pop']."	$v = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #varNames; choice: ''].	"$W = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #motorDirection]."	"$y = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '1'; menuSelector: #listIndexForDeleteMenu]."	^ ExpressionArgMorph new numExpression: '10'! !!SteloScript methodsFor: 'private' stamp: 'EiichiroIto 11/25/2019 08:51'!updateWatcher: aToggleButton for: aBlockMorph	! !!SteloScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 15:23'!varId	^ breed varId! !!SteloScript methodsFor: 'variables' stamp: 'EiichiroIto 11/24/2019 21:58'!varNames	^ breed userDefinedVarNames! !!SteloScript methodsFor: 'variables' stamp: 'EiichiroIto 11/24/2019 21:58'!variableNameInUse: aString	^ breed variableNameInUse: aString! !!TurtlesScript class methodsFor: 'block specs' stamp: 'EiichiroIto 11/25/2019 16:26'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	| blocks |	blocks := #(		'basic'			('forward %n'		- forward: 1)			('turn %n'				- turn: 15)			('heading %n'		- setHeading: 0)			-			('change x by %n'		-	changeXposBy: 1)			('set x to %n'				-	setXpos: 0)			('change y by %n'		-	changeYposBy: 1)			('set y to %n'				-	setYpos: 0)			-			('hatch'					-	hatch)			('die'						- die)		'pen'			('stamp'				- stamp)			('pen up'				- penUp)			('pen down'			- penDown)			('is pen down?'	r isPenDown)		'sensing'			('id'					r	getId)			('x position'		r	getXpos)			('y position'		r	getYpos)			('heading'			r	getHeading)			('dx'					r	dx)			('dy'					r	dy)			('breed id'			r	getBreedId)			-			('one of %m at %n'				r	turtle:at: '' 'where')			('distance to %n'				r	distanceTo: 'where')			('direction to %n'				r	directionTo: 'where')			('aim high %p'			r	aimHigh: '')			-			('%n of %m ''s %t'	r	getTurtle:breed:var:		0 '' '')			-			('here'								r	here)			('front'							r	front)			('x %n y %n from here'	r	relativeToX:y:		0 0)			('r %n theta %n from here'	r	relativeToR:theta:		0 0)		'control'			('when setup'		S	-)		'patch'			('patch color at %n' 			r 	getPatchColorAt: 'where')			('set patch color at %n to %c'			- setPatchColorAt:to: 'where' 15)			-			('patch''s %p at %n'							r 	getPatchVar:at: 	'' 'where')			('set patch''s %p at %n to %n'			-	setPatchVar:at:to: '' 'where' 0)			('change patch''s %p at %n by %n'		-	changePatchVar:at:by: '' 'where' 1)	).	^ blocks, self colorBlocks, self variablesBlocks, super blockSpecs! !!TurtlesScript methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 12:11'!objName	^ 'Turtles', breed breedNo asString! !!SBreedId class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:37'!observerBreedNo	^ 1! !!SBreedId class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:37'!patchBreedNo	^ 2! !!SBreedId class methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 11:37'!reservedNo	^ 2! !!SBreedId class methodsFor: 'accessing' stamp: 'EiichiroIto 3/13/2019 11:37'!turtleBreedNo	^ 3! !!SteloObjStream class methodsFor: 'class initialization' stamp: 'EiichiroIto 11/24/2019 22:00'!initialize	"SteloObjStream initialize"	self setupVariables! !!SteloObjStream class methodsFor: 'class initialization' stamp: 'EiichiroIto 11/29/2019 13:22'!userClasses	^ super userClasses, #(		"id		class"		(111 	SteloProject)		(112 	SteloScript)		(113		ObserverScript)		(114		PatchesScript)		(115		TurtlesScript)		(116 	SBreed)		(117 	SObserver)		(118		SPatches)		(119 	STurtles)		(120 	SBreedVarDef)		(121 	SObserverVarDef)		(122 	SPatchVarDef)		(123 	STurtleVarDef)		(124 	SDisplay)		(125 	SBreedId)	)! !!SThread class methodsFor: 'acccessing' stamp: 'EiichiroIto 9/10/2019 10:50'!generateSymbols	"self generateSymbols inspect."	| w |	self setupCachedSymbols.	w := WriteStream on: ''.	w		nextPutAll: 'enum SteloSymbol {';		nextPutAll: String lf;		nextPutAll: '  SS_nop = -1,';		nextPutAll: String lf.	cachedSymbols		withIndexDo: [ :each :index | 			w				nextPutAll: '  SS_';				nextPutAll: each;				nextPutAll: ',';				nextPutAll: ' /* ';				nextPutAll: (index - 1) asString;				nextPutAll: ' */';				nextPutAll: String lf ].	w		nextPutAll: '};';		nextPutAll: String lf.	^ w contents! !!SThread class methodsFor: 'instance creation' stamp: 'EiichiroIto 9/8/2018 17:47'!new	self shouldNotImplement! !!SThread class methodsFor: 'instance creation' stamp: 'EiichiroIto 8/8/2019 22:20'!sworld: aMicroWorld	^ self basicNew		initialize;		privSWorld: aMicroWorld;		yourself.! !!SThread methodsFor: 'turtle ops' stamp: 'EiichiroIto 10/9/2018 09:09'!aimHigh	| var ret |	var := self pop.	ret := world aimHighPatchVar: var breed: breedId id: id.	self push: ret.! !!SThread methodsFor: 'misc ops' stamp: 'EiichiroIto 9/13/2018 07:39'!broadcast	| eventId |	eventId := self pop.	world raiseEvent: eventId asInteger.! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 9/21/2019 15:39'!clearBreed	| bno |	bno := self pop.	world clearBreed: bno.! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 9/18/2018 17:23'!clearGraphics	world patches clear.! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 8/23/2019 13:00'!clearTurtles	world clearTurtles.! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 8/27/2019 16:51'!createPatch	| count |	count := self pop.	world createPatch: count asInteger.! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 10/9/2018 17:41'!createTurtles	| count bid |	bid := self pop.	count := self pop.	world create: bid asInteger turtles: count asInteger.! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 3/13/2019 14:42'!diffuse	| v p |	p := self pop.	v := self pop.	world patches diffuse8: p varNo: v.! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 3/13/2019 14:42'!diffuse4	| v p |	p := self pop.	v := self pop.	world patches diffuse4: p varNo: v.! !!SThread methodsFor: 'turtle ops' stamp: 'EiichiroIto 3/14/2019 20:44'!dx	| delta |	delta := world delta: breedId at: id.	self push: delta x! !!SThread methodsFor: 'turtle ops' stamp: 'EiichiroIto 3/14/2019 20:44'!dy	| delta |	delta := world delta: breedId at: id.	self push: delta y! !!SThread methodsFor: 'accessing' stamp: 'EiichiroIto 3/14/2019 13:36'!forBreedNo: bno index: anInteger	breedId := bno.	id := anInteger.! !!SThread methodsFor: 'accessing' stamp: 'EiichiroIto 3/14/2019 13:36'!forObserver	self forBreedNo: SBreedId observerBreedNo index: 1.! !!SThread methodsFor: 'accessing' stamp: 'EiichiroIto 3/14/2019 13:36'!forPatchId: anInteger	self forBreedNo: SBreedId patchBreedNo index: anInteger.! !!SThread methodsFor: 'turtle ops' stamp: 'EiichiroIto 10/6/2018 19:05'!forward	| step |	step := self pop.	world forward: step breed: breedId id: id.! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 10/6/2018 22:53'!getBreedId	self push: breedId.! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 8/24/2019 18:17'!getBreedVar	| var index bno ret |	bno := self pop.	var := self pop.	index := self pop.	ret := world var: var breed: bno at: index.	self push: ret.! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 8/24/2019 18:17'!getVar	| var ret |	var := self pop.	ret := world var: var breed: breedId at: id.	self push: ret.! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 3/15/2019 18:26'!getX	| ret |	ret := world x: breedId at: id.	self push: ret.! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 3/15/2019 18:27'!getY	| ret |	ret := world y: breedId at: id.	self push: ret.! !!SThread methodsFor: 'turtle ops' stamp: 'EiichiroIto 10/6/2018 18:35'!hatch	world hatch: breedId id: id.! !!SThread methodsFor: 'turtle ops' stamp: 'EiichiroIto 3/15/2019 17:03'!kill	| tid bid |	breedId <= SBreedId patchBreedNo		ifTrue: [ ^ self ].	tid := self pop.	bid := self pop.	world kill: bid index: tid.	(breedId = bid and: [ id = tid ])		ifTrue: [ self stop ]! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 3/13/2019 14:45'!multiplyBy	| v p |	p := self pop.	v := self pop.	world patches multiplyBy: p varNo: v.! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 3/13/2019 14:43'!nsum	| v1 v2 |	v2 := self pop.	v1 := self pop.	world patches nsum8: v1 to: v2.! !!SThread methodsFor: 'observer ops' stamp: 'EiichiroIto 3/13/2019 14:43'!nsum4	| v1 v2 |	v2 := self pop.	v1 := self pop.	world patches nsum4: v1 to: v2.! !!SThread methodsFor: 'patch ops' stamp: 'EiichiroIto 3/16/2019 19:16'!patchAt	| x y ret |	y := self pop.	x := self pop.	ret := world patchIndexAtX: x y: y.	self push: ret.! !!SThread methodsFor: 'private' stamp: 'EiichiroIto 10/6/2018 18:24'!privBreedId	^ breedId! !!SThread methodsFor: 'private' stamp: 'EiichiroIto 10/6/2018 18:24'!privBreedId: anObject	breedId := anObject! !!SThread methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 22:20'!privSWorld	^ world! !!SThread methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 22:20'!privSWorld: anObject	world := anObject! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 10/6/2018 18:58'!scaleColorFromTo	| v c f t |	t := self pop.	f := self pop.	c := self pop.	v := self pop.	world scaleVar: v color: c breed: breedId from: f to: t id: id.! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 8/24/2019 18:17'!setBreedVarTo	| var val index bno |	bno := self pop.	var := self pop.	val := self pop.	index := self pop.	world		var: var		breed: bno		at: index		put: val! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 11/28/2019 22:09'!setColorTo	| color |	color := self pop.	world var: STurtleVarDef colorVarNo breed: breedId at: id put: color.! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 11/28/2019 22:09'!setHeading	| degrees |	breedId <= SBreedId patchBreedNo		ifTrue: [ ^ self ].	degrees := self pop.	world var: STurtleVarDef headingVarNo breed: SBreedId turtleBreedNo at: id put: degrees.! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 11/28/2019 22:09'!setPatchColorTo	| color pid |	color := self pop.	pid := self pop.	world var: SPatchVarDef colorVarNo breed: SBreedId patchBreedNo at: pid put: color.! !!SThread methodsFor: 'variable ops' stamp: 'EiichiroIto 8/24/2019 18:17'!setVarTo	| var val |	val := self pop.	var := self pop.	world		var: var		breed: breedId		at: id		put: val! !!SThread methodsFor: 'turtle ops' stamp: 'EiichiroIto 3/15/2019 18:33'!setX	| v |	breedId <= SBreedId patchBreedNo		ifTrue: [ ^ self ].	v := self pop.	world x: breedId at: id put: v! !!SThread methodsFor: 'turtle ops' stamp: 'EiichiroIto 3/15/2019 18:33'!setY	| v |	breedId <= SBreedId patchBreedNo		ifTrue: [ ^ self ].	v := self pop.	world y: breedId at: id put: v! !!SThread methodsFor: 'turtle ops' stamp: 'EiichiroIto 9/4/2019 13:18'!turtleAt	| x y ret bid pno |	bid := self pop.	pno := self pop.	x := world patches xAt: pno.	y := world patches yAt: pno.	ret := world turtle: bid x: x y: y exceptBreed: breedId index: id.	self push: ret.! !!SThread methodsFor: 'patch ops' stamp: 'EiichiroIto 9/4/2019 21:45'!xyOf	| pno x y |	pno := self pop.	x := world patches xAt: pno.	y := world patches yAt: pno.	self push: x.	self push: y.! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 10/9/2018 09:05'!aimHighVar: v	^ self unaryCommand: #aimHigh arg: v! !!SteloBytecodeGenerator methodsFor: 'misc ops' stamp: 'EiichiroIto 9/21/2018 16:19'!broadcast: anInteger	self unaryCommand: #broadcast arg: anInteger.! !!SteloBytecodeGenerator methodsFor: 'patch ops' stamp: 'EiichiroIto 9/5/2019 10:36'!changePatchVar: v at: pno by: aNumber	self appendValue: pno.	self appendSymbol: #dup.	self appendValue: v.	self appendValue: SBreedId patchBreedNo.	self appendSymbol: #getBreedVar.	self appendValue: aNumber.	self appendSymbol: #plus.	self appendValue: v.	self appendValue: SBreedId patchBreedNo.	self appendSymbol: #setBreedVarTo.! !!SteloBytecodeGenerator methodsFor: 'variable ops' stamp: 'EiichiroIto 9/20/2018 16:20'!changeVar: id by: aNumber	self appendValue: id.	self appendSymbol: #dup.	self appendSymbol: #getVar.	self appendValue: aNumber.	self appendSymbol: #plus.	self appendSymbol: #setVarTo.! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 10/8/2018 18:42'!changeXposBy: aNumber	self appendSymbol: #getX.	self appendValue: aNumber.	self appendSymbol: #plus.	self appendSymbol: #setX! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 10/8/2018 18:42'!changeYposBy: aNumber	self appendSymbol: #getY.	self appendValue: aNumber.	self appendSymbol: #plus.	self appendSymbol: #setY! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/21/2019 15:42'!clearAll	self unaryCommand: #clearBreed arg: SBreedId patchBreedNo.	self nullaryCommand: #clearTurtles.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/21/2019 15:42'!clearGraphics	self unaryCommand: #clearBreed arg: SBreedId patchBreedNo.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/21/2019 15:46'!clearTurtle: bno	self unaryCommand: #clearBreed arg: bno.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/20/2018 13:48'!clearTurtles	self nullaryCommand: #clearTurtles.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/20/2018 16:31'!createPatchesSize: anInteger	self unaryCommand: #createPatch arg: anInteger.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/20/2018 13:48'!createTurtleSize: size breedId: id	self binaryCommand: #createTurtles arg1: size arg2: id.! !!SteloBytecodeGenerator methodsFor: 'misc ops' stamp: 'EiichiroIto 10/6/2018 22:29'!die	self appendSymbol: #getBreedId.	self appendSymbol: #getId.	self appendSymbol: #kill.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/20/2018 13:46'!diffuse4Var: v percentage: aNumber	self binaryCommand: #diffuse4 arg1: v arg2: aNumber.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/20/2018 13:46'!diffuseVar: v percentage: aNumber	self binaryCommand: #diffuse arg1: v arg2: aNumber.! !!SteloBytecodeGenerator methodsFor: 'misc ops' stamp: 'EiichiroIto 9/5/2019 09:06'!directionTo: pno	self appendValue: pno.	self appendSymbol: #xyOf.	self appendSymbol: #swap.	self appendSymbol: #getX.	self appendSymbol: #minus.	self appendSymbol: #swap.	self appendSymbol: #getY.	self appendSymbol: #minus.	self appendSymbol: #direction.	^ nil! !!SteloBytecodeGenerator methodsFor: 'misc ops' stamp: 'EiichiroIto 9/4/2019 21:49'!distanceTo: pno	self appendValue: pno.	self appendSymbol: #xyOf.	self appendSymbol: #swap.	self appendSymbol: #getX.	self appendSymbol: #minus.	self appendSymbol: #dup.	self appendSymbol: #mul.	self appendSymbol: #swap.	self appendSymbol: #getY.	self appendSymbol: #minus.	self appendSymbol: #dup.	self appendSymbol: #mul.	self appendSymbol: #plus.	self appendSymbol: #sqrt.	^ nil! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 3/14/2019 20:44'!dx	^ self nullaryCommand: #dx! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 3/14/2019 20:44'!dy	^ self nullaryCommand: #dy! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 9/20/2018 16:32'!forward: aNumber	self unaryCommand: #forward arg: aNumber.! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 9/5/2019 10:52'!front	self appendSymbol: #getX.	self appendSymbol: #dx.	self appendSymbol: #plus.	self appendSymbol: #getY.	self appendSymbol: #dy.	self appendSymbol: #plus.	self appendSymbol: #patchAt.	^ nil! !!SteloBytecodeGenerator methodsFor: 'variable ops' stamp: 'EiichiroIto 10/8/2018 18:58'!getBreedId	^ self nullaryCommand: #getBreedId.! !!SteloBytecodeGenerator methodsFor: 'color ops' stamp: 'EiichiroIto 11/28/2019 22:09'!getColor	^ self getVar: STurtleVarDef colorVarNo! !!SteloBytecodeGenerator methodsFor: 'variable ops' stamp: 'EiichiroIto 9/16/2019 17:31'!getObserverVar: vid	^ self getObserverVar: vid arg: 1! !!SteloBytecodeGenerator methodsFor: 'variable ops' stamp: 'EiichiroIto 9/16/2019 17:30'!getObserverVar: vid arg: anInteger	self appendValue: anInteger.	self appendValue: vid.	self appendValue: SBreedId observerBreedNo.	self appendSymbol: #getBreedVar.	^ nil! !!SteloBytecodeGenerator methodsFor: 'patch ops' stamp: 'EiichiroIto 11/28/2019 22:09'!getPatchColorAt: pno	^ self getPatchVar: SPatchVarDef colorVarNo at: pno! !!SteloBytecodeGenerator methodsFor: 'patch ops' stamp: 'EiichiroIto 9/4/2019 21:51'!getPatchVar: vid at: pno	self appendValue: pno.	self appendValue: vid.	self appendValue: SBreedId patchBreedNo.	self appendSymbol: #getBreedVar.	^ nil! !!SteloBytecodeGenerator methodsFor: 'variable ops' stamp: 'EiichiroIto 9/20/2018 13:42'!getVar: id	^ self unaryCommand: #getVar arg: id! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 3/15/2019 16:25'!getVar: aBlock1 breedNo: aBlock2 index: index	| bno |	self appendValue: index.	bno := aBlock2 value.	self appendValue: (aBlock1 value: bno).	self appendValue: bno.	self appendSymbol: #getBreedVar.	^ nil! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 10/10/2018 22:22'!getXpos	^ self nullaryCommand: #getX! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 10/10/2018 22:22'!getYpos	^ self nullaryCommand: #getY! !!SteloBytecodeGenerator methodsFor: 'misc ops' stamp: 'EiichiroIto 9/20/2018 13:40'!hatch	^ self nullaryCommand: #hatch.! !!SteloBytecodeGenerator methodsFor: 'patch ops' stamp: 'EiichiroIto 9/4/2019 21:19'!here	self appendSymbol: #getX.	self appendSymbol: #getY.	self appendSymbol: #patchAt.	^ nil! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!isPenDown	self appendValue: 0.	self getVar: STurtleVarDef flagVarNo.	self appendValue: 1 << STurtleVarDef penDownFlagNo.	self appendSymbol: #and.	self appendSymbol: #less.	^ nil! !!SteloBytecodeGenerator methodsFor: 'misc ops' stamp: 'EiichiroIto 10/7/2018 09:36'!kill: id breed: bid	self binaryCommand: #kill arg1: bid arg2: id.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/26/2018 21:21'!multiplyVar: v by: aNumber	self binaryCommand: #multiplyBy arg1: v arg2: aNumber.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/20/2018 13:44'!nsum4Var: v1 to: v2	self binaryCommand: #nsum4 arg1: v1 arg2: v2.! !!SteloBytecodeGenerator methodsFor: 'observer ops' stamp: 'EiichiroIto 9/20/2018 13:45'!nsumVar: v1 to: v2	self binaryCommand: #nsum arg1: v1 arg2: v2.! !!SteloBytecodeGenerator methodsFor: 'patch ops' stamp: 'EiichiroIto 9/20/2018 20:59'!patchAtX: x y: y	^ self binaryCommand: #patchAt arg1: x arg2: y! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!penDown: aBoolean	self appendValue: STurtleVarDef flagVarNo.	self getVar: STurtleVarDef flagVarNo.	self appendValue: 1 << STurtleVarDef penDownFlagNo.	aBoolean		ifTrue: [ self appendSymbol: #or ]		ifFalse: [ self appendSymbol: #inv.			self appendSymbol: #and ].	self appendSymbol: #setVarTo! !!SteloBytecodeGenerator methodsFor: 'patch ops' stamp: 'EiichiroIto 9/12/2019 13:47'!relativeToR: r theta: theta	self appendValue: r.	self appendValue: theta.	self appendSymbol: #cos.	self appendSymbol: #mul.	self appendSymbol: #getX.	self appendSymbol: #plus.	self appendValue: r.	self appendValue: theta.	self appendSymbol: #sin.	self appendSymbol: #mul.	self appendSymbol: #getY.	self appendSymbol: #plus.	self appendSymbol: #patchAt.	^ nil! !!SteloBytecodeGenerator methodsFor: 'patch ops' stamp: 'EiichiroIto 9/5/2019 10:26'!relativeToX: x y: y	self appendValue: x.	self appendSymbol: #getX.	self appendSymbol: #plus.	self appendValue: y.	self appendSymbol: #getY.	self appendSymbol: #plus.	self appendSymbol: #patchAt.	^ nil! !!SteloBytecodeGenerator methodsFor: 'color ops' stamp: 'EiichiroIto 9/26/2018 19:32'!scaleValue: v color: c from: f to: t	self appendValue: v.	self appendValue: c.	self appendValue: f.	self appendValue: t.	self appendSymbol: #scaleColorFromTo.! !!SteloBytecodeGenerator methodsFor: 'color ops' stamp: 'EiichiroIto 10/8/2018 18:28'!setColorTo: anInteger	self unaryCommand: #setColorTo arg: anInteger.! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 9/20/2018 16:18'!setHeading: aNumber	self unaryCommand: #setHeading arg: aNumber.! !!SteloBytecodeGenerator methodsFor: 'patch ops' stamp: 'EiichiroIto 11/28/2019 22:09'!setPatchColorAt: pno to: aNumber	self setPatchVar: SPatchVarDef colorVarNo at: pno to: aNumber! !!SteloBytecodeGenerator methodsFor: 'patch ops' stamp: 'EiichiroIto 9/4/2019 21:52'!setPatchVar: var at: pno to: aNumber	self appendValue: pno.	self appendValue: aNumber.	self appendValue: var.	self appendValue: SBreedId patchBreedNo.	self appendSymbol: #setBreedVarTo.! !!SteloBytecodeGenerator methodsFor: 'variable ops' stamp: 'EiichiroIto 9/20/2018 20:50'!setVar: vid to: aNumber	self binaryCommand: #setVarTo arg1: vid arg2: aNumber! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 9/20/2018 16:18'!setXpos: aNumber	self unaryCommand: #setX arg: aNumber.! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 9/20/2018 16:18'!setYpos: aNumber	self unaryCommand: #setY arg: aNumber.! !!SteloBytecodeGenerator methodsFor: 'color ops' stamp: 'EiichiroIto 11/28/2019 22:09'!stamp	self getVar: STurtleVarDef xVarNo.	self getVar: STurtleVarDef yVarNo.	self appendSymbol: #patchAt.	self getVar: STurtleVarDef colorVarNo.	self appendSymbol: #setPatchColorTo.! !!SteloBytecodeGenerator methodsFor: 'turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!turn: aNumber	self appendValue: aNumber.	self getVar: STurtleVarDef headingVarNo.	self appendSymbol: #plus.	self appendSymbol: #setHeading.! !!SteloBytecodeGenerator methodsFor: 'misc ops' stamp: 'EiichiroIto 9/4/2019 21:36'!turtle: bid at: pno	self appendValue: pno.	self appendValue: bid.	self appendSymbol: #turtleAt.	^ nil! !!SteloLibrary methodsFor: 'accessing platform' stamp: 'EiichiroIto 8/8/2019 18:48'!macModuleName	^ 'stelo.so'! !!SteloLibrary methodsFor: 'accessing platform' stamp: 'EiichiroIto 8/8/2019 18:48'!unixModuleName	^ 'stelo.so'! !!SteloLibrary methodsFor: 'accessing platform' stamp: 'EiichiroIto 9/3/2019 15:10'!win32ModuleName	^ 'stelo64.dll'! !!SteloLibrary methodsFor: 'accessing platform' stamp: 'EiichiroIto 8/27/2019 16:53'!winModuleName	^ 'stelo64.dll'! !!SBreedIdTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 11:40'!testObserverBreedNo	self assert: SBreedId observerBreedNo equals: 1.! !!SBreedIdTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 11:40'!testPatchBreedNo	self assert: SBreedId patchBreedNo equals: 2.! !!SBreedIdTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 11:41'!testReservedNo	self assert: SBreedId reservedNo equals: SBreedId patchBreedNo.! !!SBreedIdTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 11:40'!testTurtleBreedNo	self assert: SBreedId turtleBreedNo equals: 3.! !!SBreedTest methodsFor: 'tests-variables' stamp: 'EiichiroIto 9/12/2018 08:16'!testAddVariable	| br a b |	br := SBreed new.	a := br addVariable: 'a'.	b := br addVariable: 'b'.	self assert: a ~= b.	self assert: (br privVariables privVarNames includes: 'a' ).	self assert: (br privVariables privVarNames includes: 'b' ).! !!SBreedTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 9/28/2019 19:13'!testColorAt	| ps |	ps := SPatches new.	ps create: 3.	(ps privVariables varAt: 1) setArray: #[0 1 0 2 0 3 0 0 0].	self assert: (ps colorAt: 1) equals: 0.	self assert: (ps colorAt: 2) equals: 1.	self assert: (ps colorAt: 3) equals: 0.	self assert: (ps colorAt: 4) equals: 2.! !!SBreedTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 14:25'!testColorAtPut	| ps |	ps := SPatches new.	ps create: 3.	self assertCollection: ps colors equals: #[0 0 0 0 0 0 0 0 0].	ps colorAt: 1 put: 1.	ps colorAt: 2 put: 30.	ps colorAt: 9 put: 41.	self assertCollection: ps colors equals: #[1 30 0 0 0 0 0 0 41]! !!SBreedTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/16/2019 18:55'!testColors	| ps |	ps := SPatches new.	ps create: 3.	self assert: ps colors size equals: 9.	self assert: (ps colors allSatisfy: [ :each | each = 0 ]).! !!SBreedTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/16/2019 17:07'!testCountAlive	| ps |	ps := SPatches new.	ps create: 5.	self assert: ps countAlive equals: 25.	ps create: 10.	self assert: ps countAlive equals: 100.! !!SBreedTest methodsFor: 'tests-variables' stamp: 'EiichiroIto 9/27/2018 21:33'!testDeleteVariable	| br a b |	br := SBreed new.	a := br addVariable: 'a'.	b := br addVariable: 'b'.	self assert: a ~= b.	br deleteVariable: 'b'.	self assert: (br privVariables privVarNames includes: 'a' ).	self deny: (br privVariables privVarNames includes: 'b' ).	self assert: (br varId privVarNames includes: 'a' ).	self deny: (br varId privVarNames includes: 'b' ).! !!SBreedTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 11/28/2019 22:15'!testInitialize	| br |	br := SBreed new.	self assert: br varId class equals: SBreedVarDef.	self assert: br privVariables class equals: Variables.! !!SBreedTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 19:30'!testPrivVariables	| obj |	obj := STurtles new.	self assert: obj privVariables class equals: Variables.	obj := SPatches new.	self assert: obj privVariables class equals: Variables! !!SBreedTest methodsFor: 'tests-command' stamp: 'EiichiroIto 3/13/2019 15:39'!testScaleValueColorFromTo	| br c |	br := SBreed new.	c := br scaleValue: 0 color: 35 from: 1 to: 9.	self assert: c equals: SColorList black.	c := br scaleValue: 10 color: 35 from: 1 to: 9.	self assert: c equals: SColorList white.	c := br scaleValue: 5 color: 35 from: 1 to: 9.	self assert: c equals: 34.	c := br scaleValue: 1 color: 35 from: 1 to: 9.	self assert: c equals: 30.	c := br scaleValue: 9 color: 35 from: 1 to: 9.	self assert: c equals: 39.	c := br scaleValue: 10 color: 35 from: 9 to: 1.	self assert: c equals: SColorList black.	c := br scaleValue: 0 color: 35 from: 9 to: 1.	self assert: c equals: SColorList white.	c := br scaleValue: 5 color: 35 from: 9 to: 1.	self assert: c equals: 34.	c := br scaleValue: 1 color: 35 from: 9 to: 1.	self assert: c equals: 39.	c := br scaleValue: 9 color: 35 from: 9 to: 1.	self assert: c equals: 30.! !!SBreedTest methodsFor: 'tests-command' stamp: 'EiichiroIto 11/24/2019 21:16'!testScaleVarNoColorFromToIndex	| br a |	br := STurtles new.	a := br addVariable: 'a'.	br privVariables forceSize: 2.	br var: a at: 1 put: 0.	br		scaleVarNo: a		color: 35		from: 1		to: 9		index: 1.	self assert: (br colorAt: 1) equals: SColorList black.	br var: a at: 1 put: 10.	br		scaleVarNo: a		color: 35		from: 1		to: 9		index: 1.	self assert: (br colorAt: 1) equals: SColorList white.	br var: a at: 1 put: 5.	br		scaleVarNo: a		color: 35		from: 1		to: 9		index: 1.	self assert: (br colorAt: 1) equals: 34.	br var: a at: 1 put: 1.	br		scaleVarNo: a		color: 35		from: 1		to: 9		index: 1.	self assert: (br colorAt: 1) equals: 30.	br var: a at: 1 put: 9.	br		scaleVarNo: a		color: 35		from: 1		to: 9		index: 1.	self assert: (br colorAt: 1) equals: 39.	br var: a at: 1 put: 10.	br		scaleVarNo: a		color: 35		from: 9		to: 1		index: 1.	self assert: (br colorAt: 1) equals: SColorList black.	br var: a at: 1 put: 0.	br		scaleVarNo: a		color: 35		from: 9		to: 1		index: 1.	self assert: (br colorAt: 1) equals: SColorList white.	br var: a at: 1 put: 5.	br		scaleVarNo: a		color: 35		from: 9		to: 1		index: 1.	self assert: (br colorAt: 1) equals: 34.	br var: a at: 1 put: 1.	br		scaleVarNo: a		color: 35		from: 9		to: 1		index: 1.	self assert: (br colorAt: 1) equals: 39.	br var: a at: 1 put: 9.	br		scaleVarNo: a		color: 35		from: 9		to: 1		index: 1.	self assert: (br colorAt: 1) equals: 30! !!SBreedTest methodsFor: 'tests-variables' stamp: 'EiichiroIto 9/12/2018 09:15'!testUserDefinedVarNames	| ts ps l |	ts := STurtles new.	ts addVariable: 'a'.	l := ts userDefinedVarNames.	self assertCollection: l asArray equals: #('a').	ts addVariable: 'b'.	l := ts userDefinedVarNames.	self assertCollection: l asArray equals: #('a' 'b').	ps := SPatches new.	ps addVariable: 'a'.	l := ps userDefinedVarNames.	self assertCollection: l asArray equals: #('a').	ps addVariable: 'b'.	l := ps userDefinedVarNames.	self assertCollection: l asArray equals: #('a' 'b').! !!SBreedTest methodsFor: 'test' stamp: 'EiichiroIto 8/27/2019 20:22'!testUserDefinedVarNoAndNames	| ts ps l |	ts := STurtles new.	ts addVariable: 'a'.	l := ts userDefinedVarNoAndNames.	self assertCollection: l asArray equals: #((6 'a')).	ts addVariable: 'b'.	l := ts userDefinedVarNoAndNames.	self assertCollection: l asArray equals: #((6 'a') (7 'b')).	ps := SPatches new.	ps addVariable: 'a'.	l := ps userDefinedVarNoAndNames.	self assertCollection: l asArray equals: #((5 'a')).	ps addVariable: 'b'.	l := ps userDefinedVarNoAndNames.	self assertCollection: l asArray equals: #((5 'a') (6 'b')).! !!SBreedTest methodsFor: 'tests-command' stamp: 'EiichiroIto 3/15/2019 19:57'!testVarAt	| br a |	br := SBreed new.	a := br addVariable: 'a'.	br privVariables forceSize: 2.	br var: a at: 1 put: 1.	br var: a at: 2 put: 3.	self assert: ((br privVariables privVars at: a) at: 1) equals: 1.	self assert: ((br privVariables privVars at: a) at: 2) equals: 3.	self assert: (br var: a at: 1) equals: 1.	self assert: (br var: a at: 2) equals: 3.	br var: a at: 1 put: 5.	br var: a at: 2 put: 2.	self assert: ((br privVariables privVars at: a) at: 1) equals: 5.	self assert: ((br privVariables privVars at: a) at: 2) equals: 2.	self assert: (br var: a at: 1) equals: 5.	self assert: (br var: a at: 2) equals: 2! !!SBreedTest methodsFor: 'tests-command' stamp: 'EiichiroIto 3/15/2019 19:57'!testVarAtPut	| br a |	br := SBreed new.	a := br addVariable: 'a'.	br privVariables forceSize: 2.	self assert: ((br privVariables privVars at: a) at: 1) equals: 0.	self assert: ((br privVariables privVars at: a) at: 2) equals: 0.	br var: a at: 1 put: 1.	br var: a at: 2 put: 3.	self assert: ((br privVariables privVars at: a) at: 1) equals: 1.	self assert: ((br privVariables privVars at: a) at: 2) equals: 3.	br var: a at: 1 put: 5.	br var: a at: 2 put: 2.	self assert: ((br privVariables privVars at: a) at: 1) equals: 5.	self assert: ((br privVariables privVars at: a) at: 2) equals: 2! !!SBreedTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testVarFor	| s |	s := STurtles new.	self assert: (s varNoFor: 'color') equals: STurtleVarDef colorVarNo.	self assert: (s varNoFor: 'x') equals: STurtleVarDef xVarNo.	self assert: (s varNoFor: 'y') equals: STurtleVarDef yVarNo.! !!SBreedTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/28/2019 22:09'!testVarId	| obj |	obj := STurtles new.	self assert: obj varId class equals: STurtleVarDef.	obj := SPatches new.	self assert: obj varId class equals: SPatchVarDef! !!SBreedTest methodsFor: 'tests-variables' stamp: 'EiichiroIto 8/27/2019 20:19'!testVarNames	| ts ps l |	ts := STurtles new.	ts addVariable: 'a'.	l := ts varNames.	self assertCollection: l equals: #('color' 'flag' 'x' 'y' 'heading' 'a').	ts addVariable: 'b'.	l := ts varNames.	self assertCollection: l equals: #('color' 'flag' 'x' 'y' 'heading' 'a' 'b').	ps := SPatches new.	ps addVariable: 'a'.	l := ps varNames.	self assertCollection: l equals: #('color' 'screen' 'x' 'y' 'a').	ps addVariable: 'b'.	l := ps varNames.	self assertCollection: l equals: #('color' 'screen' 'x' 'y' 'a' 'b').! !!SBreedTest methodsFor: 'tests-variables' stamp: 'EiichiroIto 9/12/2018 09:20'!testVariableNameInUse	| br |	br := SBreed new.	self deny: (br variableNameInUse: 'a').	br addVariable: 'a'.	self assert: (br variableNameInUse: 'a').	br deleteVariable: 'a'.	self deny: (br variableNameInUse: 'a').! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/18/2019 10:40'!testAllocateExtended	| d x |	d := SDiffuser2 new.	self assert: d privExtended isNil.	d allocateExtended: 25.	self assert: (d privExtended isKindOf: FloatArray).	self assert: d privExtended size equals: 25.	x := d privExtended.	d allocateExtended: 20.	self assert: d privExtended equals: x.	self assert: d privExtended size equals: 25.	d allocateExtended: 30.	self assert: d privExtended ~= x.	self assert: d privExtended size equals: 30.! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 21:48'!testClearExtended	| d |	d := SDiffuser2 new.	d allocateExtended: 10.	self assert: (d privExtended allSatisfy: [ :each | each = 0 ]).	d privExtended atAllPut: 1.	self assert: (d privExtended allSatisfy: [ :each | each = 1 ]). 	d clearExtended.	self assert: (d privExtended allSatisfy: [ :each | each = 0 ]).! !!SDiffuser2Test methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/18/2019 10:03'!testDiffuseOrderPercentNeighborSize	| d x |	d := SDiffuser2 new.	x := FloatArray newFrom: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0).	d diffuse: x order: 4 percent: 80 neighborSize: 8.	self assertCollection: x equals: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray."0 0  0 0    0 1  1 1 0 0 10 0 -> 0 1  2 1 0 0  0 0    0 1  1 1 0 0  0 0    0 0  0 0"	x := FloatArray newFrom: #(0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0).	d diffuse: x order: 4 percent: 80 neighborSize: 8.	self assertCollection: x equals: #(0 1 1 1 0 1 2 1 0 1 1 1 0 0 0 0) asFloatArray."0 0 0 0    0 0 0 0 0 0 0 0    1 1 0 110 0 0 0 -> 2 1 0 1 0 0 0 0    1 1 0 1"	x := FloatArray newFrom: #(0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0).	d diffuse: x order: 4 percent: 80 neighborSize: 8.	self assertCollection: x equals: #(0 0 0 0 1 1 0 1 2 1 0 1 1 1 0 1) asFloatArray."0 0 0 0    1 1 0 1 0 0 0 0    0 0 0 0 0 0 0 0 -> 1 1 0 110 0 0 0    2 1 0 1"	x := FloatArray newFrom: #(0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0).	d diffuse: x order: 4 percent: 80 neighborSize: 8.	self assertCollection: x equals: #(1 1 0 1 0 0 0 0 1 1 0 1 2 1 0 1) asFloatArray.! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/18/2019 10:15'!testDiffusePercent	| d |	d := SDiffuser2 new.	d privOrder: 4.	d privNeighborSize: 8.	d setupNeighbor."            0 0 0 0 0 0 0 0  0 0    0 0 1 1 1 0 0 0 10 0 -> 0 0 1 2 1 0 0 0  0 0    0 0 1 1 1 0 0 0  0 0    0 0 0 0 0 0             0 0 0 0 0 0"	d allocateExtended: 36.	d diffuse: #(0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0) asFloatArray percent: 80.	self assertCollection: d privExtended equals: #(0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 2 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray."            0 0 0 0 0 0 0  0 0 0    0 0 0 0 0 0 0  0 0 0 -> 0 1 1 1 0 0 0 10 0 0    0 1 2 1 0 0 0  0 0 0    0 1 1 1 0 0             0 0 0 0 0 0"	d clearExtended.	d diffuse: #(0 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0) asFloatArray percent: 80.	self assertCollection: d privExtended equals: #(0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 2 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0) asFloatArray."             0 0 0 0 0 0 0  0  0 0    0 0 1 1 1 0 0  0 10 0 -> 0 1 2 3 1 0 0 10  0 0    0 1 3 2 1 0 0  0  0 0    0 1 1 1 0 0              0 0 0 0 0 0"	d clearExtended.	d diffuse: #(0 0 0 0 0 0 10 0 0 10 0 0 0 0 0 0) asFloatArray percent: 80.	self assertCollection: d privExtended equals: #(0 0 0 0 0 0 0 0 1 1 1 0 0 1 2 3 1 0 0 1 3 2 1 0 0 1 1 1 0 0 0 0 0 0 0 0) asFloatArray."           0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0    1 1 1 0 0 010 0 0 0 -> 1 2 1 0 0 0 0 0 0 0    1 1 1 0 0 0            0 0 0 0 0 0"	d clearExtended.	d diffuse: #(0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0) asFloatArray percent: 80.	self assertCollection: d privExtended equals: #(0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 2 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0) asFloatArray."           0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 -> 1 1 1 0 0 010 0 0 0    1 2 1 0 0 0            1 1 1 0 0 0"	d clearExtended.	d diffuse: #(0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0) asFloatArray percent: 80.	self assertCollection: d privExtended equals: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 2 1 0 0 0 1 1 1 0 0 0) asFloatArray.	d := SDiffuser2 new.	d privOrder: 4.	d privNeighborSize: 4.	d setupNeighbor."            0 0 0 0 0 0 0 0  0 0    0 0 0 2 0 0 0 0 10 0 -> 0 0 2 2 2 0 0 0  0 0    0 0 0 2 0 0 0 0  0 0    0 0 0 0 0 0             0 0 0 0 0 0"	d allocateExtended: 36.	d diffuse: #(0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0) asFloatArray percent: 80.	self assertCollection: d privExtended equals: #(0 0 0 0 0 0 0 0 0 2 0 0 0 0 2 2 2 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray.! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 18:50'!testIndexOfExtendedXY	| d |	d := SDiffuser2 new.	d privOrder: 4.	self assert: (d indexOfExtendedX: -1 y: -1) equals: 1.	self assert: (d indexOfExtendedX: 0 y: -1) equals: 2.	self assert: (d indexOfExtendedX: 1 y: -1) equals: 3.	self assert: (d indexOfExtendedX: 2 y: -1) equals: 4.	self assert: (d indexOfExtendedX: 3 y: -1) equals: 5.	self assert: (d indexOfExtendedX: 4 y: -1) equals: 6.	self assert: (d indexOfExtendedX: -1 y: 0) equals: 7.	self assert: (d indexOfExtendedX: 0 y: 0) equals: 8.	self assert: (d indexOfExtendedX: 1 y: 0) equals: 9.	self assert: (d indexOfExtendedX: 2 y: 0) equals: 10.	self assert: (d indexOfExtendedX: 3 y: 0) equals: 11.	self assert: (d indexOfExtendedX: 4 y: 0) equals: 12.	self assert: (d indexOfExtendedX: -1 y: 3) equals: 25.	self assert: (d indexOfExtendedX: 0 y: 3) equals: 26.	self assert: (d indexOfExtendedX: 1 y: 3) equals: 27.	self assert: (d indexOfExtendedX: 2 y: 3) equals: 28.	self assert: (d indexOfExtendedX: 3 y: 3) equals: 29.	self assert: (d indexOfExtendedX: 4 y: 3) equals: 30.	self assert: (d indexOfExtendedX: -1 y: 4) equals: 31.	self assert: (d indexOfExtendedX: 0 y: 4) equals: 32.	self assert: (d indexOfExtendedX: 1 y: 4) equals: 33.	self assert: (d indexOfExtendedX: 2 y: 4) equals: 34.	self assert: (d indexOfExtendedX: 3 y: 4) equals: 35.	self assert: (d indexOfExtendedX: 4 y: 4) equals: 36.! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 18:47'!testIndexOfNormalXY	| d |	d := SDiffuser2 new.	d privOrder: 4.	self assert: (d indexOfNormalX: 0 y: 0) equals: 1.	self assert: (d indexOfNormalX: 1 y: 0) equals: 2.	self assert: (d indexOfNormalX: 2 y: 0) equals: 3.	self assert: (d indexOfNormalX: 3 y: 0) equals: 4.	self assert: (d indexOfNormalX: 0 y: 1) equals: 5.	self assert: (d indexOfNormalX: 1 y: 1) equals: 6.	self assert: (d indexOfNormalX: 2 y: 1) equals: 7.	self assert: (d indexOfNormalX: 3 y: 1) equals: 8.	self assert: (d indexOfNormalX: 0 y: 2) equals: 9.	self assert: (d indexOfNormalX: 1 y: 2) equals: 10.	self assert: (d indexOfNormalX: 2 y: 2) equals: 11.	self assert: (d indexOfNormalX: 3 y: 2) equals: 12.	self assert: (d indexOfNormalX: 0 y: 3) equals: 13.	self assert: (d indexOfNormalX: 1 y: 3) equals: 14.	self assert: (d indexOfNormalX: 2 y: 3) equals: 15.	self assert: (d indexOfNormalX: 3 y: 3) equals: 16.! !!SDiffuser2Test methodsFor: 'tests-initialization' stamp: 'EiichiroIto 3/18/2019 10:32'!testInitialize	| d |	d := SDiffuser2 new.	self assert: d privOrder equals: 0.	self assert: d privNeighborSize equals: 0.! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/18/2019 10:29'!testNsum	| d x |	d := SDiffuser2 new.	d privOrder: 4.	d setupNeighbor.	d privNeighborSize: 8." 1  2  3  0  1  2 3  0  1  2  3  0    16 10 12 10 3  2  1  0  3  2 -> 10  9 16 12 1  0  1  3  2  0    14 10  9 11 2  3  1  0  1  2     8 12 14 11 1  0  2  3  1  0"	x := FloatArray new: 16.	d privExtended: #(1 2 3 0 1 2 3 0 1 2 3 0 3 2 1 0 3 2 1 0 1 3 2 0 2 3 1 0 1 2 1 0 2 3 1 0) asFloatArray.	d nsum: x.	self assertCollection: x equals: #(16 10 12 10 10 9 16 12 14 10 9 11 8 12 14 11) asFloatArray.! !!SDiffuser2Test methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/18/2019 10:08'!testNsumDstOrderNeighborSize	| d x |	d := SDiffuser2 new.	"0 0 0 0    0 5 0 00 5 0 0 -> 5 0 5 00 0 0 0    0 5 0 00 0 0 0    0 0 0 0"	x := FloatArray new: 16.	d nsum: #(0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0) asFloatArray dst: x order: 4 neighborSize: 4.	self assertCollection: x equals: #(0 5 0 0 5 0 5 0 0 5 0 0 0 0 0 0) asFloatArray.	"0 1 0 0    1 0 2 30 0 1 0 -> 0 4 0 10 2 0 0    2 0 3 30 0 0 3    3 3 3 0"	x := FloatArray new: 16.	d nsum: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray dst: x order: 4 neighborSize: 4.	self assertCollection: x equals: #(1 0 2 3 0 4 0 1 2 0 3 3 3 3 3 0) asFloatArray.	d := SDiffuser2 new.	"0 0 0 0    5 5 5 00 5 0 0 -> 5 0 5 00 0 0 0    5 5 5 00 0 0 0    0 0 0 0"	x := FloatArray new: 16.	d nsum: #(0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0) asFloatArray dst: x order: 4 neighborSize: 8.	self assertCollection: x equals: #(5 5 5 0 5 0 5 0 5 5 5 0 0 0 0 0) asFloatArray.	"0 1 0 0    4 1 5 40 0 1 0 -> 3 4 3 10 2 0 0    5 1 6 40 0 0 3    6 3 6 0"	x := FloatArray new: 16.	d nsum: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray dst: x order: 4 neighborSize: 8.	self assertCollection: x equals: #(4 1 5 4 3 4 3 1 5 1 6 4 6 3 6 0) asFloatArray! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 18:41'!testPrivExtended	| d |	d := SDiffuser2 new.	self assert: d privExtended isNil.	d privExtended: #(1 2 3).	self assertCollection: d privExtended equals: #(1 2 3).! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 18:42'!testPrivNeighbor	| d |	d := SDiffuser2 new.	self assert: d privNeighbor isNil.	d privNeighbor: #(1 2 3).	self assertCollection: d privNeighbor equals: #(1 2 3).! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 18:44'!testPrivNeighborSize	| d |	d := SDiffuser2 new.	self assert: d privNeighborSize equals: 0.	d privNeighborSize: 123.	self assertCollection: d privNeighborSize equals: 123.! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 18:43'!testPrivOrder	| d |	d := SDiffuser2 new.	self assert: d privOrder equals: 0.	d privOrder: 123.	self assertCollection: d privOrder equals: 123.! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/18/2019 09:59'!testRestoreExtended	| d x |	x := FloatArray new: 16.	d := SDiffuser2 new.	d privOrder: 4.	d privExtended: #(0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 2 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray.	d restoreExtended: x.	self assertCollection: x equals: #(0 1 1 1 0 1 2 1 0 1 1 1 0 0 0 0) asFloatArray."1 0 1 2 3 01 2 3 0 1 2     5  6  2  33 0 1 2 3 0 ->  0  1  2  61 2 3 0 1 2     4  3  0  23 2 1 0 3 2     4  2  2 101 0 3 2 1 1"	d privExtended: #(1 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 2 1 0 3 2 1 0 3 2 1 1) asFloatArray.	d restoreExtended: x.	self assertCollection: x equals: #(5 6 2 4 0 1 2 6 4 3 0 2 4 2 2 10) asFloatArray.! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 19:30'!testSetupBorder	| d |	d := SDiffuser2 new.	d privOrder: 4.	d privExtended: #(	 0  0  0  0  0  0	 0  1  2  3  4  0	 0  5  6  7  8  0	 0  9 10 11 12  0	 0 13 14 15 16  0	 0  0  0  0  0  0) asFloatArray.	d setupBorder.	self		assertCollection: d privExtended		equals: #(		16 13 14 15 16 13		 4  1  2  3  4  1		 8  5  6  7  8  5	 	12  9 10 11 12  9		16 13 14 15 16 13		 4  1  2  3  4  1) asFloatArray! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/18/2019 10:17'!testSetupDiffuseOrderNeighborSize	| d |	d := SDiffuser2 new.	d setupDiffuseOrder: 4 neighborSize: 4.	self assert: d privNeighborSize equals: 4.	self assert: d privOrder equals: 4.	self assert: (d privExtended allSatisfy: [ :each | each = 0 ]).! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 19:03'!testSetupExtended	| d |	d := SDiffuser2 new.	d privOrder: 4.	d allocateExtended: 36.	d setupExtended: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16).	self assert: (d privExtended isKindOf: FloatArray).	self assertCollection: d privExtended size equals: 36.	self		assertCollection: d privExtended		equals:			#(0 0 0 0 0 0 0 1 2 3 4 0 0 5 6 7 8 0 0 9 10 11 12 0 0 13 14 15 16 0 0 0 0 0 0 0)				asFloatArray! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/18/2019 10:19'!testSetupNSumSrcOrderNeighborSize	| d |	d := SDiffuser2 new.	d		setupNSumSrc: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16) asFloatArray		order: 4		neighborSize: 4.	self assert: d privNeighborSize equals: 4.	self assert: d privOrder equals: 4.	self		assertCollection: d privExtended		equals:			#(16 13 14 15 16 13 4 1 2 3 4 1 8 5 6 7 8 5 12 9 10 11 12 9 16 13 14 15 16 13 4 1 2 3 4 1)				asFloatArray.! !!SDiffuser2Test methodsFor: 'tests-private' stamp: 'EiichiroIto 3/17/2019 18:58'!testSetupNeighbor	| d |	d := SDiffuser2 new.	self assert: d privNeighbor isNil.	d privOrder: 4.	d setupNeighbor.	self assert: d privNeighbor isArray.	self assert: d privNeighbor size equals: 8.	self assertCollection: d privNeighbor equals: #(1 -1 6 -6 5 7 -5 -7).! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/25/2018 19:58'!testBorders	| d |	d := SDiffuser neighbor4.	self assertCollection: d borders equals: #(top left right bottom).! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/25/2018 19:59'!testCorners	| d |	d := SDiffuser neighbor4.	self assertCollection: d corners equals: #(topLeft topRight bottomLeft bottomRight).! !!SDiffuserTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/17/2018 18:24'!testDiffuseArray	| d ret |	d := SDiffuser neighbor8.	d rows: 4 cols: 4.	ret := d diffuse: 80 array: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray.	self assertCollection: ret equals: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray."0 0  0 0    0 1  1 1 0 0 10 0 -> 0 1  2 1 0 0  0 0    0 1  1 1 0 0  0 0    0 0  0 0"	ret := d diffuse: 80 array: #(0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0) asFloatArray.	self assertCollection: ret equals: #(0 1 1 1 0 1 2 1 0 1 1 1 0 0 0 0) asFloatArray."0 0 0 0    0 0 0 0 0 0 0 0    1 1 0 110 0 0 0 -> 2 1 0 1 0 0 0 0    1 1 0 1"	ret := d diffuse: 80 array: #(0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0) asFloatArray.	self assertCollection: ret equals: #(0 0 0 0 1 1 0 1 2 1 0 1 1 1 0 1) asFloatArray."0 0 0 0    1 1 0 1 0 0 0 0    0 0 0 0 0 0 0 0 -> 1 1 0 110 0 0 0    2 1 0 1"	ret := d diffuse: 80 array: #(0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0) asFloatArray.	self assertCollection: ret equals: #(1 1 0 1 0 0 0 0 1 1 0 1 2 1 0 1) asFloatArray.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 19:06'!testDiffuseBorderAt	| d |	d := SDiffuser neighbor8.	d rows: 4 cols: 4." 0  0  0  0    1  0  1  1 0  0  0 10    1  0  1  2 0  0  0  0 -> 1  0  1  1 0  0  0  0    0  0  0  0"	d privSrc: #(0 0 0 0 0 0 0 10 0 0 0 0 0 0 0 0) asFloatArray.	d diffuseBorder: 80 at: #right.	self assertCollection: d result equals: #(1 0 1 1 1 0 1 2 1 0 1 1 0 0 0 0) asFloatArray." 0  0 10  0    0  1  2  1 0  0  0  0    0  1  1  1 0  0  0  0 -> 0  0  0  0 0  0  0  0    0  1  1  1"	d privSrc: #(0 0 10 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray.	d diffuseBorder: 80 at: #top.	self assertCollection: d result equals: #(0 1 2 1 0 1 1 1 0 0 0 0 0 1 1 1) asFloatArray."0 0 0 0    0 0 0 0 0 0 0 0    1 1 0 110 0 0 0 -> 2 1 0 1 0 0 0 0    1 1 0 1"	d privSrc: #(0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0) asFloatArray.	d diffuseBorder: 80 at: #left.	self assertCollection: d result equals: #(0 0 0 0 1 1 0 1 2 1 0 1 1 1 0 1) asFloatArray." 0  0  0  0     1  1  1  0 0  0  0  0 ->  0  0  0  0 0  0  0  0     1  1  1  0 0 10  0  0     1  2  1  0"	d privSrc: #(0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0) asFloatArray.	d diffuseBorder: 80 at: #bottom.	self assertCollection: d result equals: #(1 1 1 0 0 0 0 0 1 1 1 0 1 2 1 0) asFloatArray.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 19:06'!testDiffuseCornerAt	| d |	d := SDiffuser neighbor4.	d rows: 4 cols: 4."10  0  0  0    2  2  0  2 0  0  0  0    2  0  0  0 0  0  0  0 -> 0  0  0  0 0  0  0  0    2  0  0  0"	d privSrc: #(10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray.	d diffuseCorner: 80 at: #topLeft.	self assertCollection: d result equals: #(2 2 0 2 2 0 0 0 0 0 0 0 2 0 0 0) asFloatArray." 0  0  0 10    2  0  2  2 0  0  0  0    0  0  0  2 0  0  0  0 -> 0  0  0  0 0  0  0  0    0  0  0  2"	d privSrc: #(0 0 0 10 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray.	d diffuseCorner: 80 at: #topRight.	self assertCollection: d result equals: #(2 0 2 2 0 0 0 2 0 0 0 0 0 0 0 2) asFloatArray." 0  0  0  0    2  0  0  0 0  0  0  0    0  0  0  0 0  0  0  0 -> 2  0  0  010  0  0  0    2  2  0  2"	d privSrc: #(0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0) asFloatArray.	d diffuseCorner: 80 at: #bottomLeft.	self assertCollection: d result equals: #(2 0 0 0 0 0 0 0 2 0 0 0 2 2 0 2) asFloatArray." 0  0  0  0    0  0  0  2 0  0  0  0    0  0  0  0 0  0  0  0 -> 0  0  0  2 0  0  0 10    2  0  2  2"	d privSrc: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10) asFloatArray.	d diffuseCorner: 80 at: #bottomRight.	self assertCollection: d result equals: #(0 0 0 2 0 0 0 0 0 0 0 2 2 0 2 2) asFloatArray.	d := SDiffuser neighbor8.	d rows: 4 cols: 4."10  0  0  0    2  1  0  1 0  0  0  0    1  1  0  1 0  0  0  0 -> 0  0  0  0 0  0  0  0    1  1  0  1"	d privSrc: #(10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray.	d diffuseCorner: 80 at: #topLeft.	self assertCollection: d result equals: #(2 1 0 1 1 1 0 1 0 0 0 0 1 1 0 1) asFloatArray." 0  0  0 10    1  0  1  2 0  0  0  0    1  0  1  1 0  0  0  0 -> 0  0  0  0 0  0  0  0    1  0  1  1"	d privSrc: #(0 0 0 10 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray.	d diffuseCorner: 80 at: #topRight.	self assertCollection: d result equals: #(1 0 1 2 1 0 1 1 0 0 0 0 1 0 1 1) asFloatArray." 0  0  0  0    1  1  0  1 0  0  0  0    0  0  0  0 0  0  0  0 -> 1  1  0  110  0  0  0    2  1  0  1"	d privSrc: #(0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0) asFloatArray.	d diffuseCorner: 80 at: #bottomLeft.	self assertCollection: d result equals: #(1 1 0 1 0 0 0 0 1 1 0 1 2 1 0 1) asFloatArray." 0  0  0  0    1  0  1  1 0  0  0  0    0  0  0  0 0  0  0  0 -> 1  0  1  1 0  0  0 10    1  0  1  2"	d privSrc: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10) asFloatArray.	d diffuseCorner: 80 at: #bottomRight.	self assertCollection: d result equals: #(1 0 1 1 0 0 0 0 1 0 1 1 1 0 1 2) asFloatArray.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 19:06'!testDiffuseInner	| d |	d := SDiffuser neighbor8.	d rows: 4 cols: 4.	d privSrc: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0).	d diffuseInner: 80.	self assertCollection: d result equals: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray."0 0  0 0    0 1  1 1 0 0 10 0 -> 0 1  2 1 0 0  0 0    0 1  1 1 0 0  0 0    0 0  0 0"	d privSrc: #(0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0).	d diffuseInner: 80.	self assertCollection: d result equals: #(0 1 1 1 0 1 2 1 0 1 1 1 0 0 0 0) asFloatArray.! !!SDiffuserTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/25/2018 14:12'!testNsum	| d ret |	d := SDiffuser neighbor8.	d rows: 4 cols: 4."0 0 0 0    5 5 5 00 5 0 0 -> 5 0 5 00 0 0 0    5 5 5 00 0 0 0    0 0 0 0"	ret := d nsum: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray.	self assertCollection: ret equals: #(4 1 5 4 3 4 3 1 5 1 6 4 6 3 6 0) asFloatArray."0 1 0 0    4 1 5 40 0 1 0 -> 3 4 3 10 2 0 0    5 1 6 40 0 0 3    6 3 6 0"	ret := d nsum: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray.	self assertCollection: ret equals: #(4 1 5 4 3 4 3 1 5 1 6 4 6 3 6 0) asFloatArray.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/25/2018 19:35'!testNsumBorderAt	| d  |	d := SDiffuser neighbor8.	d rows: 4 cols: 4."0 1 0 0    0 1 5 00 0 1 0 -> 0 0 0 00 2 0 0    0 0 0 00 0 0 3    0 0 0 0"	d privSrc: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray.	d nsumBorderAt: #top.	self assertCollection: d result equals: #(0 1 5 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray."0 1 0 0    0 0 0 00 0 1 0 -> 3 0 0 00 2 0 0    5 0 0 00 0 0 3    0 0 0 0"	d privSrc:  #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray.	d nsumBorderAt: #left.	self assertCollection: d result equals: #(0 0 0 0 3 0 0 0 5 0 0 0 0 0 0 0) asFloatArray."0 1 0 0    0 0 0 00 0 1 0 -> 0 0 0 21 2 0 0    0 0 0 50 0 0 3    0 0 0 0"	d privSrc:  #(0 1 0 0 0 0 1 0 1 2 0 0 0 0 0 3) asFloatArray.	d nsumBorderAt: #right.	self assertCollection: d result equals: #(0 0 0 0 0 0 0 2 0 0 0 5 0 0 0 0) asFloatArray."0 1 0 0    0 0 0 00 0 1 0 -> 0 0 0 00 2 0 0    0 0 0 00 0 0 3    0 3 6 0"	d privSrc: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray.	d nsumBorderAt: #bottom.	self assertCollection: d result equals: #(0 0 0 0 0 0 0 0 0 0 0 0 0 3 6 0) asFloatArray.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/25/2018 14:08'!testNsumCornerAt	| d |	d := SDiffuser neighbor4.	d rows: 4 cols: 4."0 1 0 0    1 0 0 00 0 1 0 -> 0 0 0 00 2 0 0    0 0 0 00 0 0 3    0 0 0 0"	d privSrc: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray.	d nsumCornerAt: #topLeft.	self assertCollection: d result equals: #(1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray."0 1 0 0    0 0 0 30 0 1 0 -> 0 0 0 00 2 0 0    0 0 0 00 0 0 3    0 0 0 0"	d privSrc: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray.	d nsumCornerAt: #topRight.	self assertCollection: d result equals: #(0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray."0 1 0 0    0 0 0 00 0 1 0 -> 0 0 0 01 2 0 0    0 0 0 00 0 0 3    4 0 0 0"	d privSrc: #(0 1 0 0 0 0 1 0 1 2 0 0 0 0 0 3) asFloatArray.	d nsumCornerAt: #bottomLeft.	self assertCollection: d result equals: #(0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0) asFloatArray."0 1 1 0    0 0 0 00 0 1 0 -> 0 0 0 00 2 0 2    0 0 0 01 0 0 3    0 0 0 3"	d privSrc: #(0 1 1 0 0 0 1 0 0 2 0 2 1 0 0 3) asFloatArray.	d nsumCornerAt: #bottomRight.	self assertCollection: d result equals: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3) asFloatArray.	d := SDiffuser neighbor8.	d rows: 4 cols: 4."0 1 0 0    4 0 0 00 0 1 0 -> 0 0 0 00 2 0 0    0 0 0 00 0 0 3    0 0 0 0"	d privSrc: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray.	d nsumCornerAt: #topLeft.	self assertCollection: d result equals: #(4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray."0 1 0 0    0 0 0 40 0 1 0 -> 0 0 0 00 2 0 0    0 0 0 00 0 0 3    0 0 0 0"	d privSrc: #(0 1 0 0 0 0 1 0 0 2 0 0 0 0 0 3) asFloatArray.	d nsumCornerAt: #topRight.	self assertCollection: d result equals: #(0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0) asFloatArray."0 1 0 0    0 0 0 00 0 1 0 -> 0 0 0 01 2 0 0    0 0 0 00 0 0 3    7 0 0 0"	d privSrc: #(0 1 0 0 0 0 1 0 1 2 0 0 0 0 0 3) asFloatArray.	d nsumCornerAt: #bottomLeft.	self assertCollection: d result equals: #(0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0) asFloatArray."0 1 1 0    0 0 0 00 0 1 0 -> 0 0 0 00 2 0 2    0 0 0 01 0 0 3    0 0 0 1"	d privSrc: #(0 1 1 0 0 0 1 0 0 2 0 2 1 0 0 3) asFloatArray.	d nsumCornerAt: #bottomRight.	self assertCollection: d result equals: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4) asFloatArray.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/25/2018 19:57'!testNsumInner	| d |	d := SDiffuser neighbor8.	d rows: 4 cols: 4."0 0 0 0    0 0 0 00 0 1 0 -> 0 3 2 00 2 0 0    0 1 3 00 0 0 0    0 0 0 0"	d privSrc: #(0 0 0 0 0 0 1 0 0 2 0 0 0 0 0 0) asFloatArray.	d nsumInner.	self assertCollection: d result equals: #(0 0 0 0 0 3 2 0 0 1 3 0 0 0 0 0) asFloatArray.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 17:50'!testPrivCols	self testRowsCols.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 17:56'!testPrivCornerIndexes	self testSetupNeighbor4.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 18:21'!testPrivDst	self testResult.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 14:08'!testPrivIndexesDict	self testSetupIndexes.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 13:56'!testPrivNeighbor	self testSetupNeighbor4.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 17:50'!testPrivRows	self testRowsCols.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 19:07'!testPrivSrc	| d |	d := SDiffuser neighbor4.	self assert: d result isNil.	d privSrc: #(1 2 3).	self assertCollection: d privSrc equals: #(1 2 3).	self assertCollection: d result equals: #(0 0 0) asFloatArray.! !!SDiffuserTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/17/2018 18:21'!testResult	| d |	d := SDiffuser neighbor4.	self assert: d result isNil.	d privDst: 123.	self assert: d result equals: 123.	d privDst: 456.	self assert: d result equals: 456.! !!SDiffuserTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/17/2018 18:13'!testRowsCols	| d |	d := SDiffuser neighbor4.	self assert: d privRows isNil.	self assert: d privCols isNil.	d rows: 3 cols: 4.	self assert: d privRows equals: 3.	self assert: d privCols equals: 4.! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 19:06'!testSetupIndexes	| d dict bag |	d := SDiffuser neighbor8.	d rows: 5 cols: 5.	d setupIndexes.	d privSrc: #(1 2 3).	dict := d privIndexesDict.	"5 6 0 0 4 - 6 0 0 4 5 - 8 9 0 0 7 - 9 0 0 7 88 9 0 0 7 - 9 0 0 7 8 - 0 0 0 0 0 - 0 0 0 0 00 0 0 0 0 - 0 0 0 0 0 - 0 0 0 0 0 - 0 0 0 0 00 0 0 0 0 - 0 0 0 0 0 - 2 3 0 0 1 - 3 0 0 1 22 3 0 0 1 - 3 0 0 1 2 - 5 6 0 0 4 - 6 0 0 4 5"	self assertCollection: (dict at: #topLeft) equals: #(25 21 22 5 1 2 10 6 7).	self assertCollection: (dict at: #topRight) equals: #(24 25 21 4 5 1 9 10 6).	self assertCollection: (dict at: #bottomLeft) equals: #(20 16 17 25 21 22 5 1 2).	self assertCollection: (dict at: #bottomRight) equals: #(19 20 16 24 25 21 4 5 1).	" 6  7  8  9 10 - 11 12 13 14 1511 12 13 14 15 -  0  0  0  0  0 0  0  0  0  0 -  0  0  0  0  0 0  0  0  0  0 -  1  2  3  4  5 1  2  3  4  5 -  6  7  8  9 10"	self assertCollection: (dict at: #top) equals: #(21 22 23 24 25 1 2 3 4 5 6 7 8 9 10).	self		assertCollection: (dict at: #bottom)		equals: #(16 17 18 19 20 21 22 23 24 25 1 2 3 4 5).	" 6 11  0  0  1 - 11  0  0  1  6 7 12  0  0  2 - 12  0  0  2  7 8 13  0  0  3 - 13  0  0  3  8 9 14  0  0  4 - 14  0  0  4  910 15  0  0  5 - 15  0  0  5 10"	self		assertCollection: (dict at: #left)		equals: #(5 10 15 20 25 1 6 11 16 21 2 7 12 17 22).	self		assertCollection: (dict at: #right)		equals: #(4 9 14 19 24 5 10 15 20 25 1 6 11 16 21).	self assertCollection: (dict at: #inner) equals: #(7 8 9 12 13 14 17 18 19).	bag := Bag new.	bag add: ((dict at: #topLeft) at: 5).	bag add: ((dict at: #topRight) at: 5).	bag add: ((dict at: #bottomLeft) at: 5).	bag add: ((dict at: #bottomRight) at: 5).	bag addAll: ((dict at: #top) copyFrom: 7 to: 9).	bag addAll: ((dict at: #left) copyFrom: 7 to: 9).	bag addAll: ((dict at: #right) copyFrom: 7 to: 9).	bag addAll: ((dict at: #bottom) copyFrom: 7 to: 9).	bag addAll: (dict at: #inner).	self assert: bag size equals: 25.	1 to: 25 do: [ :each | 		self assert: (bag includes: each).		self assert: (bag occurrencesOf: each) equals: 1 ].! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 18:14'!testSetupNeighbor4	| d |	d := SDiffuser neighbor4.	d rows: 5 cols: 6.	d setupNeighbor4.	self assertCollection: d privNeighbor equals: #(1 -1 -5 5).	self assertCollection: d privCornerIndexes equals: #(2 4 6 8).! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 18:14'!testSetupNeighbor8	| d |	d := SDiffuser neighbor8.	d rows: 5 cols: 6.	d setupNeighbor8.	self assertCollection: d privNeighbor equals: #(1 -1 -6 -5 -4 4 5 6).	self assertCollection: d privCornerIndexes equals: #(1 2 3 4 6 7 8 9).! !!SDiffuserTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/17/2018 18:11'!testSetupSelector	| d |	d := SDiffuser neighbor4.	self assert: d setupSelector equals: #setupNeighbor4.	d setupSelector: #abc.	self assert: d setupSelector equals: #abc.	d := SDiffuser neighbor8.	self assert: d setupSelector equals: #setupNeighbor8.! !!SDisplayTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 12/1/2019 13:03'!testUpdateCache	| d w |	w := SMicroWorld new.	w addBreed: SObserver new.	w addBreed: SPatches new.	d := SDisplay sworld: w.	self assert: d extent equals: 220 @ 220.	self assert: w extent equals: 100 @ 100.	d updateCache.	self assert: d privCell equals: 2 @ 2.	self assert: d privOffset equals: 10 @ 10.	d extent: 150 @ 120.	d updateCache.	self assert: d privCell equals: 1 @ 1.	self assert: d privOffset equals: 25 @ 10.! !!SEntryPointsTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 10:50'!testAddEntryPointForBreedNo	| p |	p := SEntryPoints new.	p addEntryPoint: 5 forBreedNo: 1.	p addEntryPoint: 6 forBreedNo: 2.	p addEntryPoint: 7 forBreedNo: 3.	p addEntryPoint: 8 forBreedNo: 1.	p addEntryPoint: 9 forBreedNo: 3.	self assertCollection: p breedNoList equals: #(1 2 3).	self assertCollection: (p forBreedNo: 1) asArray equals: #(5 8).	self assertCollection: (p forBreedNo: 2) asArray equals: #(6).	self assertCollection: (p forBreedNo: 3) asArray equals: #(7 9).! !!SEntryPointsTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 10:50'!testBreedNoList	| e |	e := SEntryPoints new.	self assert: e breedNoList isEmpty.	e addEntryPoint: 1 forBreedNo: 7.	e addEntryPoint: 2 forBreedNo: 2.	e addEntryPoint: 1 forBreedNo: 7.	self assertCollection: e breedNoList sort equals: #(2 7).! !!SEntryPointsTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 14:55'!testEntryPointList	| e ret |	e := SEntryPoints new.	self assert: e breedNoList isEmpty.	e addEntryPoint: 5 forBreedNo: 7.	e addEntryPoint: 2 forBreedNo: 2.	e addEntryPoint: 1 forBreedNo: 7.	ret := e entryPointList.	self assert: ret isArray.	self assert: ret size equals: 3.	self assertCollection: ret first equals: #(2 2).	self assertCollection: ret second equals: #(7 5).	self assertCollection: ret third equals: #(7 1).! !!SEntryPointsTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 9/11/2019 10:50'!testForBreedNo	| c l |	c := SEntryPoints new.	c addEntryPoint: 1 forBreedNo: 1.	c addEntryPoint: 4 forBreedNo: 2.	c addEntryPoint: 7 forBreedNo: 3.	c addEntryPoint: 10 forBreedNo: 2.	l := c forBreedNo: 1.	self assert: l isCollection.	self assert: l size equals: 1.	self assertCollection: l asArray equals: #(1).	l := c forBreedNo: 2.	self assert: l isCollection.	self assert: l size equals: 2.	self assertCollection: l asArray equals: #(4 10).	l := c forBreedNo: 3.	self assert: l isCollection.	self assert: l size equals: 1.	self assertCollection: l asArray equals: #(7).! !!SEntryPointsTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 3/14/2019 11:55'!testInitialize	self testPrivBreeds.! !!SEntryPointsTest methodsFor: 'tests-testing' stamp: 'EiichiroIto 9/11/2019 10:50'!testIsEmpty	| c |	c := SEntryPoints new.	self assert: c isEmpty.	c addEntryPoint: 2 forBreedNo: 1.	self deny: c isEmpty.! !!SEntryPointsTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 10:50'!testPrintOn	| p w |	p := SEntryPoints new.	p addEntryPoint: 5 forBreedNo: 1.	p addEntryPoint: 6 forBreedNo: 2.	p addEntryPoint: 7 forBreedNo: 3.	p addEntryPoint: 8 forBreedNo: 1.	p addEntryPoint: 9 forBreedNo: 3.	w := WriteStream on: String new.	p printOn: w.	self assert: w contents equals: '(1->(5 8) 2->(6) 3->(7 9))'! !!SEntryPointsTest methodsFor: 'tests-private' stamp: 'EiichiroIto 9/11/2019 10:50'!testPrivBreeds	| c |	c := SEntryPoints new.	self assert: c privBreeds isDictionary.	self assert: c privBreeds isEmpty.! !!SExporterTest methodsFor: 'tests-private' stamp: 'EiichiroIto 4/9/2019 19:26'!testEventIdFor	| e d |	e := SExporter new.	d := Dictionary new.	d at: #a put: 1.	d at: #b put: 2.	e privEvents: d.	self assert: (e eventIdFor: #a) equals: 1.	self assert: (e eventIdFor: #b) equals: 2.! !!SExporterTest methodsFor: 'tests-private' stamp: 'EiichiroIto 4/9/2019 19:24'!testPrivEvents	| e d |	e := SExporter new.	self assert: e privEvents isNil.	d := Dictionary new.	e privEvents: d.	self assert: e privEvents equals: d.	! !!SExporterTest methodsFor: 'tests-private' stamp: 'EiichiroIto 4/9/2019 19:24'!testPrivStream	| e s |	e := SExporter new.	self assert: e privStream isNil.	s := WriteStream on: ''.	e privStream: s.	self assert: e privStream equals: s.! !!SMicroWorldTest methodsFor: 'private' stamp: 'EiichiroIto 12/1/2019 13:03'!newWorld	| w |	w := SMicroWorld new.	w addBreed: SObserver new.	w addBreed: SPatches new.	w newBreed.	^ w! !!SMicroWorldTest methodsFor: 'tests-command' stamp: 'EiichiroIto 11/28/2019 22:09'!testAimHighPatchVarBreedId	| w v ret |	w := self newWorld.	w createPatch: 5.	w create: 3 turtles: 1.	v := w patches addVariable: 'a'.	"	21 22 23 24 25	16 17 18 19 20	11 12 13 14 15	 6  7  8  9 10	 1  2  3  4  5"	w x: 3 at: 1 put: 0.	w y: 3 at: 1 put: 0.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 45.	w		var: v		breed: 2		at: 18		put: 1.	w		var: v		breed: 2		at: 19		put: 2.	w		var: v		breed: 2		at: 14		put: 3.	ret := w aimHighPatchVar: v breed: 3 id: 1.	self assert: ret equals: -45.	w		var: v		breed: 2		at: 18		put: 4.	w		var: v		breed: 2		at: 19		put: 3.	w		var: v		breed: 2		at: 14		put: 2.	ret := w aimHighPatchVar: v breed: 3 id: 1.	self assert: ret equals: 45.	w		var: v		breed: 2		at: 18		put: 4.	w		var: v		breed: 2		at: 19		put: 5.	w		var: v		breed: 2		at: 14		put: 2.	ret := w aimHighPatchVar: v breed: 3 id: 1.	self assert: ret equals: 0.	"	21 22 23 24 25	16 17 18 19 20	11 12 13 14 15	 6  7  8  9 10	 1  2  3  4  5"	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 90.	w		var: v		breed: 2		at: 16		put: 1.	w		var: v		breed: 2		at: 17		put: 1.	w		var: v		breed: 2		at: 18		put: 2.	w		var: v		breed: 2		at: 19		put: 3.	w		var: v		breed: 2		at: 20		put: 3.	ret := w aimHighPatchVar: v breed: 3 id: 1.	self assert: ret equals: -45! !!SMicroWorldTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 18:21'!testBreedsOf	| w |	w := SMicroWorld new.	w addBreed: (STurtles new breedNo: 3).	self assert: (w breedOf: 3) class equals: STurtles.! !!SMicroWorldTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/9/2018 16:43'!testClearRaisedEvents	| w |	w := SMicroWorld new.	self assert: w privRaisedEvents isEmpty.	w raiseEvent: #a.	self assert: w privRaisedEvents notEmpty.	w clearRaisedEvents.	self assert: w privRaisedEvents isEmpty.! !!SMicroWorldTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/27/2019 16:51'!testColors	| w |	w := self newWorld.	w createPatch: 3.	self assertCollection: w colors equals: #[0 0 0 0 0 0 0 0 0].	w create: 3 turtles: 1.	(w breedOf: 3) colorAt: 1 put: 12.	self assertCollection: w colors equals: #[0 0 0 0 12 0 0 0 0].	w patches colorAt: 1 put: 23.	self assertCollection: w colors equals: #[23 0 0 0 12 0 0 0 0]! !!SMicroWorldTest methodsFor: 'tests' stamp: 'EiichiroIto 9/13/2019 22:45'!testCountAliveOfBreedNo	| w |	w := self newWorld.	w create: 3 turtles: 10.	w newBreed.	w create: 4 turtles: 15.	self assert: (w countAliveOf: 3) equals: 10.	self assert: (w countAliveOf: 4) equals: 15.	w createPatch: 10.	self assert: (w countAliveOf: 2) equals: 100.! !!SMicroWorldTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/27/2019 16:51'!testExtent	| w |	w := self newWorld.	w createPatch: 10.	self assert: w extent equals: 10 @ 10.	w createPatch: 20.	self assert: w extent equals: 20 @ 20.! !!SMicroWorldTest methodsFor: 'tests-command' stamp: 'EiichiroIto 11/28/2019 22:09'!testForwardBreedId	| w |	w := self newWorld.	w createPatch: 100.	w create: 3 turtles: 1.	(w breedOf: 3) headingAt: 1 put: 0.	w x: 3 at: 1 put: 49.	w forward: 1 breed: 3 id: 1.	self		assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1)		closeTo: -50.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) closeTo: 0.	w x: 3 at: 1 put: 49.1.	w forward: 1 breed: 3 id: 1.	self		assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1)		closeTo: -49.9.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) closeTo: 0.	w x: 3 at: 1 put: 49.9.	w forward: 1 breed: 3 id: 1.	self		assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1)		closeTo: -49.1.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) closeTo: 0.	w x: 3 at: 1 put: 50.	w forward: 1 breed: 3 id: 1.	self		assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1)		closeTo: -49.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) closeTo: 0.	(w breedOf: 3) headingAt: 1 put: 90.	w x: 3 at: 1 put: 49.	w y: 3 at: 1 put: 49.	w forward: 1 breed: 3 id: 1.	self		assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1)		closeTo: 49.	self		assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1)		closeTo: -50.	w y: 3 at: 1 put: 49.1.	w forward: 1 breed: 3 id: 1.	self		assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1)		closeTo: 49.	self		assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1)		closeTo: -49.9.	w y: 3 at: 1 put: 49.9.	w forward: 1 breed: 3 id: 1.	self		assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1)		closeTo: 49.	self		assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1)		closeTo: -49.1.	w y: 3 at: 1 put: 50.	w forward: 1 breed: 3 id: 1.	self		assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1)		closeTo: 49.	self		assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1)		closeTo: -49! !!SMicroWorldTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 17:50'!testMaxBreedNo	| w |	w := self newWorld.	self assert: w maxBreedNo equals: 3.	5 timesRepeat: [ w newBreed ].	self assert: w maxBreedNo equals: 8! !!SMicroWorldTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 11:45'!testObserver	| w |	w := self newWorld.	self assert: w observer class equals: SObserver.! !!SMicroWorldTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 11:45'!testPatches	| w |	w := self newWorld.	self assert: w patches class equals: SPatches.! !!SMicroWorldTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/11/2019 14:29'!testPrivBreeds	| w |	w := self newWorld.	self assert: w privBreeds isArray.	self assert: (w privBreeds at: 1) class equals: SObserver.	self assert: (w privBreeds at: 2) class equals: SPatches.	self assert: (w privBreeds at: 3) class equals: STurtles.! !!SMicroWorldTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/9/2018 16:42'!testPrivRaisedEvents	| w |	w := SMicroWorld new.	self assert: w privRaisedEvents isEmpty.	w privRaisedEvents: #(1 2 3).	self assertCollection: w privRaisedEvents equals: #(1 2 3).	w privRaisedEvents: #(4 5 6).	self assertCollection: w privRaisedEvents equals: #(4 5 6).! !!SMicroWorldTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 10/9/2018 16:42'!testRaiseEvent	| w |	w := SMicroWorld new.	self assert: w privRaisedEvents isEmpty.	w raiseEvent: #a.	self assertCollection: w privRaisedEvents asArray equals: #(a).	w raiseEvent: #b.	self assert: w privRaisedEvents size equals: 2.	self assert: (w privRaisedEvents includes: #a).	self assert: (w privRaisedEvents includes: #b).! !!SMicroWorldTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 9/18/2018 17:17'!testRaisedEvents	| w |	w := SMicroWorld new.	self assert: w raisedEvents isEmpty.	w raiseEvent: #a.	self assertCollection: w raisedEvents asArray equals: #(a).	w raiseEvent: #b.	self assert: w raisedEvents size equals: 2.	self assert: (w raisedEvents includes: #a).	self assert: (w raisedEvents includes: #b).! !!SObserverTest methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 11:46'!newWorld	| w |	w := SMicroWorld new.	w addBreed: (SObserver new sworld: w).	w addBreed: SPatches new.	w newBreed.	^ w! !!SObserverTest methodsFor: 'test' stamp: 'EiichiroIto 8/8/2019 07:21'!testBreedNo	| o |	o := SObserver new.	self assert: o breedNo equals: SBreedId observerBreedNo.	o breedNo: 123.	self assert: o breedNo equals: SBreedId observerBreedNo.! !!SObserverTest methodsFor: 'test' stamp: 'EiichiroIto 9/3/2019 21:56'!testClearTicks	| o |	o := SObserver new.	self assert: o ticks equals: 0.	o incrementTicks.	self assert: o ticks equals: 1.	o incrementTicks.	self assert: o ticks equals: 2.	o clearTicks.	self assert: o ticks equals: 0.! !!SObserverTest methodsFor: 'test' stamp: 'EiichiroIto 9/3/2019 21:55'!testIncrementTicks	| o |	o := SObserver new.	self assert: o ticks equals: 0.	o incrementTicks.	self assert: o ticks equals: 1.	o incrementTicks.	self assert: o ticks equals: 2.! !!SObserverTest methodsFor: 'test' stamp: 'EiichiroIto 9/3/2019 21:51'!testTicks	| o |	o := SObserver new.	self assert: o ticks equals: 0.! !!SObserverVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testCountAliveVarNo	self assert: SObserverVarDef countAliveVarNo equals: 5.! !!SObserverVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testHeightVarNo	self assert: SObserverVarDef heightVarNo equals: 2.! !!SObserverVarDefTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 11/28/2019 22:20'!testInitialize	| o |	o := SObserverVarDef new.	self assert: o size equals: 7.	self assert: (o varNoFor: 'width') equals: SObserverVarDef widthVarNo.	self assert: (o varNoFor: 'height') equals: SObserverVarDef heightVarNo.	self assert: (o varNoFor: 'maxBreedNo') equals: SObserverVarDef maxBreedNoVarNo.	self assert: (o varNoFor: 'ticks') equals: SObserverVarDef ticksVarNo.	self assert: (o varNoFor: 'countAlive') equals: SObserverVarDef countAliveVarNo.	self assert: (o varNoFor: 'size') equals: SObserverVarDef sizeVarNo.	self assert: (o varNoFor: 'maxVar') equals: SObserverVarDef maxVarVarNo.! !!SObserverVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:20'!testMaxBreedNoVarNo	self assert: SObserverVarDef maxBreedNoVarNo equals: 3.! !!SObserverVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:20'!testMaxVarVarNo	self assert: SObserverVarDef maxVarVarNo equals: 7.! !!SObserverVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:19'!testReservedVarNames	self		assertCollection: SObserverVarDef new privReservedVarNames		equals: #(width height maxBreedNo ticks countAlive size maxVar)! !!SObserverVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testSizeVarNo	self assert: SObserverVarDef sizeVarNo equals: 6.! !!SObserverVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testTicksVarNo	self assert: SObserverVarDef ticksVarNo equals: 4.! !!SObserverVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testWidthVarNo	self assert: SObserverVarDef widthVarNo equals: 1.! !!SPatchVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:18'!testClassNameForVarNo	| pv |	pv := SPatchVarDef new.	self assert: (pv classNameForVarNo: SPatchVarDef colorVarNo) equals: #ByteArray.	self assert: (pv classNameForVarNo: SPatchVarDef screenVarNo) equals: #ByteArray.	self assert: (pv classNameForVarNo: SPatchVarDef xVarNo) equals: #FloatArray.	self assert: (pv classNameForVarNo: SPatchVarDef yVarNo) equals: #FloatArray! !!SPatchVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testColorVarNo	| v |	v := SPatchVarDef new.	self assert: (v varNoFor: 'color') equals: SPatchVarDef colorVarNo.! !!SPatchVarDefTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 11/28/2019 22:09'!testInitialize	| v |	v := SPatchVarDef new.	self assert: v privVarNames size equals: 4.	self assert: (v includes: 'color').	self assert: (v includes: 'screen').	self assert: (v includes: 'x').	self assert: (v includes: 'y').! !!SPatchVarDefTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/28/2019 22:16'!testReservedVarNames	self assertCollection: SPatchVarDef new privReservedVarNames equals: #(color screen x y).! !!SPatchVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testScreenVarNo	| v |	v := SPatchVarDef new.	self assert: (v varNoFor: 'screen') equals: SPatchVarDef screenVarNo.! !!SPatchVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testXVarNo	| v |	v := SPatchVarDef new.	self assert: (v varNoFor: 'x') equals: SPatchVarDef xVarNo.! !!SPatchVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testYVarNo	| v |	v := SPatchVarDef new.	self assert: (v varNoFor: 'y') equals: SPatchVarDef yVarNo.! !!SPatchesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 3/15/2019 19:56'!testAimHighVarNoAtPointDirection	| ps v ret |	ps := SPatches new.	ps create: 5.	v := ps addVariable: 'a'.	"	21 22 23 24 25	16 17 18 19 20	11 12 13 14 15	 6  7  8  9 10	 1  2  3  4  5"	ps var: v at: 18 put: 1.	ps var: v at: 19 put: 2.	ps var: v at: 14 put: 3.	ret := ps aimHighVarNo: v atPoint: 0 @ 0 direction: 45.	self assert: ret equals: -45.	ps var: v at: 18 put: 4.	ps var: v at: 19 put: 3.	ps var: v at: 14 put: 2.	ret := ps aimHighVarNo: v atPoint: 0 @ 0 direction: 45.	self assert: ret equals: 45.	ps var: v at: 18 put: 4.	ps var: v at: 19 put: 5.	ps var: v at: 14 put: 2.	ret := ps aimHighVarNo: v atPoint: 0 @ 0 direction: 45.	self assert: ret equals: 0.	"	21 22 23 24 25	16 17 18 19 20	11 12 13 14 15	 6  7  8  9 10	 1  2  3  4  5"	ps var: v at: 17 put: 1.	ps var: v at: 18 put: 2.	ps var: v at: 19 put: 3.	ret := ps aimHighVarNo: v atPoint: 0 @ 0 direction: 90.	self assert: ret equals: -45.	ps var: v at: 16 put: 3.	ps var: v at: 17 put: 3.	ps var: v at: 18 put: 2.	ps var: v at: 19 put: 1.	ps var: v at: 20 put: 1.	ret := ps aimHighVarNo: v atPoint: 0 @ 0 direction: 90.	self assert: ret equals: 45! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 07:21'!testBreedNo	| o |	o := SPatches new.	self assert: o breedNo equals: SBreedId patchBreedNo.	o breedNo: 123.	self assert: o breedNo equals: SBreedId patchBreedNo.! !!SPatchesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 11/28/2019 22:09'!testClear	| ps cs v |	ps := SPatches new.	ps create: 3.	cs := ps privVariables realArrayAt: SPatchVarDef colorVarNo.	1 to: 9 do: [ :each | cs at: each put: each ].	v := ps addVariable: 'a'.	1 to: 9 do: [ :each | ps var: v at: each put: 5 ].	self assertCollection: cs class equals: ByteArray.	self assertCollection: cs asArray equals: #(1 2 3 4 5 6 7 8 9).	self		assertCollection: (ps privVariables realArrayAt: v)		equals: #(5 5 5 5 5 5 5 5 5) asFloatArray.	ps clear.	self assertCollection: (ps privVariables realArrayAt: SPatchVarDef colorVarNo) equals: #(0 0 0 0 0 0 0 0 0) asByteArray.	self		assertCollection: (ps privVariables realArrayAt: v)		equals: #(0 0 0 0 0 0 0 0 0) asFloatArray! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testColorAtPoint	| ps |	ps := SPatches new.	ps create: 3.	ps privVariables setVar: SPatchVarDef colorVarNo toArray: #[2 0 0 0 1 0 0 3 4].	self assert: (ps colorAtPoint: 0 @ 0) equals: 1.	self assert: (ps colorAtPoint: -1 @ -1) equals: 2.	self assert: (ps colorAtPoint: 0 @ 1) equals: 3.	self assert: (ps colorAtPoint: 1 @ 1) equals: 4.! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 14:40'!testColorAtPointPut	| ps |	ps := SPatches new.	ps create: 3.	self assertCollection: ps colors asArray equals: #(0 0 0 0 0 0 0 0 0).	ps colorAtPoint: 0 @ 0 put: 1.	ps colorAtPoint: -1 @ -1 put: 2.	ps colorAtPoint: 0 @ 1 put: 3.	ps colorAtPoint: 1 @ 1 put: 4.	self assertCollection: ps colors asArray equals: #(2 0 0 0 1 0 0 3 4).! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 9/14/2018 14:24'!testColorVariable	| ps |	ps := SPatches new.	ps create: 3.	self assert: ps colors size equals: 9.	self assert: (ps colors allSatisfy: [ :each | each = 0 ]).! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 14:34'!testCols	| ps |	ps := SPatches new.	self assert: ps cols equals: ps defaultOrder.	ps create: 120.	self assert: ps cols equals: 120.! !!SPatchesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 9/28/2019 19:09'!testCreate	| ps |	ps := SPatches new.	ps create: 4.	self assert: (ps privVariables realArrayAt: 1) size equals: 16.! !!SPatchesTest methodsFor: 'tests-enumerating' stamp: 'EiichiroIto 3/16/2019 18:13'!testDeadOnesDo	"do nothing"! !!SPatchesTest methodsFor: 'tests-private' stamp: 'EiichiroIto 3/13/2019 14:34'!testDefaultOrder	| ps |	ps := SPatches new.	self assert: ps defaultOrder equals: 100.! !!SPatchesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 9/28/2019 19:16'!testDiffuse4VarNo	| ps v |	ps := SPatches new.	ps create: 3.	v := ps addVariable: 'a'.	ps var: v at: 5 put: 100.	self		assertCollection: (ps privVariables realArrayAt: v)		equals: #(0 0 0 0 100 0 0 0 0) asFloatArray.	ps diffuse4: 80 varNo: v.	self		assertCollection: (ps privVariables realArrayAt: v)		equals: #(0 20 0 20 20 20 0 20 0) asFloatArray! !!SPatchesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 9/28/2019 19:16'!testDiffuse8VarNo	| ps v |	ps := SPatches new.	ps create: 3.	v := ps addVariable: 'a'.	ps var: v at: 5 put: 100.	self		assertCollection: (ps privVariables realArrayAt: v)		equals: #(0 0 0 0 100 0 0 0 0) asFloatArray.	ps diffuse8: 80 varNo: v.	self		assertCollection: (ps privVariables realArrayAt: v)		equals: #(10 10 10 10 20 10 10 10 10) asFloatArray! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 14:34'!testExtent	| ps |	ps := SPatches new.	self assert: ps extent equals: (1 @ 1) * ps defaultOrder.	ps create: 120.	self assert: ps extent equals: 120 @ 120.! !!SPatchesTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/27/2019 15:46'!testIndexAtColRow	| ps |	ps := SPatches new.	self assert: ps cols equals: 100.	self assert: (ps indexAtCol: 1 row: 1) equals: 1.	self assert: (ps indexAtCol: 1 row: 2) equals: 101.	self assert: (ps indexAtCol: 100 row: 1) equals: 100.	self assert: (ps indexAtCol: 2 row: 1) equals: 2.	self assert: (ps indexAtCol: 100 row: 100) equals: 10000.! !!SPatchesTest methodsFor: 'tests-private' stamp: 'EiichiroIto 3/13/2019 14:27'!testIndexAtPoint	| ps |	ps := SPatches new.	ps create: 5.	self assert: ps cols equals: 5.	self assert: ps rows equals: 5.	self assert: (ps indexAtPoint: -2 @ -2) equals: 1.	self assert: (ps indexAtPoint: -1.9 @ -2) equals: 1.	self assert: (ps indexAtPoint: -1.1 @ -2) equals: 1.	self assert: (ps indexAtPoint: -1 @ -2) equals: 2.	self assert: (ps indexAtPoint: -0.9 @ -2) equals: 2.	self assert: (ps indexAtPoint: -0.1 @ -2) equals: 2.	self assert: (ps indexAtPoint: 0 @ -2) equals: 3.	self assert: (ps indexAtPoint: 0.1 @ -2) equals: 3.	self assert: (ps indexAtPoint: 0.9 @ -2) equals: 3.	self assert: (ps indexAtPoint: 1 @ -2) equals: 4.	self assert: (ps indexAtPoint: 2 @ -2) equals: 5.	self assert: (ps indexAtPoint: 2.1 @ -2) equals: 5.	self assert: (ps indexAtPoint: 2.9 @ -2) equals: 5.	self assert: (ps indexAtPoint: -1 @ 1) equals: 17.	self assert: (ps indexAtPoint: -0.9 @ 1) equals: 17.	self assert: (ps indexAtPoint: 0 @ 0) equals: 13.	self assert: (ps indexAtPoint: 0.1 @ 0) equals: 13.	self assert: (ps indexAtPoint: 0.9 @ 0) equals: 13.	self assert: (ps indexAtPoint: 2 @ 2) equals: 25.	ps create: 6.	self assert: ps cols equals: 6.	self assert: ps rows equals: 6.	self assert: (ps indexAtPoint: 0 @ 0) equals: 22.	self assert: (ps indexAtPoint: -3 @ -3) equals: 1.	self assert: (ps indexAtPoint: 2 @ 2) equals: 36.	self assert: (ps indexAtPoint: -1 @ 1) equals: 27.	ps create: 100.	self assert: (ps indexAtPoint: -50 @ -50) equals: 1.	self assert: (ps indexAtPoint: -49.5 @ -50) equals: 1.	self assert: (ps indexAtPoint: -49 @ -50) equals: 2.! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/16/2019 19:19'!testIndexAtXY	| ps |	ps := SPatches new.	ps create: 5.	self assert: ps cols equals: 5.	self assert: ps rows equals: 5.	self assert: (ps indexAtX: -2 y: -2) equals: 1.	self assert: (ps indexAtX: -1 y: -2) equals: 2.	self assert: (ps indexAtX: 0 y: -2) equals: 3.	self assert: (ps indexAtX: 1 y: -2) equals: 4.	self assert: (ps indexAtX: 2 y: -2) equals: 5.	self assert: (ps indexAtX: -3 y: -2) equals: 5.	self assert: (ps indexAtX: -2 y: -1) equals: 6.	self assert: (ps indexAtX: -2 y: 0) equals: 11.	self assert: (ps indexAtX: -2 y: 1) equals: 16.	self assert: (ps indexAtX: -2 y: 2) equals: 21.	self assert: (ps indexAtX: -2 y: -3) equals: 21.! !!SPatchesTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 11/28/2019 22:09'!testInitialize	| ps |	ps := SPatches new.	self assert: ps varId class equals: SPatchVarDef.	self assert: ps privVariables class equals: Variables.	self assert: ps size equals: 10000.! !!SPatchesTest methodsFor: 'tests-enumerating' stamp: 'EiichiroIto 3/16/2019 18:13'!testLivingOnesDo	| ps count |	ps := SPatches new.	ps create: 5.	count := 0.	ps livingOnesDo: [ :each | count := count + 1 ].	self assert: count equals: 25.! !!SPatchesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 9/28/2019 19:17'!testMultiplyByVarNo	| ps v |	ps := SPatches new.	ps create: 3.	v := ps addVariable: 'a'.	ps var: v at: 3 put: 2.	ps var: v at: 4 put: 3.	ps var: v at: 5 put: 5.	ps var: v at: 8 put: 11.	self		assertCollection: (ps privVariables realArrayAt: v)		equals: #(0 0 2 3 5 0 0 11 0) asFloatArray.	ps multiplyBy: 7 varNo: v.	self		assertCollection: (ps privVariables realArrayAt: v)		equals: #(0 0 14 21 35 0 0 77 0) asFloatArray! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 14:37'!testNormalize	| ps r |	ps := SPatches new.	ps create: 7.	-3 to: 3 do: [ :each | 		r := ps normalize: each.		self assert: r equals: each ].	r := ps normalize: -4.	self assert: r equals: 3.	r := ps normalize: -5.	self assert: r equals: 2.	r := ps normalize: -7.	self assert: r equals: 0.	r := ps normalize: -10.	self assert: r equals: -3.	r := ps normalize: -11.	self assert: r equals: 3.	r := ps normalize: 4.	self assert: r equals: -3.	r := ps normalize: 5.	self assert: r equals: -2.	r := ps normalize: 7.	self assert: r equals: 0.	r := ps normalize: 10.	self assert: r equals: 3.	r := ps normalize: 11.	self assert: r equals: -3.	ps create: 8.	-4 to: 3 do: [ :each | 		r := ps normalize: each.		self assert: r equals: each ].	r := ps normalize: -5.	self assert: r equals: 3.	r := ps normalize: -8.	self assert: r equals: 0.	r := ps normalize: -12.	self assert: r equals: -4.	r := ps normalize: -13.	self assert: r equals: 3.	r := ps normalize: 4.	self assert: r equals: -4.	r := ps normalize: 8.	self assert: r equals: 0.	r := ps normalize: 11.	self assert: r equals: 3.	r := ps normalize: 12.	self assert: r equals: -4.	ps create: 100.	r := ps normalize: 49.	self assert: r equals: 49.	r := ps normalize: 49.1.	self assert: r equals: 49.1.	r := ps normalize: -49.9.	self assert: r closeTo: -49.9.	r := ps normalize: -50.	self assert: r equals: -50.	r := ps normalize: -50.1.	self assert: r equals: 49.9.! !!SPatchesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 9/28/2019 19:17'!testNsum4To	| ps v1 v2 |	ps := SPatches new.	ps create: 3.	v1 := ps addVariable: 'a'.	v2 := ps addVariable: 'b'.	ps var: v1 at: 2 put: 2.	ps var: v1 at: 7 put: 1.	self		assertCollection: (ps privVariables realArrayAt: v1)		equals: #(0 2 0 0 0 0 1 0 0) asFloatArray.	ps nsum4: v1 to: v2.	self		assertCollection: (ps privVariables realArrayAt: v2)		equals: #(3 0 2 1 2 0 0 3 1) asFloatArray! !!SPatchesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 9/28/2019 19:17'!testNsum8To	| ps v1 v2 |	ps := SPatches new.	ps create: 3.	v1 := ps addVariable: 'a'.	v2 := ps addVariable: 'b'.	"0 2 0    3 1 30 0 0 -> 3 3 31 0 0    2 3 3"	ps var: v1 at: 2 put: 2.	ps var: v1 at: 7 put: 1.	self		assertCollection: (ps privVariables realArrayAt: v1)		equals: #(0 2 0 0 0 0 1 0 0) asFloatArray.	ps nsum8: v1 to: v2.	self		assertCollection: (ps privVariables realArrayAt: v2)		equals: #(3 1 3 3 3 3 2 3 3) asFloatArray! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 14:40'!testOrder	| ps |	ps := SPatches new.	self assert: ps order equals: ps defaultOrder.	ps create: 120.	self assert: ps order equals: 120.! !!SPatchesTest methodsFor: 'tests-private' stamp: 'EiichiroIto 9/15/2018 17:48'!testPointOfRowCol	| ps pos |	ps := SPatches new.	ps create: 5.	pos := ps pointOfRow: 1 col: 1.	self assert: pos equals: -2 @ -2.	pos := ps pointOfRow: 5 col: 1.	self assert: pos equals: 2 @ -2.	pos := ps pointOfRow: 3 col: 3.	self assert: pos equals: 0 @ 0.	pos := ps pointOfRow: 5 col: 5.	self assert: pos equals: 2 @ 2.	ps create: 6.	pos := ps pointOfRow: 1 col: 1.	self assert: pos equals: -3 @ -3.	pos := ps pointOfRow: 6 col: 1.	self assert: pos equals: 2 @ -3.	pos := ps pointOfRow: 4 col: 4.	self assert: pos equals: 0 @ 0.	pos := ps pointOfRow: 6 col: 6.	self assert: pos equals: 2 @ 2.! !!SPatchesTest methodsFor: 'tests-printing' stamp: 'EiichiroIto 9/9/2018 09:20'!testPrintOn	| ps |	ps := SPatches new.	self assert: ps asString equals: 'Patches(100x100)'.	ps create: 10.	self assert: ps asString equals: 'Patches(10x10)'.! !!SPatchesTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 19:30'!testPrivVariables	| ps |	ps := SPatches new.	self assert: ps privVariables class equals: Variables! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/13/2019 14:34'!testRows	| ps |	ps := SPatches new.	self assert: ps rows equals: ps defaultOrder.	ps create: 120.	self assert: ps rows equals: 120.! !!SPatchesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 11/28/2019 22:09'!testVarAt	| ps |	ps := SPatches new.	ps clear.	ps create: 4.	self assert: (ps var: SPatchVarDef xVarNo at: 1) equals: -2.	self assert: (ps var: SPatchVarDef xVarNo at: 2) equals: -1.	self assert: (ps var: SPatchVarDef xVarNo at: 8) equals: 1.	self assert: (ps var: SPatchVarDef xVarNo at: 9) equals: -2.	self assert: (ps var: SPatchVarDef yVarNo at: 1) equals: -2.	self assert: (ps var: SPatchVarDef yVarNo at: 2) equals: -2.	self assert: (ps var: SPatchVarDef yVarNo at: 13) equals: 1.	self assert: (ps var: SPatchVarDef yVarNo at: 14) equals: 1.! !!SPatchesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 11/28/2019 22:09'!testVarAtPut	| ps |	ps := SPatches new.	ps clear.	ps create: 2.	ps var: SPatchVarDef screenVarNo at: 1 put: 2.	ps var: SPatchVarDef screenVarNo at: 2 put: 5.	ps var: SPatchVarDef colorVarNo at: 1 put: 100.	ps var: SPatchVarDef colorVarNo at: 2 put: 200.	self assert: (ps var: SPatchVarDef screenVarNo at: 1) equals: 2.	self assert: (ps var: SPatchVarDef screenVarNo at: 2) equals: 5.	self assert: (ps colorAt: 1) equals: 100.	self assert: (ps colorAt: 2) equals: (SColorList default normalize: 200).! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/18/2019 14:53'!testXAt	| ps |	ps := SPatches new."	 1  2  3  4   -2 -1 0 1	 5  6  7  8	 9 10 11 12	13 14 15 16"	ps create: 4.	self assert: (ps xAt: 1) equals: -2.	self assert: (ps xAt: 2) equals: -1.	self assert: (ps xAt: 3) equals: 0.	self assert: (ps xAt: 4) equals: 1.	self assert: (ps xAt: 5) equals: -2.	self assert: (ps xAt: 6) equals: -1.	self assert: (ps xAt: 7) equals: 0.	self assert: (ps xAt: 8) equals: 1.	self assert: (ps xAt: 9) equals: -2.	self assert: (ps xAt: 10) equals: -1.	self assert: (ps xAt: 11) equals: 0.	self assert: (ps xAt: 12) equals: 1.	self assert: (ps xAt: 13) equals: -2.	self assert: (ps xAt: 14) equals: -1.	self assert: (ps xAt: 15) equals: 0.	self assert: (ps xAt: 16) equals: 1."   1  2  3  4  5   -2 -1 0 1 2   6  7  8  9 10  11 12 13 14 15  16 17 18 19 20  21 22 23 24 25"	ps create: 5.	self assert: (ps xAt: 1) equals: -2.	self assert: (ps xAt: 2) equals: -1.	self assert: (ps xAt: 3) equals: 0.	self assert: (ps xAt: 4) equals: 1.	self assert: (ps xAt: 5) equals: 2.	self assert: (ps xAt: 21) equals: -2.	self assert: (ps xAt: 22) equals: -1.	self assert: (ps xAt: 23) equals: 0.	self assert: (ps xAt: 24) equals: 1.	self assert: (ps xAt: 25) equals: 2.! !!SPatchesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 3/18/2019 14:55'!testYAt	| ps |	ps := SPatches new."	 1  2  3  4   -2	 5  6  7  8   -1	 9 10 11 12    0	13 14 15 16    1"	ps create: 4.	self assert: (ps yAt: 1) equals: -2.	self assert: (ps yAt: 2) equals: -2.	self assert: (ps yAt: 3) equals: -2.	self assert: (ps yAt: 4) equals: -2.	self assert: (ps yAt: 5) equals: -1.	self assert: (ps yAt: 6) equals: -1.	self assert: (ps yAt: 7) equals: -1.	self assert: (ps yAt: 8) equals: -1.	self assert: (ps yAt: 9) equals: 0.	self assert: (ps yAt: 10) equals: 0.	self assert: (ps yAt: 11) equals: 0.	self assert: (ps yAt: 12) equals: 0.	self assert: (ps yAt: 13) equals: 1.	self assert: (ps yAt: 14) equals: 1.	self assert: (ps yAt: 15) equals: 1.	self assert: (ps yAt: 16) equals: 1."   1  2  3  4  5   -2   6  7  8  9 10   -1  11 12 13 14 15    0  16 17 18 19 20    1  21 22 23 24 25    2"	ps create: 5.	self assert: (ps yAt: 1) equals: -2.	self assert: (ps yAt: 6) equals: -1.	self assert: (ps yAt: 11) equals: 0.	self assert: (ps yAt: 16) equals: 1.	self assert: (ps yAt: 21) equals: 2.	self assert: (ps yAt: 5) equals: -2.	self assert: (ps yAt: 10) equals: -1.	self assert: (ps yAt: 15) equals: 0.	self assert: (ps yAt: 20) equals: 1.	self assert: (ps yAt: 25) equals: 2.! !!SPluginWorldTest methodsFor: 'running' stamp: 'EiichiroIto 8/21/2019 18:42'!setUp	super setUp.	SteloLibCall new reset.! !!SPluginWorldTest methodsFor: 'running' stamp: 'EiichiroIto 8/21/2019 18:42'!tearDown	super tearDown.	SteloLibCall new reset.! !!SPluginWorldTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testClearBreed	| c x t |	c := SPluginWorld new.	c createPatch: 10.	x := c var: SPatchVarDef colorVarNo breed: SBreedId patchBreedNo at: 1.	self assert: x equals: 0.	c var: SPatchVarDef colorVarNo breed: SBreedId patchBreedNo at: 1 put: 10.	x := c var: SPatchVarDef colorVarNo breed: SBreedId patchBreedNo at: 1.	self assert: x equals: 10.	c clearBreed: SBreedId patchBreedNo.	x := c var: SPatchVarDef colorVarNo breed: SBreedId patchBreedNo at: 1.	self assert: x equals: 0.	self assert: (c countAliveOf: SBreedId turtleBreedNo) equals: 0.	t := STurtles new breedNo: SBreedId turtleBreedNo.	c setupBreed: t.	self assert: (c countAliveOf: SBreedId turtleBreedNo) equals: 0.	c create: SBreedId turtleBreedNo turtles: 50.	self assert: (c countAliveOf: SBreedId turtleBreedNo) equals: 50.	c clearBreed: SBreedId turtleBreedNo.	self assert: (c countAliveOf: SBreedId turtleBreedNo) equals: 0.	self assert: (c sizeOf: SBreedId turtleBreedNo) equals: 100.! !!SPluginWorldTest methodsFor: 'test' stamp: 'EiichiroIto 9/16/2019 20:05'!testCountAliveOf	| c t |	c := SPluginWorld new.	c createPatch: 10.	self assert: (c countAliveOf: 2) equals: 100.	self assert: (c countAliveOf: 3) equals: 0.	t := STurtles new breedNo: 3.	c setupBreed: t.	self assert: (c countAliveOf: 3) equals: 0.	c create: 3 turtles: 50.	self assert: (c countAliveOf: 3) equals: 50.	c create: 3 turtles: 5.	self assert: (c countAliveOf: 3) equals: 55! !!SPluginWorldTest methodsFor: 'test' stamp: 'EiichiroIto 9/16/2019 20:14'!testCreatePatch	self testCountAliveOf.! !!SPluginWorldTest methodsFor: 'test' stamp: 'EiichiroIto 9/16/2019 20:13'!testCreateTurtles	self testCountAliveOf.! !!SPluginWorldTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testGetByteAllBreed	| w t arr |	w := SPluginWorld new.	t := STurtles new breedNo: 3.	t create: 2.	w setupBreed: t.	arr := w getByteAll: STurtleVarDef colorVarNo breed: 3.	self assert: arr size equals: 100.	self assert: arr first equals: (t colorAt: 1).	self assert: arr second equals: (t colorAt: 2).	self assert: arr third equals: (t colorAt: 3).! !!SPluginWorldTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testGetFloatAllBreed	| w t arr |	w := SPluginWorld new.	t := STurtles new breedNo: 3.	t create: 5.	Transcript show: (SteloLibCall new getErrorMessage); cr.	w setupBreed: t.	Transcript show: (SteloLibCall new getErrorMessage); cr.	"w plugin createTurtleSize: 5 breedId: 3."	w var: STurtleVarDef xVarNo breed: 3 at: 1 put: 10.0.	Transcript show: (SteloLibCall new getErrorMessage); cr.	w var: STurtleVarDef xVarNo breed: 3 at: 2 put: 20.0.	"(w plugin getFloatAll: 3 breed: 3) inspect."	arr := w getFloatAll: STurtleVarDef xVarNo breed: 3.	self assert: arr size equals: 100.	self assert: arr first closeTo: 10.	self assert: arr second closeTo: 20.	self assert: arr third closeTo: 0.! !!SPluginWorldTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetByteAllBreedFrom	| w t arr r |	w := SPluginWorld new.	t := STurtles new breedNo: 3.	t create: 50.	w setupBreed: t.	arr := #(10 200 30 40 50 60 7 8 9 10) asByteArray.	w setByteAll: STurtleVarDef colorVarNo breed: 3 from: arr.	r := w var: STurtleVarDef colorVarNo breed: 3 at: 1.	self assert: r equals: 10.! !!SPluginWorldTest methodsFor: 'test' stamp: 'EiichiroIto 9/16/2019 20:06'!testSizeOf	| c t |	c := SPluginWorld new.	c createPatch: 11.	self assert: (c sizeOf: 2) equals: 121.	t := STurtles new breedNo: 3.	c setupBreed: t.	self assert: (c countAliveOf: 3) equals: 0.	c create: 3 turtles: 5.	self assert: (c sizeOf: 3) equals: 100.! !!SProcessTest methodsFor: 'private' stamp: 'EiichiroIto 12/1/2019 13:03'!newWorld	| w |	w := SMicroWorld new.	w addBreed: SObserver new.	w addBreed: SPatches new.	w newBreed.	^ w! !!SProcessTest methodsFor: 'private' stamp: 'EiichiroIto 9/11/2019 10:23'!sampleProgram3	| program |	program := SProgram new.	program addCode: #(#pushShort 10 0 #pushShort 20 0 #stop).	program addEntryPoint: 1 eventNo: 4 breedNo: 3.	^ program! !!SProcessTest methodsFor: 'tests' stamp: 'EiichiroIto 11/24/2019 17:29'!testAfterLoop	| p w |	w := SMicroWorld new.	p := w newProcess program: SProgram new.	p privRunningEvents: #().	p privTransition: #afterLoop.	p afterLoop.	self assert: p privTransition equals: #afterLoop.	self assertCollection: p privRunningEvents equals: {EventId loopEventNo}.	p privRunningEvents: #(8 9) asSet.	p afterLoop.	self assert: p privTransition equals: #afterLoop.	self assert: (p privRunningEvents isKindOf: Set).	self assert: p privRunningEvents size equals: 2.	self assert: (p privRunningEvents includes: 8).	self assert: (p privRunningEvents includes: 9).! !!SProcessTest methodsFor: 'tests' stamp: 'EiichiroIto 9/9/2019 16:02'!testAfterSetup	| p w |	w := SMicroWorld new.	p := w newProcess program: SProgram new.	p privRunningEvents: #().	p privTransition: #afterSetup.	p afterSetup.	self assert: p privTransition equals: #idle.	self assert: p privRunningEvents isEmpty.	p privRunningEvents: #(8 9) asSet.	p privTransition: #afterSetup.	p afterSetup.	self assert: p privTransition equals: #afterSetup.	self assert: (p privRunningEvents isKindOf: Set).	self assert: p privRunningEvents size equals: 2.	self assert: (p privRunningEvents includes: 8).	self assert: (p privRunningEvents includes: 9).! !!SProcessTest methodsFor: 'tests' stamp: 'EiichiroIto 9/9/2019 16:02'!testAfterSingle	| p w |	w := SMicroWorld new.	p := w newProcess program: SProgram new.	p privRunningEvents: #().	p privTransition: #afterSingle.	p afterSingle.	self assert: p privTransition equals: #idle.	self assert: p privRunningEvents isEmpty.	p privRunningEvents: #(8 9) asSet.	p privTransition: #afterSingle.	p afterSingle.	self assert: p privTransition equals: #afterSingle.	self assert: (p privRunningEvents isKindOf: Set).	self assert: p privRunningEvents size equals: 2.	self assert: (p privRunningEvents includes: 8).	self assert: (p privRunningEvents includes: 9).! !!SProcessTest methodsFor: 'tests' stamp: 'EiichiroIto 11/24/2019 17:29'!testAfterStartup	| p w |	w := SMicroWorld new.	p := w newProcess program: SProgram new.	p privRunningEvents: #().	p privTransition: #afterStartup.	p afterStartup.	self assert: p privTransition equals: #afterSetup.	self assertCollection: p privRunningEvents equals: {EventId setupEventNo}.	p privRunningEvents: #(8 9) asSet.	p privTransition: #afterStartup.	p afterStartup.	self assert: p privTransition equals: #afterStartup.	self assert: (p privRunningEvents isKindOf: Set).	self assert: p privRunningEvents size equals: 2.	self assert: (p privRunningEvents includes: 8).	self assert: (p privRunningEvents includes: 9).! !!SProcessTest methodsFor: 'tests' stamp: 'EiichiroIto 8/27/2019 16:51'!testDoOneCycle	| w p ret |	w := self newWorld.	w createPatch: 1.	w create: 3 turtles: 1.	p := w newProcess program: self sampleProgram3.	p privRunningEvents: {4}.	ret := p doOneCycle.	self assert: ret not.! !!SProcessTest methodsFor: 'tests-execution' stamp: 'EiichiroIto 11/28/2019 22:09'!testExecuteThreadBreedNoIndexIfTerminatedDo	| w prg p f x addr |	w := self newWorld.	prg := SProgram new.	p := w newProcess program: prg.	w create: 3 turtles: 1.	w var: STurtleVarDef colorVarNo breed: 3 at: 1 put: SColorList black.	addr := prg nextAddress.	prg addCode: {#pushShort. SColorList white. 0. #setColorTo. #stop}.	f := false.	p executeThread: addr breedNo: 3 index: 1 ifTerminatedDo: [ f := true ].	x := w var: STurtleVarDef colorVarNo breed: 3 at: 1.	self assert: x equals: SColorList white.	self deny: f.	addr := prg nextAddress.	prg addCode: {#stopAll}.	p executeThread: addr breedNo: 3 index: 1 ifTerminatedDo: [ f := true ].	self assert: f.! !!SProcessTest methodsFor: 'tests-execution' stamp: 'EiichiroIto 8/8/2019 22:07'!testIdle	| p |	p := SMicroWorld new newProcess program: SProgram new.	p idle.! !!SProcessTest methodsFor: 'tests' stamp: 'EiichiroIto 8/8/2019 22:07'!testInitialize	| p |	p := SMicroWorld new newProcess program: SProgram new.	self assert: p privTransition equals: #idle.! !!SProcessTest methodsFor: 'tests-testing' stamp: 'EiichiroIto 8/8/2019 22:08'!testIsRunning	| p |	p := SMicroWorld new newProcess program: SProgram new.	p privTransition: #idle.	self assert: p isRunning not.	p privTransition: #loop.	self assert: p isRunning.	p privTransition: #setup.! !!SProcessTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/24/2019 17:29'!testLoop	| p |	p := SMicroWorld new newProcess program: SProgram new.	p loop.	self assert: p privTransition equals: #afterLoop.	self assertCollection: p privRunningEvents equals: {EventId loopEventNo}.! !!SProcessTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 22:08'!testPrivRunningEvents	| p |	p := SMicroWorld new newProcess program: SProgram new.	self assert: p privRunningEvents isArray.	self assert: p privRunningEvents isEmpty.	p privRunningEvents: #(1 2 3).	self assertCollection: p privRunningEvents equals: #(1 2 3).! !!SProcessTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 22:09'!testPrivTransition	| p |	p := SMicroWorld new newProcess program: SProgram new.	self assert: p privTransition equals: #idle.	p privTransition: #abc.	self assert: p privTransition equals: #abc.! !!SProcessTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/24/2019 17:29'!testSetup	| p |	p := SMicroWorld new newProcess program: SProgram new.	p setup.	self assert: p privTransition equals: #afterSetup.	self assertCollection: p privRunningEvents equals: {EventId setupEventNo}.! !!SProcessTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/24/2019 17:29'!testSingle	| p |	p := SMicroWorld new newProcess program: SProgram new.	p single.	self assert: p privTransition equals: #afterSingle.	self assertCollection: p privRunningEvents equals: {EventId singleEventNo}.! !!SProcessTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 12/1/2019 13:04'!testStartup	| w p |	w := SMicroWorld new.	w addBreed: SObserver new.	p := w newProcess program: SProgram new.	p startup.	self assert: p privTransition equals: #afterStartup.	self assertCollection: p privRunningEvents equals: {EventId startupEventNo}.! !!SProcessTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 22:10'!testStep	| p |	p := SMicroWorld new newProcess program: SProgram new.	p privTransition: #idle.	p step.! !!SProcessTest methodsFor: 'tests-execution' stamp: 'EiichiroIto 8/8/2019 22:10'!testStop	| p |	p := SMicroWorld new newProcess program: SProgram new.	self assert: p privTransition equals: #idle.	self assert: p privRunningEvents isEmpty.! !!SProgramTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 10:55'!testAddCode	| p |	p := SProgram new.	self assert: p codes isEmpty.	p addCode: #(1 2 3 4).	self assertCollection: p codes equals: #(1 2 3 4).	p addCode: #(5 6 7).	self assertCollection: p codes equals: #(1 2 3 4 5 6 7).! !!SProgramTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 10:59'!testAddEntryPointEventNoBreedNo	| p |	p := SProgram new.	self assert: p eventNoList isEmpty.	p addEntryPoint: 5 eventNo: 1 breedNo: 2.	p addEntryPoint: 6 eventNo: 2 breedNo: 2.	p addEntryPoint: 7 eventNo: 3 breedNo: 2.	p addEntryPoint: 8 eventNo: 1 breedNo: 1.	p addEntryPoint: 9 eventNo: 3 breedNo: 1.	p addEntryPoint: 10 eventNo: 2 breedNo: 3.	p addEntryPoint: 11 eventNo: 3 breedNo: 3.	self assertCollection: p eventNoList equals: #(1 2 3).	self assertCollection: ((p forEventNo: 1) forBreedNo: 1) asArray equals: #(8).	self assertCollection: ((p forEventNo: 1) forBreedNo: 2) asArray equals: #(5).	self assertCollection: ((p forEventNo: 1) forBreedNo: 3) asArray equals: #().	self assertCollection: ((p forEventNo: 2) forBreedNo: 1) asArray equals: #().	self assertCollection: ((p forEventNo: 2) forBreedNo: 2) asArray equals: #(6).	self assertCollection: ((p forEventNo: 2) forBreedNo: 3) asArray equals: #(10).	self assertCollection: ((p forEventNo: 3) forBreedNo: 1) asArray equals: #(9).	self assertCollection: ((p forEventNo: 3) forBreedNo: 2) asArray equals: #(7).	self assertCollection: ((p forEventNo: 3) forBreedNo: 3) asArray equals: #(11).! !!SProgramTest methodsFor: 'test' stamp: 'EiichiroIto 9/12/2019 13:22'!testBytecode	| p |	p := SProgram new.	self assert: p codes isEmpty.	p privCodes: #(1 2 3).	self assertCollection: p bytecode equals: #(1 2 3).	p privCodes: #(1 2 div mod 3).	self assertCollection: p bytecode equals: #(1 2 22 48 3).! !!SProgramTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 10:41'!testCodes	| p |	p := SProgram new.	self assert: p codes isEmpty.	p privCodes: #(1 2 3).	self assertCollection: p codes equals: #(1 2 3).	p privCodes: #(4 5 6).	self assertCollection: p codes equals: #(4 5 6).! !!SProgramTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 15:02'!testEntryPointList	| p ret |	p := SProgram new.	self assert: p entryPointList isEmpty.	p addEntryPoint: 5 eventNo: 1 breedNo: 2.	p addEntryPoint: 6 eventNo: 2 breedNo: 2.	p addEntryPoint: 7 eventNo: 3 breedNo: 2.	p addEntryPoint: 8 eventNo: 1 breedNo: 1.	p addEntryPoint: 9 eventNo: 3 breedNo: 1.	p addEntryPoint: 10 eventNo: 2 breedNo: 3.	p addEntryPoint: 11 eventNo: 3 breedNo: 3.	ret := p entryPointList.	self assert: ret isArray.	self assert: ret size equals: 7.	self assertCollection: ret first equals: #(1 1 8).	self assertCollection: ret second equals: #(1 2 5).	self assertCollection: ret third equals: #(2 2 6).	self assertCollection: ret fourth equals: #(2 3 10).	self assertCollection: ret fifth equals: #(3 1 9).	self assertCollection: ret sixth equals: #(3 2 7).	self assertCollection: ret seventh equals: #(3 3 11)! !!SProgramTest methodsFor: 'test' stamp: 'EiichiroIto 8/9/2019 19:42'!testEventNoList	| p |	p := SProgram new.	self assert: p eventNoList isEmpty.	p forEventNo: 1.	p forEventNo: 3.	self assertCollection: p eventNoList sort equals: #(1 3).! !!SProgramTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 9/11/2019 10:52'!testForEventNo	| p c1 c2 |	p := SProgram new.	self assert: p privEntryPoints isEmpty.	c1 := p forEventNo: 1.	self assert: (c1 isKindOf: SEntryPoints).	self assert: p privEntryPoints size equals: 1.	self assert: (p privEntryPoints at: 1) equals: c1.	c2 := p forEventNo: 2.	self assert: (c2 isKindOf: SEntryPoints).	self assert: p privEntryPoints size equals: 2.	self assert: (p privEntryPoints at: 2) equals: c2.	self assert: c1 ~= c2.! !!SProgramTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 9/11/2019 10:52'!testInitialize	self testPrivEntryPoints.! !!SProgramTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 10:54'!testNextAddress	| p |	p := SProgram new.	self assert: p nextAddress equals: 1.	p addCode: #(1 2 3 4).	self assert: p nextAddress equals: 5.	p addCode: #(5 6 7).	self assert: p nextAddress equals: 8.! !!SProgramTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 10:53'!testPrivCodes	self testCodes.! !!SProgramTest methodsFor: 'tests-private' stamp: 'EiichiroIto 9/11/2019 10:52'!testPrivEntryPoints	| p |	p := SProgram new.	self assert: p privEntryPoints isDictionary.	self assert: p privEntryPoints isEmpty.! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 11:17'!testAddListEventNoBreedNo	| j d |	j := SProgramToJson new.	j addList: #(1 2 3) eventNo: 2 breedNo: 5.	j addList: #(4 5 6) eventNo: 2 breedNo: 3.	j addList: #(1) eventNo: 1 breedNo: 5.	j addList: #(5 6) eventNo: 3 breedNo: 3.	d := j breeds.	self assert: d size equals: 2.	self assert: (d at: 3) class equals: Dictionary.	self assertCollection: ((d at: 3) at: 2) equals: #(4 5 6).	self assertCollection: ((d at: 3) at: 3) equals: #(5 6).	self assert: (d at: 5) class equals: Dictionary.	self assertCollection: ((d at: 5) at: 2) equals: #(1 2 3).	self assertCollection: ((d at: 5) at: 1) equals: #(1).	self should: [ j addCode: #(7 8) eventNo: 2 breedNo: 3 ] raise: Error.! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 8/9/2019 18:53'!testBreeds	| j |	j := SProgramToJson new.	self assert: j breeds class equals: Dictionary.! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 11/24/2019 17:30'!testConvert	| pr j list |	pr := SProgram new.	pr addEntryPoint: 5 eventNo: EventId loopEventNo breedNo: 3.	pr addEntryPoint: 10 eventNo: EventId loopEventNo breedNo: 1.	j := SProgramToJson new.	j convert: pr.	self assert: j breeds size equals: 2.	self assert: (j breeds at: 3) class equals: Dictionary.	list := (j breeds at: 3) at: EventId loopEventNo.	self assertCollection: list asArray equals: #(5).	self assert: (j breeds at: 1) class equals: Dictionary.	list := (j breeds at: 1) at: EventId loopEventNo.	self assertCollection: list asArray equals: #(10).! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 11:21'!testConvertEventNo	| e j d |	e := SEntryPoints new.	e addEntryPoint: 1 forBreedNo: 5.	e addEntryPoint: 2 forBreedNo: 5.	e addEntryPoint: 9 forBreedNo: 3.	j := SProgramToJson new.	j convert: e eventNo: 2.	d := j breeds.	self assert: d size equals: 2.	self assert: (d at: 3) class equals: Dictionary.	self assertCollection: ((d at: 3) at: 2) asArray equals: #(9).	self assert: (d at: 5) class equals: Dictionary.	self assertCollection: ((d at: 5) at: 2) asArray equals: #(1 2).! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 11:23'!testFromProgram	| p j ret |	p := SProgram new.	p addCode: #(1 2 3 4 5 6 7 8 9).	p addEntryPoint: 10 eventNo: 1 breedNo: 1.	p addEntryPoint: 12 eventNo: 1 breedNo: 2.	p addEntryPoint: 14 eventNo: 1 breedNo: 2.	p addEntryPoint: 16 eventNo: 2 breedNo: 1.	j := SProgramToJson new.	ret := j fromProgram: p.	self assert: ret equals: '{"breeds":[{"breed":1,"entries":[{"event":1,"address":10},{"event":2,"address":16}]},{"breed":2,"entries":[{"event":1,"address":12},{"event":1,"address":14}]}],"codes":[1,2,3,4,5,6,7,8,9]}'! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 11:36'!testGenerateBreeds	| d d1 d2 j |	d := Dictionary new.	d1 := Dictionary new.	d1 at: 5 put: #(2).	d2 := Dictionary new.		d2 at: 1 put: #(4 5).	d at: 3 put: d1.	d at: 2 put: d2.	j := SProgramToJson new.	j generateBreeds: d.	self assert: j stream contents equals: '"breeds":[{"breed":2,"entries":[{"event":1,"address":4},{"event":1,"address":5}]},{"breed":3,"entries":[{"event":5,"address":2}]}]'! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 14:46'!testGenerateCodes	| j |	j := SProgramToJson new.	j generateCodes: #().	self assert: j stream contents equals: '"codes":[]'.	j := SProgramToJson new.	j generateCodes: #(1).	self assert: j stream contents equals: '"codes":[1]'.	j := SProgramToJson new.	j generateCodes: #(1 2).	self assert: j stream contents equals: '"codes":[1,2]'.	j := SProgramToJson new.	j generateCodes: #(1 2 3 4).	self assert: j stream contents equals: '"codes":[1,2,3,4]'.! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 11:31'!testGenerateEntries	| d j |	d := Dictionary new.	d at: 5 put: #(1).	d at: 1 put: #(2 3).	j := SProgramToJson new.	j generateEntries: d.	self assert: j stream contents equals: ',"entries":[{"event":1,"address":2},{"event":1,"address":3},{"event":5,"address":1}]'.! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 9/11/2019 11:28'!testGenerateEntryEventNo	| j |	j := SProgramToJson new.	j generateEntry: #() eventNo: 5.	self assert: j stream contents equals: ''.	j := SProgramToJson new.	j generateEntry: #(1) eventNo: 5.	self assert: j stream contents equals: '{"event":5,"address":1}'.	j := SProgramToJson new.	j generateEntry: #(3 4) eventNo: 1.	self		assert: j stream contents		equals: '{"event":1,"address":3},{"event":1,"address":4}'.	j := SProgramToJson new.	j generateEntry: #(5 6 7) eventNo: 3.	self		assert: j stream contents		equals:			'{"event":3,"address":5},{"event":3,"address":6},{"event":3,"address":7}'! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 8/9/2019 18:54'!testInitialize	self testBreeds.	self testStream.! !!SProgramToJsonTest methodsFor: 'test' stamp: 'EiichiroIto 8/9/2019 18:54'!testStream	| j |	j := SProgramToJson new.	self assert: j stream class equals: WriteStream.! !!SThreadTest methodsFor: 'private' stamp: 'EiichiroIto 12/1/2019 13:03'!newWorld	| w |	w := SMicroWorld new.	w addBreed: SObserver new.	w addBreed: SPatches new.	w newBreed.	^ w! !!SThreadTest methodsFor: 'private' stamp: 'EiichiroIto 9/10/2019 14:57'!sampleCode1	^ OrderedCollection new		add: #pushShort;		add: 3;		add: 0;		add: #forward;		add: #stop;		yourself! !!SThreadTest methodsFor: 'private' stamp: 'EiichiroIto 9/12/2019 08:54'!sampleCode2	^ #(pushShort 1 0 pushShort 2 0 plus return pushShort 1 0 call returnValue dup mul stop)! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testAbs	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	self assert: t stack size equals: 1.	t abs.	self assert: t stack size equals: 1.	self assert: t pop equals: 10.	t push: -20.	self assert: t stack size equals: 1.	t abs.	self assert: t stack size equals: 1.	self assert: t pop equals: 20.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testAcos	| t |	t := SThread sworld: SMicroWorld new.	t push: 0.5.	self assert: t stack size equals: 1.	t acos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 60.	t push: -10.	self assert: t stack size equals: 1.	t acos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 180.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testAimHigh	| w v t |	w := self newWorld.	w createPatch: 5.	w create: 3 turtles: 1.	v := w patches addVariable: 'a'.	"	21 22 23 24 25	16 17 18 19 20	11 12 13 14 15	 6  7  8  9 10	 1  2  3  4  5"	w x: 3 at: 1 put: 0.	w y: 3 at: 1 put: 0.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 45.	w		var: v		breed: 2		at: 18		put: 1.	w		var: v		breed: 2		at: 19		put: 2.	w		var: v		breed: 2		at: 14		put: 3.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t push: v.	t aimHigh.	self assert: t pop equals: -45! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 9/10/2019 16:18'!testAnd	| t |	t := SThread sworld: SMicroWorld new.	t push: false.	t push: false.	self assert: t stack size equals: 2.	t and.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: false.	t push: true.	self assert: t stack size equals: 2.	t and.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: true.	t push: false.	self assert: t stack size equals: 2.	t and.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: true.	t push: true.	self assert: t stack size equals: 2.	t and.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testAsin	| t |	t := SThread sworld: SMicroWorld new.	t push: 0.5.	self assert: t stack size equals: 1.	t asin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 30.	t push: -10.	self assert: t stack size equals: 1.	t asin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -90.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testAtan	| t |	t := SThread sworld: SMicroWorld new.	t push: 1.	self assert: t stack size equals: 1.	t atan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 45.	t push: -10.	self assert: t stack size equals: 1.	t atan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -45.! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testBroadcast	| w e s |	w := SMicroWorld new.	e := SThread sworld: w.	s := e stack size.	e push: 10.	self assert: w raisedEvents isEmpty.	e broadcast.	self assert: e stack size equals: s.	self assert: w raisedEvents size equals: 1.	self assert: (w raisedEvents includes: 10).! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/12/2019 08:45'!testCall	| e |	e := SThread sworld: SMicroWorld new.	e pc: 20.	e push: 10.	e call.	self assert: e pc equals: 10.	self assert: e stack size equals: 1.	self assert: e pop equals: 20.! !!SThreadTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 9/21/2019 16:02'!testClearBreed	| w e |	w := self newWorld.	w create: 3 turtles: 5.	w addBreed: (STurtles new breedNo: 4).	w create: 4 turtles: 10.	e := SThread sworld: w.	self assert: (w breedOf: 3) countAlive equals: 5.	self assert: (w breedOf: 4) countAlive equals: 10.	e push: 3.	e clearBreed.	self assert: (w breedOf: 3) countAlive equals: 0.	self assert: (w breedOf: 4) countAlive equals: 10.	self assert: e stack size equals: 0.! !!SThreadTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 8/8/2019 11:52'!testClearGraphics	| w e |	w := self newWorld.	w patches colorAtPoint: 10 @ 20 put: 1.	w patches colorAtPoint: 20 @ 15 put: 2.	e := SThread sworld: w.	self assert: e stack size equals: 0.	self assert: (w patches colorAtPoint: 10 @ 20) equals: 1.	self assert: (w patches colorAtPoint: 20 @ 15) equals: 2.	e clearGraphics.	self assert: e stack size equals: 0.	self assert: (w patches colorAtPoint: 10 @ 20) equals: 0.	self assert: (w patches colorAtPoint: 20 @ 15) equals: 0.! !!SThreadTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 9/21/2019 16:02'!testClearTurtles	| w e s |	w := self newWorld.	w create: 3 turtles: 5.	w addBreed: (STurtles new breedNo: 4).	w create: 4 turtles: 10.	e := SThread sworld: w.	s := e stack size.	self assert: (w breedOf: 3) countAlive equals: 5.	self assert: (w breedOf: 4) countAlive equals: 10.	e clearTurtles.	self assert: (w breedOf: 3) countAlive equals: 0.	self assert: (w breedOf: 4) countAlive equals: 0.	self assert: e stack size equals: s.! !!SThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 08:01'!testCodes	| t |	t := SThread sworld: SMicroWorld new.	self assert: t codes isNil.	t codes: #(1 2 3).	self assertCollection: t codes equals: #(1 2 3).! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testCos	| t |	t := SThread sworld: SMicroWorld new.	t push: 0.	self assert: t stack size equals: 1.	t cos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1.	t push: 90.	self assert: t stack size equals: 1.	t cos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 180.	self assert: t stack size equals: 1.	t cos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -1.	t push: 270.	self assert: t stack size equals: 1.	t cos.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.! !!SThreadTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 8/8/2019 11:52'!testCreatePatch	| w e |	w := self newWorld.	e := SThread sworld: w.	self assert: w patches rows equals: 100.	self assert: w patches cols equals: 100.	self assert: e stack size equals: 0.	e push: 20.	e createPatch.	self assert: e stack size equals: 0.	self assert: w patches rows equals: 20.	self assert: w patches cols equals: 20.! !!SThreadTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 8/16/2019 17:16'!testCreateTurtles	| w e s |	w := self newWorld.	e := SThread sworld: w.	s := e stack size.	e push: 20.	e push: 3.	self assert: (w breedOf: 3) countAlive equals: 0.	e createTurtles.	self assert: e stack size equals: s.	self assert: (w breedOf: 3) countAlive equals: 20.! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testDec	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	self assert: t stack first equals: 10.	t dec.	self assert: t stack first equals: 9.	t dec.	self assert: t stack first equals: 8.! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testDirection	| t |	t := SThread sworld: SMicroWorld new.	t forPatchId: 1.	t push: 0.	t push: 0.	t direction.	self assert: t pop equals: 90.	t push: 1.	t push: 1.	t direction.	self assert: t pop equals: 45.	t push: 0.	t push: 1.	t direction.	self assert: t pop equals: 90.	t push: 0.	t push: -1.	t direction.	self assert: t pop equals: -90.	t push: -1.	t push: 1.	t direction.	self assert: t pop equals: 135.	t push: -1.	t push: -1.	t direction.	self assert: t pop equals: 225.	t push: 1.	t push: -1.	t direction.	self assert: t pop equals: 360 - 45.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 9/4/2019 09:41'!testDiv	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t div.	self assert: t stack size equals: 1.	self assert: t pop equals: 2.	t push: 5.	t push: -10.	self assert: t stack size equals: 2.	t div.	self assert: t stack size equals: 1.	self assert: t pop equals: -0.5.	self deny: t isTerminated.	t push: 5.	t push: 0.	t div.	self assert: t isTerminated.! !!SThreadTest methodsFor: 'tests-execution' stamp: 'EiichiroIto 11/28/2019 22:09'!testDoOneCycle	| e w c |	w := self newWorld.	w create: 3 turtles: 1.	w x: 3 at: 1 put: 0.	w y: 3 at: 1 put: 0.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 0.	c := self sampleCode1.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e codes: c.	self assert: e pc equals: 1.	self assert: e stack isEmpty.	self assert: e doOneCycle not.	self assert: e pc equals: c size + 1.	self assert: e stack isEmpty.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 3.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) equals: 0.	self should: [e doOneCycle] raise: Error.! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testDrop	| t |	t := SThread sworld: SMicroWorld.	self assert: t stack size equals: 0.	t push: 10.	self assert: t stack size equals: 1.	t drop.	self assert: t stack size equals: 0.! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testDup	| t |	t := SThread sworld: SMicroWorld.	self assert: t stack size equals: 0.	t push: 10.	self assert: t stack size equals: 1.	t dup.	self assert: t stack size equals: 2.	self assert: t pop equals: 10.	self assert: t pop equals: 10.	self assert: t stack size equals: 0.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testDx	| e w |	w := self newWorld.	w create: 3 turtles: 1.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 0.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e dx.	self assert: e pop closeTo: 1.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 90.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e dx.	self assert: e pop closeTo: 0.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 180.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e dx.	self assert: e pop closeTo: -1.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 270.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e dx.	self assert: e pop closeTo: 0! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testDy	| e w |	w := self newWorld.	w create: 3 turtles: 1.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 0.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e dy.	self assert: e pop closeTo: 0.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 90.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e dy.	self assert: e pop closeTo: 1.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 180.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e dy.	self assert: e pop closeTo: 0.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 270.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e dy.	self assert: e pop closeTo: -1! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 9/10/2019 16:18'!testEqual	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t equal.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -10.	t push: -10.	self assert: t stack size equals: 2.	t equal.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!SThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 08:01'!testErrorOccuered	| t |	t := SThread sworld: SMicroWorld new.	self assert: t isTerminated equals: false.	t errorOccuered.	self assert: t isTerminated equals: true.! !!SThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testEvaluate	| w t c x |	w := self newWorld.	t := SThread sworld: w.	w create: 3 turtles: 1.	w var: STurtleVarDef colorVarNo breed: 3 at: 1 put: SColorList black.	c := #(push1 pushShort 2 0 #plus #stop).	t forBreedNo: 3 index: 1.	t codes: c.	x := t evaluate: 1.	self assert: x equals: 3.! !!SThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testExecute	| w t c x |	w := self newWorld.	t := SThread sworld: w.	w create: 3 turtles: 1.	w var: STurtleVarDef colorVarNo breed: 3 at: 1 put: SColorList black.	c := {#pushShort. SColorList white. 0. #setColorTo. #stop}.	t forBreedNo: 3 index: 1.	t codes: c.	t execute: 1.	x := w var: STurtleVarDef colorVarNo breed: 3 at: 1.	self assert: x equals: SColorList white.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testExp	| t |	t := SThread sworld: SMicroWorld new.	t push: 0.	self assert: t stack size equals: 1.	t exp.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1.	t push: 2.	self assert: t stack size equals: 1.	t exp.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 2 exp.	t push: -1.	self assert: t stack size equals: 1.	t exp.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1 / 1 exp.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testExp10	| t |	t := SThread sworld: SMicroWorld new.	t push: 0.	self assert: t stack size equals: 1.	t exp10.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1.	t push: 2.	self assert: t stack size equals: 1.	t exp10.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 100.	t push: -1.	self assert: t stack size equals: 1.	t exp10.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.1.! !!SThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 08:01'!testForBreedNoIndex	| e |	e := SThread sworld: SMicroWorld new.	self assert: e privBreedId isNil.	self assert: e privId isNil.	e forBreedNo: 3 index: 123.	self assert: e privBreedId equals: 3.	self assert: e privId equals: 123.! !!SThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 08:01'!testForObserver	| e |	e := SThread sworld: SMicroWorld new.	self assert: e privBreedId isNil.	self assert: e privId isNil.	e forObserver.	self assert: e privBreedId equals: SBreedId observerBreedNo.	self assert: e privId equals: 1.! !!SThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 08:01'!testForPatchId	| e |	e := SThread sworld: SMicroWorld new.	self assert: e privBreedId isNil.	self assert: e privId isNil.	e forPatchId: 123.	self assert: e privBreedId equals: 2.	self assert: e privId equals: 123.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testForward	| e w |	w := self newWorld.	w createPatch: 5.	w create: 3 turtles: 1.	w x: 3 at: 1 put: 0.	w y: 3 at: 1 put: 0.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 0.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e push: 1.	e forward.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) closeTo: 1.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) closeTo: 0.	e push: 2.	e forward.	self		assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1)		closeTo: -2.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) closeTo: 0! !!SThreadTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 8/27/2019 16:51'!testGetBreedId	| w t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 2.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t getBreedId.	self assert: t pop equals: 3.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t getBreedId.	self assert: t pop equals: 3.	t := SThread sworld: w.	t forPatchId: 3.	t getBreedId.	self assert: t pop equals: 2.	t := SThread sworld: w.	t forObserver.	t getBreedId.	self assert: t pop equals: 1.! !!SThreadTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 8/27/2019 16:51'!testGetBreedVar	| w t v |	w := self newWorld.	t := SThread sworld: w.	w createPatch: 4.	v := w patches addVariable: 'a'.	t push: 1.	t push: v.	t push: SBreedId patchBreedNo.	t getBreedVar.	self assert: t pop equals: 0.	w patches privVariables var: v at: 1 put: 2.	t push: 1.	t push: v.	t push: SBreedId patchBreedNo.	t getBreedVar.	self assert: t pop equals: 2! !!SThreadTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testGetId	| t |	t := SThread sworld: SMicroWorld new.	t privId: 10.	self assert: t stack size equals: 0.	t getId.	self assert: t pop equals: 10.! !!SThreadTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 8/24/2019 18:17'!testGetVar	| w t v |	w := self newWorld.	t := SThread sworld: w.	w create: 3 turtles: 1.	t forBreedNo: 3 index: 1.	v := (w breedOf: 3) addVariable: 'b'.	t push: v.	t getVar.	self assert: t pop equals: 0.	w		var: v		breed: 3		at: 1		put: 10.	t push: v.	t getVar.	self assert: t pop equals: 10! !!SThreadTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 8/27/2019 16:51'!testGetX	| w t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 3.	w x: 3 at: 1 put: 1.	w x: 3 at: 2 put: -1.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t getX.	self assert: t pop equals: 1.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t getX.	self assert: t pop equals: -1.	t := SThread sworld: w.	t forBreedNo: 3 index: 3.	t getX.	self assert: t pop equals: 0.	t := SThread sworld: w.	t forPatchId: 3.	t getX.	self assert: t pop equals: 1! !!SThreadTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 8/27/2019 16:51'!testGetY	| w t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 3.	w y: 3 at: 1 put: 1.	w y: 3 at: 2 put: -1.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t getY.	self assert: t pop equals: 1.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t getY.	self assert: t pop equals: -1.	t := SThread sworld: w.	t forBreedNo: 3 index: 3.	t getY.	self assert: t pop equals: 0.	t := SThread sworld: w.	t forPatchId: 3.	t getY.	self assert: t pop equals: -1! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 8/16/2019 17:16'!testHatch	| w e s |	w := self newWorld.	w create: 3 turtles: 1.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	s := e stack size.	self assert: (w breedOf: 3) countAlive equals: 1.	self assert: ((w breedOf: 3) aliveAt: 1).	e hatch.	self assert: (w breedOf: 3) countAlive equals: 2.	self assert: ((w breedOf: 3) aliveAt: 1).	self assert: ((w breedOf: 3) aliveAt: 2).	self assert: e stack size equals: s.! !!SThreadTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 9/5/2018 10:34'!testInitialize	self testPc.	self testStack.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 9/12/2019 08:33'!testInv	| t |	t := SThread sworld: SMicroWorld new.	t push: 0.	t inv.	self assert: t pop equals: 16rFFFF.	t := SThread sworld: SMicroWorld new.	t push: 16rFFFF.	t inv.	self assert: t pop equals: 0.	t := SThread sworld: SMicroWorld new.	t push: 16r1234.	t inv.	self assert: t pop equals: 16rEDCB.! !!SThreadTest methodsFor: 'tests-testing' stamp: 'EiichiroIto 9/10/2019 10:56'!testIsRunning	self testPrivIsRunning.! !!SThreadTest methodsFor: 'tests-testing' stamp: 'EiichiroIto 9/10/2019 10:56'!testIsTerminated	self testPrivIsTerminated.! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testJump	| t |	t := SThread sworld: SMicroWorld new.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t push: 5.	self assert: t stack size equals: 1.	t jump.	self assert: t pc equals: 5.	self assert: t stack size equals: 0.! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testJumpIfFalse	| t |	t := SThread sworld: SMicroWorld new.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t push: true.	t push: 5.	self assert: t stack size equals: 2.	t jumpIfFalse.	self assert: t pc equals: 1.	self assert: t stack size equals: 0.	t push: false.	t push: 5.	self assert: t stack size equals: 2.	t jumpIfFalse.	self assert: t pc equals: 5.	self assert: t stack size equals: 0.! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testJumpIfTrue	| t |	t := SThread sworld: SMicroWorld new.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t push: false.	t push: 5.	self assert: t stack size equals: 2.	t jumpIfTrue.	self assert: t pc equals: 1.	self assert: t stack size equals: 0.	t push: true.	t push: 5.	self assert: t stack size equals: 2.	t jumpIfTrue.	self assert: t pc equals: 5.	self assert: t stack size equals: 0.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 9/10/2019 10:55'!testKill	| w e s |	w := self newWorld.	w create: 3 turtles: 2.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e codes: #(1 2 3 4).	s := e stack size.	self assert: ((w breedOf: 3) aliveAt: 1).	e push: 3.	e push: 1.	e kill.	self assert: e stack size equals: s.	self assert: ((w breedOf: 3) aliveAt: 1) not.	self deny: e isRunning.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 9/10/2019 16:18'!testLess	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t less.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -10.	t push: -10.	self assert: t stack size equals: 2.	t less.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -10.	t push: 10.	self assert: t stack size equals: 2.	t less.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 9/10/2019 16:21'!testLessEqual	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t lessEqual.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -10.	t push: -10.	self assert: t stack size equals: 2.	t lessEqual.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: -10.	t push: 10.	self assert: t stack size equals: 2.	t lessEqual.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testLn	| t |	t := SThread sworld: SMicroWorld new.	t push: 1.	self assert: t stack size equals: 1.	t ln.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 2 exp.	self assert: t stack size equals: 1.	t ln.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 2.	t push: 1 / 1 exp.	self assert: t stack size equals: 1.	t ln.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -1.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testLog	| t |	t := SThread sworld: SMicroWorld new.	t push: 1.	self assert: t stack size equals: 1.	t log.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 100.	self assert: t stack size equals: 1.	t log.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 2.	t push: 0.1.	self assert: t stack size equals: 1.	t log.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -1.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testMinus	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t minus.	self assert: t stack size equals: 1.	self assert: t pop equals: 5.	t push: 5.	t push: -10.	self assert: t stack size equals: 2.	t minus.	self assert: t stack size equals: 1.	self assert: t pop equals: 15.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testMod	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t mod.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.	t push: -5.	t push: 10.	self assert: t stack size equals: 2.	t mod.	self assert: t stack size equals: 1.	self assert: t pop equals: 5.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testMul	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t mul.	self assert: t stack size equals: 1.	self assert: t pop equals: 50.	t push: 0.5.	t push: -10.	self assert: t stack size equals: 2.	t mul.	self assert: t stack size equals: 1.	self assert: t pop equals: -5.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 9/10/2019 16:16'!testNot	| t |	t := SThread sworld: SMicroWorld new.	t push: false.	self assert: t stack size equals: 1.	t not.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: true.	self assert: t stack size equals: 1.	t not.	self assert: t stack size equals: 1.	self assert: t pop equals: 0.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 9/10/2019 16:19'!testOr	| t |	t := SThread sworld: SMicroWorld new.	t push: false.	t push: false.	self assert: t stack size equals: 2.	t or.	self assert: t stack size equals: 1.	self assert: t stack first equals: 0.	t pop.	t push: false.	t push: true.	self assert: t stack size equals: 2.	t or.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: true.	t push: false.	self assert: t stack size equals: 2.	t or.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: true.	t push: true.	self assert: t stack size equals: 2.	t or.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 8/27/2019 16:51'!testPatchAt	| w t |	w := self newWorld.	t := SThread sworld: w.	w createPatch: 4.	t push: 0.	t push: 0.	t patchAt.	self assert: t pop equals: 11.	t push: -2.	t push: -2.	t patchAt.	self assert: t pop equals: 1.	t push: 1.	t push: 1.	t patchAt.	self assert: t pop equals: 16.	t push: 0.	t push: -1.	t patchAt.	self assert: t pop equals: 7.! !!SThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 9/12/2019 08:45'!testPc	| e |	e := SThread sworld: SMicroWorld new.	self assert: e pc equals: 1.	e pc: 10.	self assert: e pc equals: 10.	e pc: 20.	self assert: e pc equals: 20.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testPlus	| t |	t := SThread sworld: SMicroWorld new.	t push: 10.	t push: 5.	self assert: t stack size equals: 2.	t plus.	self assert: t stack size equals: 1.	self assert: t pop equals: 15.	t push: 5.	t push: -10.	self assert: t stack size equals: 2.	t plus.	self assert: t stack size equals: 1.	self assert: t pop equals: -5.! !!SThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 08:01'!testPop	| e |	e := SThread sworld: SMicroWorld new.	e push: 10.	e push: 20.	self assertCollection: e stack asArray equals: #(10 20).	self assert: e pop equals: 20.	self assert: e pop equals: 10.	self assert: e stack isEmpty.! !!SThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 08:01'!testPrivBreedId	| e |	e := SThread sworld: SMicroWorld new.	self assert: e privBreedId isNil.	e privBreedId: 10.	self assert: e privBreedId equals: 10.	e privBreedId: 20.	self assert: e privBreedId equals: 20.! !!SThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 08:01'!testPrivId	| e |	e := SThread sworld: SMicroWorld new.	self assert: e privId isNil.	e privId: 10.	self assert: e privId equals: 10.	e privId: 20.	self assert: e privId equals: 20.! !!SThreadTest methodsFor: 'tests-testing' stamp: 'EiichiroIto 9/10/2019 10:55'!testPrivIsRunning	| t |	t := SThread sworld: SMicroWorld new.	self assert: t isRunning equals: false.	t privIsRunning: true.	self assert: t isRunning equals: true.	t privIsRunning: false.	self assert: t isRunning equals: false.! !!SThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 9/10/2019 10:56'!testPrivIsTerminated	| t |	t := SThread sworld: SMicroWorld new.	self assert: t isTerminated equals: false.	t privIsTerminated: true.	self assert: t isTerminated equals: true.	t privIsTerminated: false.	self assert: t isTerminated equals: false.! !!SThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 9/11/2019 22:12'!testPrivRetVal	| t |	t := SThread sworld: SMicroWorld new.	self assert: t retVal equals: 0.	t privRetVal: 123.	self assert: t retVal equals: 123.! !!SThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 22:21'!testPrivSWorld	| w1 w2 e |	w1 := SMicroWorld new.	e := SThread sworld: w1.	self assert: e privSWorld equals: w1.	w2 := SMicroWorld new.	e privSWorld: w2.	self assert: e privSWorld equals: w2.! !!SThreadTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 08:01'!testPush	| e |	e := SThread sworld: SMicroWorld new.	self assert: e stack isEmpty.	e push: 10.	e push: 20.	self assert: e stack size equals: 2.	self assertCollection: e stack asArray equals: #(10 20).! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 9/10/2019 15:03'!testPush0	| e |	e := SThread sworld: SMicroWorld new.	self assert: e stack isEmpty.	e push0.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(0).	e push0.	self assert: e stack size equals: 2.	self assertCollection: e stack asArray equals: #(0 0).! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 9/10/2019 15:03'!testPush1	| e |	e := SThread sworld: SMicroWorld new.	self assert: e stack isEmpty.	e push1.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(1).	e push1.	self assert: e stack size equals: 2.	self assertCollection: e stack asArray equals: #(1 1).! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 9/10/2019 15:10'!testPushFloat	| e |	e := SThread sworld: SMicroWorld new.	e codes: #(16r00 16r00 16rF6 16r42).	self assert: e stack isEmpty.	e pushFloat.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(123.0)! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 9/10/2019 15:11'!testPushShort	| e |	e := SThread sworld: SMicroWorld new.	e codes: #(16r03 16r00).	self assert: e stack isEmpty.	e pushShort.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(3).	e := SThread sworld: SMicroWorld new.	e codes: #(16rFD 16rFF).	self assert: e stack isEmpty.	e pushShort.	self assert: e stack size equals: 1.	self assertCollection: e stack asArray equals: #(-3)! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testRandomFromTo	| t |	t := SThread sworld: SMicroWorld new.	100		timesRepeat: [ self assert: t stack size equals: 0.			t push: 5.			t push: 10.			t randomFromTo.			self assert: t stack size equals: 1.			self assert: (t pop between: 5 and: 10) ].! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/11/2019 22:12'!testRetVal	self testPrivRetVal.! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/12/2019 08:49'!testReturn	| e |	e := SThread sworld: SMicroWorld new.	e pc: 20.	e push: 30.	e push: 10.	e return.	self assert: e pc equals: 30.	self assert: e stack size equals: 0.	self assert: e retVal equals: 10.! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/12/2019 08:53'!testReturnValue	| e w c ret |	w := self newWorld.	w create: 3 turtles: 1.	c := self sampleCode2.	e := SThread sworld: w.	e forBreedNo: 3 index: 1.	e codes: c.	ret := e evaluate: 9.	self assert: ret equals: 9.	self assert: e stack isEmpty.	self assert: e pc equals: c size + 1.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testRounded	| t |	t := SThread sworld: SMicroWorld new.	t push: 1.4.	self assert: t stack size equals: 1.	t rounded.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: 1.5.	self assert: t stack size equals: 1.	t rounded.	self assert: t stack size equals: 1.	self assert: t pop equals: 2.	t push: -1.5.	self assert: t stack size equals: 1.	t rounded.	self assert: t stack size equals: 1.	self assert: t pop equals: -2.! !!SThreadTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 8/27/2019 16:51'!testSetBreedVarTo	| w t v |	w := self newWorld.	t := SThread sworld: w.	w createPatch: 4.	v := w patches addVariable: 'a'.	self assert: (w patches privVariables var: v at: 1) equals: 0.	self assert: t stack size equals: 0.	t push: 1.	t push: 2.	t push: v.	t push: SBreedId patchBreedNo.	t setBreedVarTo.	self assert: (w patches privVariables var: v at: 1) equals: 2.	self assert: t stack size equals: 0.	t push: 1.	t push: 3.	t push: v.	t push: SBreedId patchBreedNo.	t setBreedVarTo.	self assert: (w patches privVariables var: v at: 1) equals: 3.	self assert: t stack size equals: 0.! !!SThreadTest methodsFor: 'tests-color ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetColorTo	| w t ret |	w := self newWorld.	w create: 3 turtles: 2.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t push: 10.	t setColorTo.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t push: 15.	t setColorTo.	t := SThread sworld: w.	t forPatchId: 1.	t push: 20.	t setColorTo.	ret := w var: STurtleVarDef colorVarNo breed: 3 at: 1.	self assert: ret equals: 10.	ret := w var: STurtleVarDef colorVarNo breed: 3 at: 2.	self assert: ret equals: 15.	ret := w var: STurtleVarDef colorVarNo breed: 2 at: 1.	self assert: ret equals: 20.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 8/8/2019 18:21'!testSetHeading	| w t h |	w := self newWorld.	w create: 3 turtles: 2.	h := (w breedOf: 3) headingAt: 2.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	self assert: t stack size equals: 0.	t push: 10.	t setHeading.	self assert: t stack size equals: 0.	self assert: ((w breedOf: 3) headingAt: 1) equals: 10.	self assert: ((w breedOf: 3) headingAt: 2) equals: h.	t push: 20.	t setHeading.	self assert: t stack size equals: 0.	self assert: ((w breedOf: 3) headingAt: 1) equals: 20.	self assert: ((w breedOf: 3) headingAt: 2) equals: h.! !!SThreadTest methodsFor: 'tests-color ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetPatchColorTo	| w t ret |	w := self newWorld.	w create: 3 turtles: 2.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t push: 1.	t push: 10.	t setPatchColorTo.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t push: 2.	t push: 15.	t setPatchColorTo.	t := SThread sworld: w.	t forPatchId: 1.	t push: 3.	t push: 20.	t setPatchColorTo.	ret := w var: STurtleVarDef colorVarNo breed: 2 at: 1.	self assert: ret equals: 10.	ret := w var: STurtleVarDef colorVarNo breed: 2 at: 2.	self assert: ret equals: 15.	ret := w var: STurtleVarDef colorVarNo breed: 2 at: 3.	self assert: ret equals: 20.! !!SThreadTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 8/24/2019 18:17'!testSetVarTo	| w t v1 v2 |	w := self newWorld.	t := SThread sworld: w.	w create: 3 turtles: 1.	t forBreedNo: 3 index: 1.	v1 := (w breedOf: 3) addVariable: 'a'.	v2 := (w breedOf: 3) addVariable: 'b'.	self assert: (w var: v1 breed: 3 at: 1) equals: 0.	self assert: (w var: v2 breed: 3 at: 1) equals: 0.	self assert: t stack size equals: 0.	t push: v1.	t push: 123.	t setVarTo.	t push: v2.	t push: 456.	t setVarTo.	self assert: (w var: v1 breed: 3 at: 1) equals: 123.	self assert: (w var: v2 breed: 3 at: 1) equals: 456.	self assert: t stack size equals: 0.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetX	| w t |	w := self newWorld.	w create: 3 turtles: 2.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	self assert: t stack size equals: 0.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 0.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 2) equals: 0.	t push: 10.	t setX.	self assert: t stack size equals: 0.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 10.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 2) equals: 0.	t push: 20.	t setX.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 20.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 2) equals: 0.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetY	| w t |	w := self newWorld.	w create: 3 turtles: 2.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	self assert: t stack size equals: 0.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) equals: 0.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 2) equals: 0.	t push: 10.	t setY.	self assert: t stack size equals: 0.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) equals: 10.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 2) equals: 0.	t push: 20.	t setY.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) equals: 20.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 2) equals: 0.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testSin	| t |	t := SThread sworld: SMicroWorld new.	t push: 0.	self assert: t stack size equals: 1.	t sin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 90.	self assert: t stack size equals: 1.	t sin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 1.	t push: 180.	self assert: t stack size equals: 1.	t sin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 270.	self assert: t stack size equals: 1.	t sin.	self assert: t stack size equals: 1.	self assert: t pop closeTo: -1.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 9/4/2019 09:41'!testSqrt	| t |	t := SThread sworld: SMicroWorld new.	t push: 0.	self assert: t stack size equals: 1.	t sqrt.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 2.	self assert: t stack size equals: 1.	t sqrt.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 2 sqrt.	self deny: t isTerminated.	t push: -5.	self assert: t stack size equals: 1.	t sqrt.	self assert: t isTerminated.! !!SThreadTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 08:01'!testStack	| e |	e := SThread sworld: SMicroWorld new.	self assert: e stack isCollection.	self assert: e stack isEmpty.! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/10/2019 10:54'!testStop	| t |	t := SThread sworld: SMicroWorld new.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t stop.	self deny: t isRunning.	self deny: t isTerminated.! !!SThreadTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/10/2019 10:55'!testStopAll	| t |	t := SThread sworld: SMicroWorld new.	t codes: #(1 2 3).	self assert: t pc equals: 1.	t stopAll.	self deny: t isRunning.	self assert: t isTerminated.! !!SThreadTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testSwap	| t |	t := SThread sworld: SMicroWorld new.	t push: 1.	t push: 2.	t swap.	self assert: t pop equals: 1.	self assert: t pop equals: 2.! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testTan	| t |	t := SThread sworld: SMicroWorld new.	t push: 0.	self assert: t stack size equals: 1.	t tan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 0.	t push: 60.	self assert: t stack size equals: 1.	t tan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: 3 sqrt.	t push: 30.	self assert: t stack size equals: 1.	t tan.	self assert: t stack size equals: 1.	self assert: t pop closeTo: (1 / 3 sqrt).! !!SThreadTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 8/8/2019 08:01'!testTruncated	| t |	t := SThread sworld: SMicroWorld new.	t push: 1.4.	self assert: t stack size equals: 1.	t truncated.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: 1.5.	self assert: t stack size equals: 1.	t truncated.	self assert: t stack size equals: 1.	self assert: t pop equals: 1.	t push: -1.5.	self assert: t stack size equals: 1.	t truncated.	self assert: t stack size equals: 1.	self assert: t pop equals: -1.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 9/4/2019 13:19'!testTurtleAt	| w t ret pno |	w := self newWorld.	t := SThread sworld: w.	w create: 3 turtles: 2.	t forBreedNo: 3 index: 0.	self assert: t stack size equals: 0.	pno := w patches indexAtX: 0 y: 0.	t push: pno.	t push: 3.	t turtleAt.	ret := t pop.	self assert: (ret = 1 or: [ ret = 2 ]).	self assert: t stack size equals: 0.	t forBreedNo: 3 index: 1.	self assert: t stack size equals: 0.	pno := w patches indexAtX: 0 y: 0.	t push: pno.	t push: 3.	t turtleAt.	ret := t pop.	self assert: ret equals: 2.	self assert: t stack size equals: 0.	t forBreedNo: 3 index: 2.	self assert: t stack size equals: 0.	pno := w patches indexAtX: 0 y: 0.	t push: pno.	t push: 3.	t turtleAt.	ret := t pop.	self assert: ret equals: 1.	self assert: t stack size equals: 0.! !!SThreadTest methodsFor: 'tests-turtle ops' stamp: 'EiichiroIto 9/4/2019 21:47'!testXyOf	| w t |	w := self newWorld.	t := SThread sworld: w.	w createPatch: 4.	t push: 11.	t xyOf.	self assert: t pop equals: 0.	self assert: t pop equals: 0.	t push: 1.	t xyOf.	self assert: t pop equals: -2.	self assert: t pop equals: -2.	t push: 16.	t xyOf.	self assert: t pop equals: 1.	self assert: t pop equals: 1.	t push: 7.	t xyOf.	self assert: t pop equals: -1.	self assert: t pop equals: 0.! !!STurtleVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testAliveFlagNo	self assert: STurtleVarDef aliveFlagNo equals: 0.! !!STurtleVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testClassNameForVarNo	| pv |	pv := STurtleVarDef new.	self assert: (pv classNameForVarNo: STurtleVarDef colorVarNo) equals: #ByteArray.	self assert: (pv classNameForVarNo: STurtleVarDef flagVarNo) equals: #ByteArray.	self assert: (pv classNameForVarNo: STurtleVarDef xVarNo) equals: #FloatArray.	self assert: (pv classNameForVarNo: STurtleVarDef yVarNo) equals: #FloatArray.	self assert: (pv classNameForVarNo: STurtleVarDef headingVarNo) equals: #FloatArray! !!STurtleVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testColorVarNo	| v |	v := STurtleVarDef new.	self assert: (v varNoFor: 'color') equals: STurtleVarDef colorVarNo.! !!STurtleVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testFlagVarNo	| v |	v := STurtleVarDef new.	self assert: (v varNoFor: 'flag') equals: STurtleVarDef flagVarNo.! !!STurtleVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testHeadingVarNo	| v |	v := STurtleVarDef new.	self assert: (v varNoFor: 'heading') equals: STurtleVarDef headingVarNo.! !!STurtleVarDefTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 11/28/2019 22:09'!testInitialize	| v |	v := STurtleVarDef new.	self assert: v privVarNames size equals: 5.	self assert: (v includes: 'color').	self assert: (v includes: 'flag').	self assert: (v includes: 'x').	self assert: (v includes: 'y').	self assert: (v includes: 'heading').! !!STurtleVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testPenDownFlagNo	self assert: STurtleVarDef penDownFlagNo equals: 1.! !!STurtleVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testXVarNo	| v |	v := STurtleVarDef new.	self assert: (v varNoFor: 'x') equals: STurtleVarDef xVarNo.! !!STurtleVarDefTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/28/2019 22:09'!testYVarNo	| v |	v := STurtleVarDef new.	self assert: (v varNoFor: 'y') equals: STurtleVarDef yVarNo.! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 8/16/2019 17:16'!testAliveAt	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts clear.	ts create: 2.	self assert: ts countAlive equals: 2.	ts aliveAt: 1 put: false.	self assert: ts countAlive equals: 1.! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 8/16/2019 17:17'!testAliveAtPut	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts clear.	ts create: 3.	self assert: ts countAlive equals: 3.	ts aliveAt: 1 put: false.	ts aliveAt: 2 put: false.	self assert: ts countAlive equals: 1.	ts aliveAt: 2 put: true.	self assert: ts countAlive equals: 2.! !!STurtlesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/27/2019 16:32'!testBreedName	| ts |	ts := STurtles new.	ts breedNo: 5.	self assert: ts breedName equals: 'Turtle5'.	ts breedNo: 3.	self assert: ts breedName equals: 'Turtle3'.! !!STurtlesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 07:21'!testBreedNo	| ts |	ts := STurtles new.	self assert: ts breedNo isNil.	ts breedNo: 3.	self assert: ts breedNo equals: 3.	ts breedNo: 4.	self assert: ts breedNo equals: 4.! !!STurtlesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/16/2019 17:17'!testClear	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts create: 100.	self assert: ts countAlive equals: 100.	ts clear.	self assert: ts countAlive equals: 0.! !!STurtlesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 07:20'!testCopyTurtleFromTo	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts create: 2.	ts xAt: 1 put: 2.	ts yAt: 1 put: 3.	ts headingAt: 1 put: 30.	ts headingAt: 2 put: 60.	self assert: (ts xAt: 1) equals: 2.	self assert: (ts yAt: 1) equals: 3.	self assert: (ts xAt: 2) equals: 0.	self assert: (ts yAt: 2) equals: 0.	self assert: (ts headingAt: 1) equals: 30.	self assert: (ts headingAt: 2) equals: 60.	ts copyTurtleFrom: 1 to: 2.	self assert: (ts xAt: 1) equals: 2.	self assert: (ts yAt: 1) equals: 3.	self assert: (ts xAt: 2) equals: 2.	self assert: (ts yAt: 2) equals: 3.	self assert: (ts headingAt: 1) equals: 30.	self assert: (ts headingAt: 2) equals: 30! !!STurtlesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/16/2019 17:17'!testCountAlive	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts create: 10.	self assert: ts countAlive equals: 10.	ts aliveAt: 4 put: false.	ts aliveAt: 8 put: false.	self assert: ts countAlive equals: 8.! !!STurtlesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 8/16/2019 17:17'!testCreate	| ts |	ts := STurtles new breedNo: 3.	self assert: ts countAlive equals: 0.	ts create: 10.	self assert: ts countAlive equals: 10.! !!STurtlesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/8/2019 07:20'!testDefaultColor	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	self assert: (ts defaultColor between: 1 and: 140).! !!STurtlesTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 8/27/2019 16:31'!testDefaultPosition	| ts |	ts := STurtles new.	self assert: ts defaultPosition equals: 0 @ 0.	ts defaultPosition: 10 @ 20.	self assert: ts defaultPosition equals: 10 @ 20.! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 8/8/2019 07:20'!testDeltaAt	| ts delta |	ts := STurtles new breedNo: 3.	ts create: 2.	ts headingAt: 1 put: 30.	ts headingAt: 2 put: 60.	delta := ts deltaAt: 1.	self assert: delta equals: (Point r: 1.0 degrees: 30).	delta := ts deltaAt: 2.	self assert: delta equals: (Point r: 1.0 degrees: 60).! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 8/8/2019 07:20'!testHeadingAt	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts clear.	ts create: 2.	ts headingAt: 1 put: 10.	ts headingAt: 2 put: 20.	self assert: (ts headingAt: 1) equals: 10.	self assert: (ts headingAt: 2) equals: 20! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 3/13/2019 15:12'!testHeadingAtPut	self testHeadingAt.! !!STurtlesTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 11/28/2019 22:09'!testInitialize	| ts |	ts := STurtles new.	self assert: ts varId class equals: STurtleVarDef.	self assert: ts privVariables class equals: Variables.	self assert: ts countAlive equals: 0.! !!STurtlesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 8/8/2019 07:20'!testKillAt	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts clear.	ts create: 3.	self assert: (ts aliveAt: 1).	self assert: (ts aliveAt: 2).	self assert: (ts aliveAt: 3).	ts killAt: 1.	ts killAt: 3.	self assert: (ts aliveAt: 1) not.	self assert: (ts aliveAt: 2).	self assert: (ts aliveAt: 3) not.! !!STurtlesTest methodsFor: 'tests-enumerating' stamp: 'EiichiroIto 8/16/2019 17:18'!testLivingOnesDo	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts clear.	ts create: 5.	self assert: ts countAlive equals: 5.	ts livingOnesDo: [ :each | ts aliveAt: each put: false ].	self assert: ts countAlive equals: 0.! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 8/8/2019 07:20'!testPenDownAt	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts clear.	ts create: 2.	self assert: (ts penDownAt: 1) equals: false.	self assert: (ts penDownAt: 2) equals: false.	ts penDownAt: 1 put: true.	ts penDownAt: 2 put: false.	self assert: (ts penDownAt: 1) equals: true.	self assert: (ts penDownAt: 2) equals: false! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 3/13/2019 15:15'!testPenDownAtPut	self testPenDownAt.! !!STurtlesTest methodsFor: 'tests-printing' stamp: 'EiichiroIto 8/8/2019 07:20'!testPrintOn	| ts |	ts := STurtles new breedNo: 3.	self assert: ts asString equals: 'Turtles(0)'.	ts create: 10.	self assert: ts asString equals: 'Turtles(10)'.! !!STurtlesTest methodsFor: 'tests-private' stamp: 'EiichiroIto 10/18/2019 07:27'!testSetupAt	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts create: 3.	ts setupAt: 1.	ts setupAt: 2.	ts setupAt: 3.	self assert: (ts aliveAt: 1).	self assert: (ts aliveAt: 2).	self assert: (ts aliveAt: 3).	self deny: (ts penDownAt: 1).	self deny: (ts penDownAt: 2).	self deny: (ts penDownAt: 3).! !!STurtlesTest methodsFor: 'tests-command' stamp: 'EiichiroIto 8/8/2019 07:20'!testTurtlesAtPoint	| ts list |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts create: 5.	list := ts turtlesAtPoint: 0 @ 0.	self assertCollection: list asArray equals: #(1 2 3 4 5).	ts killAt: 3.	list := ts turtlesAtPoint: 0 @ 0.	self assertCollection: list asArray equals: #(1 2 4 5).	ts xAt: 2 put: 1.	list := ts turtlesAtPoint: 0 @ 0.	self assertCollection: list asArray equals: #(1 4 5).	ts yAt: 1 put: 1.	list := ts turtlesAtPoint: 0 @ 0.	self assertCollection: list asArray equals: #(4 5)! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 11/28/2019 22:09'!testVarAtPut	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts clear.	ts create: 2.	ts var: STurtleVarDef xVarNo at: 1 put: 2.	ts var: STurtleVarDef xVarNo at: 2 put: 5.	ts var: STurtleVarDef headingVarNo at: 1 put: 200.	ts var: STurtleVarDef headingVarNo at: 2 put: 400.	ts var: STurtleVarDef colorVarNo at: 1 put: 100.	ts var: STurtleVarDef colorVarNo at: 2 put: 200.	self assert: (ts xAt: 1) equals: 2.	self assert: (ts xAt: 2) equals: 5.	self assert: (ts headingAt: 1) equals: 200.	self assert: (ts headingAt: 2) equals: 40.	self assert: (ts colorAt: 1) equals: 100.	self assert: (ts colorAt: 2) equals: 200 \\ SColorList colors size.! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 8/8/2019 07:20'!testXAt	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts clear.	ts create: 2.	self assert: (ts xAt: 1) equals: 0.	self assert: (ts xAt: 2) equals: 0.	ts xAt: 1 put: 10.	ts xAt: 2 put: 20.	self assert: (ts xAt: 1) equals: 10.	self assert: (ts xAt: 2) equals: 20! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 3/13/2019 15:09'!testXAtPut	self testXAt.! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 8/8/2019 07:20'!testYAt	| ts |	ts := STurtles new breedNo: SBreedId turtleBreedNo.	ts clear.	ts create: 2.	self assert: (ts yAt: 1) equals: 0.	self assert: (ts yAt: 2) equals: 0.	ts yAt: 1 put: 10.	ts yAt: 2 put: 20.	self assert: (ts yAt: 1) equals: 10.	self assert: (ts yAt: 2) equals: 20! !!STurtlesTest methodsFor: 'tests-accessing variable' stamp: 'EiichiroIto 3/13/2019 15:09'!testYAtPut	self testYAt.! !!SteloBytecodeGeneratorTest methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 11:27'!newWorld	| w |	w := SMicroWorld new.	w addBreed: SPatches new.	w addBreed: (STurtles new breedNo: 3).	^ w! !!SteloBytecodeGeneratorTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/24/2019 20:03'!testAddress	| b |	b := SteloBytecodeGenerator new.	self assert: b address equals: 1.	b address: 100.	self assert: b address equals: 100.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testAddressOfSubName	| b d |	b := SteloBytecodeGenerator new.	self should: [ b addressOfSubName: 'abc' ] raise: Error.	d := Dictionary new.	b subTable: d.	self should: [ b addressOfSubName: 'abc' ] raise: Error.	d at: 'abc' put: 123.	d at: 'def' put: 456.	self assert: (b addressOfSubName: 'abc') equals: 123.	self assert: (b addressOfSubName: 'def') equals: 456.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testAimHighVar	| w v ret b t |	w := SMicroWorld new.	w addBreed: SPatches new.	w addBreed: (STurtles new breedNo: 3).	w createPatch: 5.	w create: 3 turtles: 1.	v := w patches addVariable: 'a'.	"	21 22 23 24 25	16 17 18 19 20	11 12 13 14 15	 6  7  8  9 10	 1  2  3  4  5"	w x: 3 at: 1 put: 0.	w y: 3 at: 1 put: 0.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 45.	w		var: v		breed: 2		at: 18		put: 1.	w		var: v		breed: 2		at: 19		put: 2.	w		var: v		breed: 2		at: 14		put: 3.	b := SteloBytecodeGenerator new.	b aimHighVar: v.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	ret := t evaluate: 1.	self assert: ret equals: -45! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testAndWith	| t b r |	b := SteloBytecodeGenerator new.	r := b and: true with: true.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b and: true with: false.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b and: false with: true.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b and: false with: false.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testAppendCall	| b r |	b := SteloBytecodeGenerator new.	b subTable: { 'def'->123 } asDictionary.	self assert: b privStream contents isEmpty.	b appendCall: 'def'.	self assert: b privStream contents size equals: 1.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeCall.	self assert: r subName equals: 'def'.	self assert: r address equals: 123.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testAppendLabel	| b r |	b := SteloBytecodeGenerator new.	self assert: b privStream contents isEmpty.	b appendLabel: 123.	b appendLabel: 456.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeLabel.	self assert: r id equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeLabel.	self assert: r id equals: 456.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testAppendSymbol	| b r |	b := SteloBytecodeGenerator new.	self assert: b privStream contents isEmpty.	b appendSymbol: #abc.	b appendSymbol: #def.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #def.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testAppendSymbolWithJump	| b r |	b := SteloBytecodeGenerator new.	self assert: b privStream contents isEmpty.	b appendSymbol: #abc withJump: 12.	b appendSymbol: #def withJump: 34.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeSymbolWithJump.	self assert: r selector equals: #abc.	self assert: r labelId equals: 12.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeSymbolWithJump.	self assert: r selector equals: #def.	self assert: r labelId equals: 34.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testAppendValue	| b r |	b := SteloBytecodeGenerator new.	self assert: b privStream contents isEmpty.	b appendValue: 123.	b appendValue: 456.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 456.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testBinaryCommandArg1Arg2	| b r |	b := SteloBytecodeGenerator new.	self assert: b privStream contents isEmpty.	b binaryCommand: #abc arg1: 123 arg2: 456.	self assert: b privStream contents size equals: 3.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 456.	r := b privStream contents third.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testBroadcast	| w b t e eventId |	w := self newWorld.	w create: 3 turtles: 1.	eventId := EventId new.	e := eventId newNo.	b := SteloBytecodeGenerator new.	b broadcast: e.	self assert: w raisedEvents isEmpty.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w raisedEvents includes: e).! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testCallSub	| b r |	b := SteloBytecodeGenerator new.	b subTable: { 'abc'->9. 'def'->3 } asDictionary.	b return: 1.	b callSub: 'def'.	b address: 5.	r := b code.	self assertCollection: r equals: #(push1 return pushShort 3 0 call stop).! !!SteloBytecodeGeneratorTest methodsFor: 'tests-patch ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testChangePatchVaratBy	| w b vid t pno |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1.	vid := w patches addVariable: 'a'.	w patches var: vid at: 2 put: 1.	w patches var: vid at: 5 put: 2.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 0 y: 0.	b changePatchVar: vid at: pno by: 5.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w patches var: vid at: 2) equals: 1.	self assert: (w patches var: vid at: 5) equals: 7.	w y: 3 at: 1 put: -1.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 0 y: -1.	b changePatchVar: vid at: pno by: 5.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w patches var: vid at: 2) equals: 6.	self assert: (w patches var: vid at: 5) equals: 7! !!SteloBytecodeGeneratorTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testChangeVarBy	| w vid b t |	w := self newWorld.	w create: 3 turtles: 2.	vid := (w breedOf: 3) addVariable: 'a'.	w		var: vid		breed: 3		at: 1		put: 5.	b := SteloBytecodeGenerator new.	b changeVar: vid by: 10.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w var: vid breed: 3 at: 1) equals: 15.	self assert: (w var: vid breed: 3 at: 2) equals: 0.	b := SteloBytecodeGenerator new.	b changeVar: vid by: -1.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	t execute: 1.	self assert: (w var: vid breed: 3 at: 1) equals: 15.	self assert: (w var: vid breed: 3 at: 2) equals: -1! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testChangeXposBy	| w b t |	w := self newWorld.	w create: 3 turtles: 2.	w		var: STurtleVarDef xVarNo		breed: 3		at: 1		put: 3.	w		var: STurtleVarDef xVarNo		breed: 3		at: 2		put: 4.	b := SteloBytecodeGenerator new.	b changeXposBy: 3.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	t execute: 1.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 3.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 2) equals: 7! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testChangeYposBy	| w b t |	w := self newWorld.	w create: 3 turtles: 2.	w		var: STurtleVarDef yVarNo		breed: 3		at: 1		put: 3.	w		var: STurtleVarDef yVarNo		breed: 3		at: 2		put: 4.	b := SteloBytecodeGenerator new.	b changeYposBy: 3.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	t execute: 1.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) equals: 3.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 2) equals: 7! !!SteloBytecodeGeneratorTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testClearAll	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 2.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 1		put: 3.	b := SteloBytecodeGenerator new.	b clearAll.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 3.	self assert: w patches size equals: 9.	self assert: (w breedOf: 3) countAlive equals: 2.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 0.	self assert: w patches size equals: 9.	self assert: (w breedOf: 3) countAlive equals: 0! !!SteloBytecodeGeneratorTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testClearGraphics	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 2.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 1		put: 3.	b := SteloBytecodeGenerator new.	b clearGraphics.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 3.	self assert: w patches size equals: 9.	self assert: (w breedOf: 3) countAlive equals: 2.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 0.	self assert: w patches size equals: 9.	self assert: (w breedOf: 3) countAlive equals: 2! !!SteloBytecodeGeneratorTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testClearTurtles	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 2.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 1		put: 3.	b := SteloBytecodeGenerator new.	b clearTurtles.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 3.	self assert: w patches size equals: 9.	self assert: (w breedOf: 3) countAlive equals: 2.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 3.	self assert: w patches size equals: 9.	self assert: (w breedOf: 3) countAlive equals: 0! !!SteloBytecodeGeneratorTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/24/2019 20:03'!testCode	| b arr |	b := SteloBytecodeGenerator new.	b forward: 1.	b turn: 15.	arr := b code.	self assertCollection: arr equals: #(push1 forward pushShort 15 0 pushShort 5 0 getVar plus setHeading stop).! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testComputeFunctionOf	| t b r |	b := SteloBytecodeGenerator new.	r := b computeFunction: #abs of: -1.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b computeFunction: #abs of: 10.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := SteloBytecodeGenerator new.	r := b computeFunction: #sqrt of: 2.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 2 sqrt.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testCreatePatchesSize	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 2.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 1		put: 3.	b := SteloBytecodeGenerator new.	b createPatchesSize: 4.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 3.	self assert: w patches size equals: 9.	self assert: (w breedOf: 3) countAlive equals: 2.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 0.	self assert: w patches size equals: 16.	self assert: (w breedOf: 3) countAlive equals: 0! !!SteloBytecodeGeneratorTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testCreateTurtleSizeBreedId	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 2.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 1		put: 3.	b := SteloBytecodeGenerator new.	b createTurtleSize: 3 breedId: 3.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 3.	self assert: w patches size equals: 9.	self assert: (w breedOf: 3) countAlive equals: 2.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: 3.	self assert: w patches size equals: 9.	self assert: (w breedOf: 3) countAlive equals: 5! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testDie	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 2.	b := SteloBytecodeGenerator new.	b die.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 2).	t codes: b code.	t execute: 1.	self deny: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 2).	t := SThread sworld: w.	t forPatchId: 2.	t codes: b code.	t execute: 1.	self deny: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 2)! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testDiffuse4VarPercentage	| w b v t arr |	w := self newWorld.	w createPatch: 4.	v := w patches addVariable: 'a'.	b := SteloBytecodeGenerator new.	b diffuse4Var: v percentage: 80.	"10  0  0  0    2  2  0  2 0  0  0  0    2  0  0  0 0  0  0  0 -> 0  0  0  0 0  0  0  0    2  0  0  0"	w patches var: v at: 1 put: 10.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(2 2 0 2 2 0 0 0 0 0 0 0 2 0 0 0) asFloatArray.	" 0  0  0 10    2  0  2  2 0  0  0  0    0  0  0  2 0  0  0  0 -> 0  0  0  0 0  0  0  0    0  0  0  2"	w patches privVariables clearVarNo: v.	w patches var: v at: 4 put: 10.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(2 0 2 2 0 0 0 2 0 0 0 0 0 0 0 2) asFloatArray.	" 0  0  0  0    2  0  0  0 0  0  0  0    0  0  0  0 0  0  0  0 -> 2  0  0  010  0  0  0    2  2  0  2"	w patches privVariables clearVarNo: v.	w patches var: v at: 13 put: 10.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(2 0 0 0 0 0 0 0 2 0 0 0 2 2 0 2) asFloatArray.	" 0  0  0  0    0  0  0  2 0  0  0  0    0  0  0  0 0  0  0  0 -> 0  0  0  2 0  0  0 10    2  0  2  2"	w patches privVariables clearVarNo: v.	w patches var: v at: 16 put: 10.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(0 0 0 2 0 0 0 0 0 0 0 2 2 0 2 2) asFloatArray.	w createPatch: 3.	w patches privVariables clearVarNo: v.	w patches var: v at: 5 put: 100.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(0 20 0 20 20 20 0 20 0) asFloatArray! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testDiffuseVarPercentage	| w b v t arr |	w := self newWorld.	w createPatch: 4.	v := w patches addVariable: 'a'.	b := SteloBytecodeGenerator new.	b diffuseVar: v percentage: 80.	"10  0  0  0    2  2  0  2 0  0  0  0    2  0  0  0 0  0  0  0 -> 0  0  0  0 0  0  0  0    2  0  0  0"	w patches var: v at: 1 put: 10.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(2 1 0 1 1 1 0 1 0 0 0 0 1 1 0 1) asFloatArray.	" 0  0  0 10    2  0  2  2 0  0  0  0    0  0  0  2 0  0  0  0 -> 0  0  0  0 0  0  0  0    0  0  0  2"	w patches privVariables clearVarNo: v.	w patches var: v at: 4 put: 10.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(1 0 1 2 1 0 1 1 0 0 0 0 1 0 1 1) asFloatArray.	" 0  0  0  0    2  0  0  0 0  0  0  0    0  0  0  0 0  0  0  0 -> 2  0  0  010  0  0  0    2  2  0  2"	w patches privVariables clearVarNo: v.	w patches var: v at: 13 put: 10.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(1 1 0 1 0 0 0 0 1 1 0 1 2 1 0 1) asFloatArray.	" 0  0  0  0    0  0  0  2 0  0  0  0    0  0  0  0 0  0  0  0 -> 0  0  0  2 0  0  0 10    2  0  2  2"	w patches privVariables clearVarNo: v.	w patches var: v at: 16 put: 10.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(1 0 1 1 0 0 0 0 1 0 1 1 1 0 1 2) asFloatArray.	w createPatch: 3.	w patches privVariables clearVarNo: v.	w patches var: v at: 5 put: 100.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	arr := w patches privVariables realArrayAt: v.	self		assertCollection: arr		equals: #(10 10 10 10 20 10 10 10 10) asFloatArray! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testDirectionTo	| w t b r pno |	w := self newWorld.	w createPatch: 5.	w create: 3 turtles: 2.	w x: 3 at: 2 put: 1.	"1  2  3  4  5	 6  7  8  9 10	11 12 13 14 15	16 17 18 19 20	21 22 23 24 25"	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 2 y: 1.	r := b directionTo: pno.	self assert: r isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	r := t evaluate: 1.	self assert: r closeTo: 0.5 arcTan radiansToDegrees.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	r := t evaluate: 1.	self assert: r closeTo: 1 arcTan radiansToDegrees.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testDistanceTo	| w t b r pno |	w := self newWorld.	w create: 3 turtles: 2.	w x: 3 at: 2 put: 1.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 2 y: 1.	r := b distanceTo: pno.	self assert: r isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	r := t evaluate: 1.	self assert: r closeTo: 5 sqrt.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	r := t evaluate: 1.	self assert: r closeTo: 2 sqrt! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testDivideBy	| t b r |	b := SteloBytecodeGenerator new.	r := b divide: 100 by: 2.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 50.	b := SteloBytecodeGenerator new.	r := b divide: 12 by: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 4.	b := SteloBytecodeGenerator new.	r := b divide: 10 by: -2.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: -5.	b := SteloBytecodeGenerator new.	r := b divide: 1 by: 5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.2.	b := SteloBytecodeGenerator new.	r := b divide: 2 by: -4.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: -0.5.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testDoIfBegin	| w b t i |	w := self newWorld.	w create: 3 turtles: 1.	b := SteloBytecodeGenerator new.	b appendValue: false.	i := b doIfBegin: nil.	b die.	b doIfEnd: i.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	b := SteloBytecodeGenerator new.	b appendValue: true.	i := b doIfBegin: nil.	b die.	b doIfEnd: i.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self deny: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1)! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testDoIfElse	| w b t i |	w := self newWorld.	w create: 3 turtles: 2.	w		var: STurtleVarDef colorVarNo		breed: 3		at: 1		put: 0.	w		var: STurtleVarDef colorVarNo		breed: 3		at: 2		put: 0.	b := SteloBytecodeGenerator new.	b appendValue: false.	i := b doIfBegin: nil.	b die.	i := b doIfElse: i.	b setVar: STurtleVarDef colorVarNo to: 15.	b doIfEnd: i.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 1)		equals: 0.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 1)		equals: 15.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	b := SteloBytecodeGenerator new.	b appendValue: true.	i := b doIfBegin: nil.	b die.	i := b doIfElse: i.	b setVar: STurtleVarDef colorVarNo to: 15.	b doIfEnd: i.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 2)		equals: 0.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 2).	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	t execute: 1.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 2)		equals: 0.	self deny: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 2)! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/21/2018 15:55'!testDoIfEnd	self testDoIfBegin.	self testDoIfElse.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testDoRepeatBegin	| w b t arr |	w := self newWorld.	w create: 3 turtles: 1.	(w breedOf: 3) headingAt: 1 put: 0.	b := SteloBytecodeGenerator new.	b appendValue: false.	arr := b doRepeatBegin: 5.	b forward: 1.	b doRepeatEndLabels: arr.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 0.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 5! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/21/2018 16:01'!testDoRepeatEndLabels	self testDoRepeatBegin.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testDoUntilBegin	| w b t i |	w := self newWorld.	w create: 3 turtles: 1.	(w breedOf: 3) headingAt: 1 put: 0.	b := SteloBytecodeGenerator new.	i := b doUntilBegin.	b forward: 1.	b appendValue: 5.	b getXpos.	b appendSymbol: #less.	b doUntilEnd: nil id: i.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 0.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 6! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/21/2018 16:10'!testDoUntilEndId	self testDoUntilBegin.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testDx	| w b t |	w := self newWorld.	w createPatch: 5.	w create: 3 turtles: 2.	(w breedOf: 3) headingAt: 1 put: 45.	(w breedOf: 3) headingAt: 2 put: 60.	b := SteloBytecodeGenerator new.	b dx.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) closeTo: 45 degreeCos.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	self assert: (t evaluate: 1) closeTo: 60 degreeCos! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testDy	| w b t |	w := self newWorld.	w createPatch: 5.	w create: 3 turtles: 2.	(w breedOf: 3) headingAt: 1 put: 45.	(w breedOf: 3) headingAt: 2 put: 60.	b := SteloBytecodeGenerator new.	b dy.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) closeTo: 45 degreeSin.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	self assert: (t evaluate: 1) closeTo: 60 degreeSin! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testEqualTo	| t b r |	b := SteloBytecodeGenerator new.	r := b equal: 12 to: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b equal: 10 to: -3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b equal: 5 to: 5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b equal: -2.5 to: -2.5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testForward	| w b t |	w := self newWorld.	w create: 3 turtles: 2.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 0.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) equals: 0.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 2) equals: 0.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 2) equals: 0.	(w breedOf: 3) headingAt: 1 put: 45.	b := SteloBytecodeGenerator new.	b forward: 2 sqrt.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 1.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) equals: 1.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 2) equals: 0.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 2) equals: 0! !!SteloBytecodeGeneratorTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testGetBreedId	| w b t ret |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1.	b := SteloBytecodeGenerator new.	ret := b getBreedId.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 3.	t := SThread sworld: w.	t forPatchId: 2.	t codes: b code.	self assert: (t evaluate: 1) equals: 2.	t := SThread sworld: w.	t forObserver.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-color ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testGetColor	| w b t ret |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1.	w		var: STurtleVarDef colorVarNo		breed: 3		at: 1		put: SColorList red.	w		var: STurtleVarDef colorVarNo		breed: 3		at: 2		put: SColorList yellow.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 1		put: SColorList green.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 2		put: SColorList blue.	b := SteloBytecodeGenerator new.	ret := b getColor.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	ret := t evaluate: 1.	self assert: ret equals: SColorList red.	t := SThread sworld: w.	t forPatchId: 2.	t codes: b code.	ret := t evaluate: 1.	self assert: ret equals: SColorList blue! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testGetId	| w b t ret |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1.	b := SteloBytecodeGenerator new.	ret := b getId.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	t := SThread sworld: w.	t forPatchId: 2.	t codes: b code.	self assert: (t evaluate: 1) equals: 2.	t := SThread sworld: w.	t forPatchId: 3.	t codes: b code.	self assert: (t evaluate: 1) equals: 3.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 12/1/2019 13:04'!testGetObserverVar	| w b t ret |	w := self newWorld.	w addBreed: SObserver new.	w create: 3 turtles: 1.	b := SteloBytecodeGenerator new.	ret := b getObserverVar: SObserverVarDef widthVarNo.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 100.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	w createPatch: 10.	t codes: b code.	self assert: (t evaluate: 1) equals: 10! !!SteloBytecodeGeneratorTest methodsFor: 'tests-patch ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testGetPatchColorAt	| w b t ret pno |	w := self newWorld.	"	1 2 3	4 5 6	7 8 9"	w createPatch: 3.	w create: 3 turtles: 1.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 3		put: SColorList green.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 5		put: SColorList blue.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 6		put: SColorList yellow.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 7		put: SColorList red.	w		var: SPatchVarDef colorVarNo		breed: 2		at: 9		put: SColorList lime.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 1 y: 2.	ret := b getPatchColorAt: pno.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	ret := t evaluate: 1.	self assert: ret equals: SColorList green.	b := SteloBytecodeGenerator new.	ret := b getPatchColorAt: 9.	t := SThread sworld: w.	t forPatchId: 2.	t codes: b code.	ret := t evaluate: 1.	self assert: ret equals: SColorList lime! !!SteloBytecodeGeneratorTest methodsFor: 'tests-patch ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testGetPatchVarAt	| w b vid t ret pno |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1.	vid := w patches addVariable: 'a'.	w patches var: vid at: 5 put: 4.	w patches var: vid at: 2 put: 8.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 0 y: 0.	ret := b getPatchVar: vid at: pno.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 4.	w y: 3 at: 1 put: -1.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 4.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testGetVar	| w vid b t ret |	w := self newWorld.	w create: 3 turtles: 2.	vid := (w breedOf: 3) addVariable: 'a'.	b := SteloBytecodeGenerator new.	ret := b getVar: vid.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	w		var: vid		breed: 3		at: 1		put: 20.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 20! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testGetVarBreedNoIndex	| w b vid t ret |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1.	vid := (w breedOf: 3) addVariable: 'a'.	w		var: vid		breed: 3		at: 1		put: 4.	w		var: vid		breed: 3		at: 2		put: 5.	b := SteloBytecodeGenerator new.	ret := b getVar: [ :x | vid ] breedNo: 3 index: 2.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 5! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testGetXpos	| w b t ret |	w := self newWorld.	w createPatch: 5.	w create: 3 turtles: 2.	w x: 3 at: 1 put: 2.	w x: 3 at: 2 put: 3.	b := SteloBytecodeGenerator new.	ret := b getXpos.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 2.	b := SteloBytecodeGenerator new.	b getXpos.	t := SThread sworld: w.	t forPatchId: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: -2.	b := SteloBytecodeGenerator new.	b getXpos.	t := SThread sworld: w.	t forPatchId: 7.	t codes: b code.	self assert: (t evaluate: 1) equals: -1! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testGetYpos	| w b t ret |	w := self newWorld.	w createPatch: 5.	w create: 3 turtles: 2.	w y: 3 at: 1 put: 2.	w y: 3 at: 2 put: 3.	b := SteloBytecodeGenerator new.	ret := b getYpos.	self assert: ret isNil.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 2.	b := SteloBytecodeGenerator new.	b getYpos.	t := SThread sworld: w.	t forPatchId: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: -2.	b := SteloBytecodeGenerator new.	b getYpos.	t := SThread sworld: w.	t forPatchId: 7.	t codes: b code.	self assert: (t evaluate: 1) equals: -1! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testHatch	| w b t |	w := self newWorld.	w create: 3 turtles: 1.	w		var: STurtleVarDef colorVarNo		breed: 3		at: 1		put: 15.	b := SteloBytecodeGenerator new.	b hatch.	self assert: (w breedOf: 3) countAlive equals: 1.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w breedOf: 3) countAlive equals: 2.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 1)		equals: 15.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 2)		equals: 15! !!SteloBytecodeGeneratorTest methodsFor: 'tests-patch ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testHere	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1."1 2 3 4 5 6 7 8 9"	w var: STurtleVarDef xVarNo breed: SBreedId turtleBreedNo at: 1 put: 0.	w var: STurtleVarDef yVarNo breed: SBreedId turtleBreedNo at: 1 put: 0.	b := SteloBytecodeGenerator new.	b here.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 5.	w var: STurtleVarDef xVarNo breed: SBreedId turtleBreedNo at: 1 put: 1.	b := SteloBytecodeGenerator new.	b here.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 6.	w var: STurtleVarDef yVarNo breed: SBreedId turtleBreedNo at: 1 put: -1.	b := SteloBytecodeGenerator new.	b here.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 3.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-initialization' stamp: 'EiichiroIto 9/20/2018 18:59'!testInitialize	self testPrivLabelId.	self testPrivStream.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testIsBetweenAnd	| t b r |	b := SteloBytecodeGenerator new.	r := b is: 10 between: 3 and: 12.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b is: 10 between: 10 and: 12.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b is: 12 between: 10 and: 12.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b is: 9 between: 10 and: 12.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b is: 13 between: 10 and: 12.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testIsPenDown	| w b t r |	w := self newWorld.	w create: 3 turtles: 2.	w		var: STurtleVarDef flagVarNo		breed: 3		at: 1		put: 1.	w		var: STurtleVarDef flagVarNo		breed: 3		at: 2		put: 3.	b := SteloBytecodeGenerator new.	b isPenDown.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	r := t evaluate: 1.	self assert: r equals: 0.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	r := t evaluate: 1.	self assert: r equals: 1.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testKillBreed	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 3.	b := SteloBytecodeGenerator new.	b kill: 2 breed: 3.	t := SThread sworld: w.	t forBreedNo: 3 index: 3.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 2).	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 3).	t codes: b code.	t execute: 1.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	self deny: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 2).	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 3)! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testLabelsAndJumpsFor	| b arr |	b := SteloBytecodeGenerator new.	b appendLabel: b privLabelId newNo.	b appendValue: 1.	b appendValue: 2.	b appendLabel: b privLabelId newNo.	b appendSymbol: #a.	b appendLabel: b privLabelId newNo.	b appendValue: 2.	b appendSymbol: #a withJump: 1.	arr := b labelsAndJumpsFor: b privStream contents.	self assertCollection: arr first equals: #(1 5 6).	self assert: arr second size equals: 1.	self assert: arr second first selector equals: #a.	self assert: b address equals: 13.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testLessEqualThan	| t b r |	b := SteloBytecodeGenerator new.	r := b lessEqual: 12 than: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b lessEqual: -10 than: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b lessEqual: 5 than: 5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b lessEqual: -2.5 than: -2.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testLessThan	| t b r |	b := SteloBytecodeGenerator new.	r := b less: 12 than: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b less: -10 than: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b less: 5 than: 5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b less: -2.5 than: -2.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testMinusWith	| t b r |	b := SteloBytecodeGenerator new.	r := b minus: 12 with: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 9.	b := SteloBytecodeGenerator new.	r := b minus: 10 with: -3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 13.	b := SteloBytecodeGenerator new.	r := b minus: 1.5 with: 5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: -3.5.	b := SteloBytecodeGenerator new.	r := b minus: -2 with: -4.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 2.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testModBy	| t b r |	b := SteloBytecodeGenerator new.	r := b mod: 12 by: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b mod: 10 by: -3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: -2.	b := SteloBytecodeGenerator new.	r := b mod: 1 by: 5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b mod: -2 by: 4.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 2.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testMultiplyAnd	| t b r |	b := SteloBytecodeGenerator new.	r := b multiply: 12 and: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 36.	b := SteloBytecodeGenerator new.	r := b multiply: 10 and: -3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: -30.	b := SteloBytecodeGenerator new.	r := b multiply: 1.5 and: 5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 7.5.	b := SteloBytecodeGenerator new.	r := b multiply: -2 and: -4.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 8.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-observer ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testMultiplyVarBy	| w v b t |	w := self newWorld.	w createPatch: 3.	v := w patches addVariable: 'a'.	b := SteloBytecodeGenerator new.	b multiplyVar: v by: 2.	w patches var: v at: 1 put: 1.	w patches var: v at: 5 put: 2.	w patches var: v at: 7 put: 3.	w patches var: v at: 8 put: 4.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	self		assertCollection: (w patches privVariables realArrayAt: v)		equals: #(2 0 0 0 4 0 6 8 0) asFloatArray! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testNot	| t b r |	b := SteloBytecodeGenerator new.	r := b not: true.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	b := SteloBytecodeGenerator new.	r := b not: false.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testNsum4VarTo	| w v1 v2 b t |	w := self newWorld.	w createPatch: 4.	v1 := w patches addVariable: 'a'.	v2 := w patches addVariable: 'b'.	b := SteloBytecodeGenerator new.	b nsum4Var: v1 to: v2.	"0 1 0 0     1 0 2 30 0 1 0 --> 0 4 0 10 2 0 0     2 0 3 30 0 0 3     3 3 3 0"	w patches var: v1 at: 2 put: 1.	w patches var: v1 at: 7 put: 1.	w patches var: v1 at: 10 put: 2.	w patches var: v1 at: 16 put: 3.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	self		assertCollection: (w patches privVariables realArrayAt: v2)		equals: #(1 0 2 3 0 4 0 1 2 0 3 3 3 3 3 0) asFloatArray! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testNsumVarTo	| w v1 v2 b t |	w := self newWorld.	w createPatch: 4.	v1 := w patches addVariable: 'a'.	v2 := w patches addVariable: 'b'.	b := SteloBytecodeGenerator new.	b nsumVar: v1 to: v2.	"0 1 0 0     4 1 5 40 0 1 0 --> 3 4 3 10 2 0 0     5 1 6 40 0 0 3     6 3 6 0"	w patches var: v1 at: 2 put: 1.	w patches var: v1 at: 7 put: 1.	w patches var: v1 at: 10 put: 2.	w patches var: v1 at: 16 put: 3.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	self		assertCollection: (w patches privVariables realArrayAt: v2)		equals: #(4 1 5 4 3 4 3 1 5 1 6 4 6 3 6 0) asFloatArray! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testNullaryCommand	| b r |	b := SteloBytecodeGenerator new.	self assert: b privStream contents isEmpty.	b nullaryCommand: #abc.	self assert: b privStream contents size equals: 1.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testOrWith	| t b r |	b := SteloBytecodeGenerator new.	r := b or: true with: true.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b or: true with: false.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b or: false with: true.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	r := b or: false with: false.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-patch ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testPatchAtXY	| w b t |	w := self newWorld.	w createPatch: 3.	b := SteloBytecodeGenerator new.	b patchAtX: 0 y: 0.	t := SThread sworld: w.	t codes: b code.	self assert: (t evaluate: 1) equals: 5.	b := SteloBytecodeGenerator new.	b patchAtX: -1 y: 1.	t := SThread sworld: w.	t codes: b code.	self assert: (t evaluate: 1) equals: 7.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testPenDown	| w b t r |	w := self newWorld.	w create: 3 turtles: 1.	w		var: STurtleVarDef flagVarNo		breed: 3		at: 1		put: 1.	b := SteloBytecodeGenerator new.	b penDown: true.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	r := w var: STurtleVarDef flagVarNo breed: 3 at: 1.	self assert: r equals: 1 + (1 << STurtleVarDef penDownFlagNo).	b := SteloBytecodeGenerator new.	b penDown: false.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	r := w var: STurtleVarDef flagVarNo breed: 3 at: 1.	self assert: r equals: 1! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testPlusAnd	| t b r |	b := SteloBytecodeGenerator new.	r := b plus: 12 and: 3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 15.	b := SteloBytecodeGenerator new.	r := b plus: 10 and: -3.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 7.	b := SteloBytecodeGenerator new.	r := b plus: 1.5 and: 5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 6.5.	b := SteloBytecodeGenerator new.	r := b plus: -2 and: -4.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: -6.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testPrivLabelId	| b |	b := SteloBytecodeGenerator new.	self assert: b privLabelId class equals: BaseId.	self assert: b privLabelId size equals: 0.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testPrivStream	| b |	b := SteloBytecodeGenerator new.	self assert: b privStream isStream.	self assert: b privStream contents isArray.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testRandomFromTo	| t b r |	b := SteloBytecodeGenerator new.	10		timesRepeat: [ r := b randomFrom: 1 to: 10.			self assert: r isNil.			t := SThread sworld: SMicroWorld new.			t codes: b code.			self assert: ((t evaluate: 1) between: 1 and: 10) ].! !!SteloBytecodeGeneratorTest methodsFor: 'test' stamp: 'EiichiroIto 11/24/2019 20:03'!testRelativeToRTheta	| w b t |	w := self newWorld.	w createPatch: 5.	w create: 3 turtles: 1." 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"	b := SteloBytecodeGenerator new.	b relativeToR: 1 theta: 0.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 14.	b := SteloBytecodeGenerator new.	b relativeToR: 1 theta: 90.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 18.	b := SteloBytecodeGenerator new.	b relativeToR: 1 theta: 180.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 12.	b := SteloBytecodeGenerator new.	b relativeToR: 1 theta: 270.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 8.	b := SteloBytecodeGenerator new.	b relativeToR: 2 theta: 0.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 15.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-patch ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testRelativeToXY	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1."1 2 3 4 5 6 7 8 9"	b := SteloBytecodeGenerator new.	b patchAtX: 0 y: 0.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 5.	b := SteloBytecodeGenerator new.	b relativeToX: -1 y: 0.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 4.	b := SteloBytecodeGenerator new.	b relativeToX: 0 y: 1.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 8.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testResolveJumpAddressUsing	| b fp arr |	b := SteloBytecodeGenerator new.	b appendLabel: b privLabelId newNo.	b appendValue: 1.	b appendValue: 2.	b appendSymbol: #a withJump: 3.	b appendLabel: b privLabelId newNo.	b appendSymbol: #b.	b appendLabel: b privLabelId newNo.	b appendValue: 2.	b appendSymbol: #c withJump: 2.	fp := b privStream contents.	self assert: (fp at: 4) address equals: nil.	self assert: (fp at: 9) address equals: nil.	arr := b labelsAndJumpsFor: fp.	b resolveJumpAddress: arr second using: arr first.	self assert: (fp at: 4) address equals: 10.	self assert: (fp at: 9) address equals: 9.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 9/12/2019 13:21'!testReturn	self testCallSub.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testReturnValue	| b r |	b := SteloBytecodeGenerator new.	b returnValue.	b address: 5.	r := b code.	self assertCollection: r equals: #(returnValue stop).! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testRounded	| t b r |	b := SteloBytecodeGenerator new.	r := b rounded: 10.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := SteloBytecodeGenerator new.	r := b rounded: 10.2.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := SteloBytecodeGenerator new.	r := b rounded: 10.5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 11.	b := SteloBytecodeGenerator new.	r := b rounded: -10.5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: -11.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-color ops' stamp: 'EiichiroIto 12/1/2019 13:04'!testScaleValueColorFromTo	| w v b t |	w := self newWorld.	w addBreed: SObserver new.	w createPatch: 4.	v := w patches addVariable: 'a'.	b := SteloBytecodeGenerator new.	b		scaleValue: v		color: 15		from: 1		to: 9.	w patches var: v at: 1 put: 0.	w patches var: v at: 2 put: 1.	w patches var: v at: 3 put: 2.	w patches var: v at: 4 put: 3.	w patches var: v at: 5 put: 4.	w patches var: v at: 6 put: 5.	w patches var: v at: 7 put: 6.	w patches var: v at: 8 put: 7.	w patches var: v at: 9 put: 8.	w patches var: v at: 10 put: 9.	w patches var: v at: 11 put: 10.	t := SThread sworld: w.	t forObserver.	t codes: b code.	t execute: 1.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 1)		equals: SColorList black.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 6)		equals: SColorList red - 1.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 7)		equals: SColorList red.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 8)		equals: SColorList red + 1.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 11)		equals: SColorList white.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 12)		equals: SColorList black.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 13)		equals: SColorList black.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 14)		equals: SColorList black.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 15)		equals: SColorList black.	self		assert: (w patches var: SPatchVarDef colorVarNo at: 16)		equals: SColorList black! !!SteloBytecodeGeneratorTest methodsFor: 'tests-color ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetColorTo	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1.	w		var: STurtleVarDef colorVarNo		breed: 3		at: 1		put: SColorList red.	w		var: STurtleVarDef colorVarNo		breed: 3		at: 2		put: SColorList red.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 1)		equals: SColorList red.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 2)		equals: SColorList red.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: SColorList black.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 2)		equals: SColorList black.	b := SteloBytecodeGenerator new.	b setColorTo: SColorList yellow.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 1)		equals: SColorList yellow.	self		assert: (w var: STurtleVarDef colorVarNo breed: 3 at: 2)		equals: SColorList red.	t := SThread sworld: w.	t forPatchId: 2.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: SColorList black.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 2)		equals: SColorList yellow! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetHeading	| w b t |	w := self newWorld.	w create: 3 turtles: 2.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 5.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 2		put: 5.	b := SteloBytecodeGenerator new.	b setHeading: 15.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self		assert: (w var: STurtleVarDef headingVarNo breed: 3 at: 1)		equals: 15.	self		assert: (w var: STurtleVarDef headingVarNo breed: 3 at: 2)		equals: 5! !!SteloBytecodeGeneratorTest methodsFor: 'tests-patch ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetPatchColorAtTo	| w b t pno |	w := self newWorld.	"	1 2 3	4 5 6	7 8 9"	w createPatch: 3.	w create: 3 turtles: 1.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 1 y: 2.	b setPatchColorAt: pno to: SColorList red.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 3)		equals: SColorList red.	b := SteloBytecodeGenerator new.	b setPatchColorAt: 9 to: SColorList red.	t := SThread sworld: w.	t forPatchId: 2.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 9)		equals: SColorList red.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 1)		equals: SColorList black! !!SteloBytecodeGeneratorTest methodsFor: 'tests-patch ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testSetPatchVarAtTo	| w b vid t pno |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1.	vid := w patches addVariable: 'a'.	self assert: (w patches var: vid at: 2) equals: 0.	self assert: (w patches var: vid at: 5) equals: 0.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 0 y: 0.	b setPatchVar: vid at: pno to: 5.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w patches var: vid at: 2) equals: 0.	self assert: (w patches var: vid at: 5) equals: 5.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 0 y: -1.	b setPatchVar: vid at: pno to: 5.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w patches var: vid at: 2) equals: 5.	self assert: (w patches var: vid at: 5) equals: 5! !!SteloBytecodeGeneratorTest methodsFor: 'tests-variable ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testSetVarTo	| w vid b t |	w := self newWorld.	w create: 3 turtles: 2.	vid := (w breedOf: 3) addVariable: 'a'.	self assert: (w var: vid breed: 3 at: 1) equals: 0.	self assert: (w var: vid breed: 3 at: 2) equals: 0.	b := SteloBytecodeGenerator new.	b setVar: vid to: 10.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w var: vid breed: 3 at: 1) equals: 10.	self assert: (w var: vid breed: 3 at: 2) equals: 0.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetXpos	| w b t |	w := self newWorld.	w create: 3 turtles: 2.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 0.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 2) equals: 0.	b := SteloBytecodeGenerator new.	b setXpos: 3.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 1) equals: 3.	self assert: (w var: STurtleVarDef xVarNo breed: 3 at: 2) equals: 0! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetYpos	| w b t |	w := self newWorld.	w create: 3 turtles: 2.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) equals: 0.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 2) equals: 0.	b := SteloBytecodeGenerator new.	b setYpos: 5.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	t execute: 1.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 1) equals: 0.	self assert: (w var: STurtleVarDef yVarNo breed: 3 at: 2) equals: 5! !!SteloBytecodeGeneratorTest methodsFor: 'tests-color ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testStamp	| w b t |	w := self newWorld.	w createPatch: 3.	w create: 3 turtles: 1.	w		var: STurtleVarDef colorVarNo		breed: 3		at: 1		put: 15.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 5)		equals: 0.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 6)		equals: 0.	b := SteloBytecodeGenerator new.	b stamp.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 5)		equals: 15.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 6)		equals: 0.	w x: 3 at: 1 put: 1.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 5)		equals: 15.	self		assert: (w var: SPatchVarDef colorVarNo breed: 2 at: 6)		equals: 15! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testStopAll	| w b t |	w := self newWorld.	w create: 3 turtles: 1.	b := SteloBytecodeGenerator new.	b stopAll.	b die.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	self assert: t isTerminated.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-control ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testStopThread	| w b t |	w := self newWorld.	w create: 3 turtles: 1.	b := SteloBytecodeGenerator new.	b stopThread.	b die.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	t execute: 1.	self assert: (w flag: STurtleVarDef aliveFlagNo breed: 3 at: 1).	self deny: t isTerminated.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-accessing' stamp: 'EiichiroIto 11/24/2019 20:03'!testSubTable	| b d |	b := SteloBytecodeGenerator new.	self assert: b subTable isNil.	d := Dictionary new.	b subTable: d.	self assert: b subTable equals: d.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testTernaryCommandArg1Arg2Arg3	| b r |	b := SteloBytecodeGenerator new.	self assert: b privStream contents isEmpty.	b ternaryCommand: #abc arg1: 123 arg2: 456 arg3: 789.	self assert: b privStream contents size equals: 4.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 456.	r := b privStream contents third.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 789.	r := b privStream contents fourth.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-arithmetic ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testTruncated	| t b r |	b := SteloBytecodeGenerator new.	r := b truncated: 10.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := SteloBytecodeGenerator new.	r := b truncated: 10.2.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := SteloBytecodeGenerator new.	r := b truncated: 10.5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: 10.	b := SteloBytecodeGenerator new.	r := b truncated: -10.5.	self assert: r isNil.	t := SThread sworld: SMicroWorld new.	t codes: b code.	self assert: (t evaluate: 1) equals: -10.! !!SteloBytecodeGeneratorTest methodsFor: 'tests-turtle  ops' stamp: 'EiichiroIto 11/28/2019 22:09'!testTurn	| w b t |	w := self newWorld.	w create: 3 turtles: 2.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 1		put: 5.	w		var: STurtleVarDef headingVarNo		breed: 3		at: 2		put: 5.	b := SteloBytecodeGenerator new.	b turn: -15.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	t execute: 1.	self		assert: (w var: STurtleVarDef headingVarNo breed: 3 at: 1)		equals: 5.	self		assert: (w var: STurtleVarDef headingVarNo breed: 3 at: 2)		equals: 350! !!SteloBytecodeGeneratorTest methodsFor: 'tests-misc ops' stamp: 'EiichiroIto 11/24/2019 20:03'!testTurtleAt	| w b t pno |	w := self newWorld.	w create: 3 turtles: 3.	w x: 3 at: 3 put: 1.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 0 y: 0.	b turtle: 3 at: pno.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 2.	t := SThread sworld: w.	t forBreedNo: 3 index: 2.	t codes: b code.	self assert: (t evaluate: 1) equals: 1.	b := SteloBytecodeGenerator new.	pno := w patchIndexAtX: 1 y: 0.	b turtle: 3 at: pno.	t := SThread sworld: w.	t forBreedNo: 3 index: 3.	t codes: b code.	self assert: (t evaluate: 1) equals: 0.	t := SThread sworld: w.	t forPatchId: (w patches indexAtPoint: 1 @ 0).	t codes: b code.	self assert: (t evaluate: 1) equals: 3.	b := SteloBytecodeGenerator new.	b turtle: 3 at: pno.	t := SThread sworld: w.	t forBreedNo: 3 index: 1.	t codes: b code.	self assert: (t evaluate: 1) equals: 3.	t := SThread sworld: w.	t forBreedNo: 3 index: 3.	t codes: b code.	self assert: (t evaluate: 1) equals: 0! !!SteloBytecodeGeneratorTest methodsFor: 'tests-private' stamp: 'EiichiroIto 11/24/2019 20:03'!testUnaryCommandArg	| b r |	b := SteloBytecodeGenerator new.	self assert: b privStream contents isEmpty.	b unaryCommand: #abc arg: 123.	self assert: b privStream contents size equals: 2.	r := b privStream contents first.	self assert: r class equals: ScratchBytecodeValue.	self assert: r data equals: 123.	r := b privStream contents second.	self assert: r class equals: ScratchBytecodeSymbol.	self assert: r selector equals: #abc.! !!SteloLibCallTest methodsFor: 'private' stamp: 'EiichiroIto 8/10/2019 18:30'!defaultOrder	^ 6! !!SteloLibCallTest methodsFor: 'private' stamp: 'EiichiroIto 8/10/2019 18:30'!defaultPatchSize	^ self defaultOrder * self defaultOrder! !!SteloLibCallTest methodsFor: 'running' stamp: 'EiichiroIto 8/10/2019 18:36'!setUp	super setUp.	SteloLibCall new reset.! !!SteloLibCallTest methodsFor: 'running' stamp: 'EiichiroIto 8/10/2019 18:36'!tearDown	super tearDown.	SteloLibCall new reset.! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 9/21/2019 12:50'!testAddVariableNameBreedNo	| c x |	c := SteloLibCall new.	x := c addVariable: 10 breed: SBreedId patchBreedNo.	self assert: x.	x := c addVariable: 10 breed: SBreedId patchBreedNo.	self deny: x! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testGetByteBreedId	| c x |	c := SteloLibCall new.	c setupBreed: 3.	c create: 3 turtles: 1.	c		setByte: STurtleVarDef colorVarNo		breed: 3		id: 1		value: 10.	x := c getByte: STurtleVarDef colorVarNo breed: 3 id: 1.	self assert: x equals: 10! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testGetFloatBreedId	| c x |	c := SteloLibCall new.	c createPatch: 10.	x := c getFloat: SObserverVarDef widthVarNo breed: SBreedId observerBreedNo id: 1.	self assert: x equals: 10.! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testGetTypeBreed	| c t |	c := SteloLibCall new.	c setupBreed: SBreedId turtleBreedNo.	t := c getType: STurtleVarDef colorVarNo breed: SBreedId turtleBreedNo.	self assert: t equals: SteloLibCall byte.	t := c getType: STurtleVarDef flagVarNo breed: SBreedId turtleBreedNo.	self assert: t equals: SteloLibCall byte.	t := c getType: STurtleVarDef xVarNo breed: SBreedId turtleBreedNo.	self assert: t equals: SteloLibCall float.	t := c getType: STurtleVarDef yVarNo breed: SBreedId turtleBreedNo.	self assert: t equals: SteloLibCall float.	t := c getType: STurtleVarDef headingVarNo breed: SBreedId turtleBreedNo.	self assert: t equals: SteloLibCall float.	t := c getType: SPatchVarDef colorVarNo breed: SBreedId patchBreedNo.	self assert: t equals: SteloLibCall byte.	t := c getType: SPatchVarDef xVarNo breed: SBreedId patchBreedNo.	self assert: t equals: SteloLibCall computedFloat.	t := c getType: SPatchVarDef yVarNo breed: SBreedId patchBreedNo.	self assert: t equals: SteloLibCall computedFloat.	t := c getType: SPatchVarDef screenVarNo breed: SBreedId patchBreedNo.	self assert: t equals: SteloLibCall byte.! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testGetWordBreedId	| c x |	c := SteloLibCall new.	c setupBreed: 3.	x := c getByte: STurtleVarDef flagVarNo breed: 3 id: 1.	self assert: x equals: 0.	x := c getByte: STurtleVarDef flagVarNo breed: 3 id: 2.	self assert: x equals: 0.	x := c getByte: STurtleVarDef flagVarNo breed: 3 id: 3.	self assert: x equals: 0.	c create: 3 turtles: 2.	x := c getByte: STurtleVarDef flagVarNo breed: 3 id: 1.	self assert: x equals: 1.	x := c getByte: STurtleVarDef flagVarNo breed: 3 id: 2.	self assert: x equals: 1.	x := c getByte: STurtleVarDef flagVarNo breed: 3 id: 3.	self assert: x equals: 0.! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 8/10/2019 18:38'!testIsRunning	| c |	c := SteloLibCall new.	self deny: c isRunning.! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 9/14/2019 18:20'!testPatchIndexAtXY	| c r |	c := SteloLibCall new.	c createPatch: 10.	r := c patchIndexAtX: -5 y: -5.	self assert: r equals: 1.	r := c patchIndexAtX: -4 y: -5.	self assert: r equals: 2.	r := c patchIndexAtX: 4 y: 4.	self assert: r equals: 100.	r := c patchIndexAtX: 0 y: 0.	self assert: r equals: 56.! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetByteAllBreedExtArraySize	| c ext x |	c := SteloLibCall new.	c setupBreed: 3.	c create: 3 turtles: 3.	ext := FFIExternalArray externalNewType: 'byte' size: 3.	ext at: 1 put: 10.	ext at: 2 put: 20.	ext at: 3 put: 30.	[ 	c setByteAll: STurtleVarDef colorVarNo breed: 3 extArray: ext size: 3 ]	ensure: [ ext release ].	x := c getByte: STurtleVarDef colorVarNo breed: 3 id: 1.	self assert: x equals: 10.	x := c getByte: STurtleVarDef colorVarNo breed: 3 id: 2.	self assert: x equals: 20.	x := c getByte: STurtleVarDef colorVarNo breed: 3 id: 3.	self assert: x equals: 30.! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 8/11/2019 08:31'!testSetByteBreedIdValue	self testGetByteBreedId.! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetFloatAllBreedExtArraySize	| c ext x |	c := SteloLibCall new.	c setupBreed: 3.	c create: 3 turtles: 3.	ext := FFIExternalArray externalNewType: 'float' size: 3.	ext at: 1 put: 1.5.	ext at: 2 put: 2.6.	ext at: 3 put: 3.7.	[ 	c setFloatAll: STurtleVarDef xVarNo breed: 3 extArray: ext size: 3 ]	ensure: [ ext release ].	x := c getFloat: STurtleVarDef xVarNo breed: 3 id: 1.	self assert: x closeTo: 1.5.	x := c getFloat: STurtleVarDef xVarNo breed: 3 id: 2.	self assert: x closeTo: 2.6.	x := c getFloat: STurtleVarDef xVarNo breed: 3 id: 3.	self assert: x closeTo: 3.7.! !!SteloLibCallTest methodsFor: 'test' stamp: 'EiichiroIto 11/28/2019 22:09'!testSetFloatBreedIdValue	| c x |	c := SteloLibCall new.	c setupBreed: 3.	c create: 3 turtles: 1.	x := c getFloat: STurtleVarDef xVarNo breed: 3 id: 1.	self assert: x closeTo: 0.	c		setFloat: STurtleVarDef xVarNo		breed: 3		id: 1		value: 1.0.	x := c getFloat: STurtleVarDef xVarNo breed: 3 id: 1.	self assert: x closeTo: 1.	c		setFloat: SObserverVarDef ticksVarNo		breed: SBreedId observerBreedNo		id: 0		value: 120.	x := c		getFloat: SObserverVarDef ticksVarNo		breed: SBreedId observerBreedNo		id: 0.	self assert: x equals: 120.	c		setFloat: SObserverVarDef ticksVarNo		breed: SBreedId observerBreedNo		id: 0		value: 10.	x := c		getFloat: SObserverVarDef ticksVarNo		breed: SBreedId observerBreedNo		id: 0.	self assert: x equals: 10! !!SteloProcessTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 22:23'!testPrivSWorld	| w p |	w := SMicroWorld new.	p := SteloProcess new.	self assert: p privSWorld isNil.	p privSWorld: w.	self assert: p privSWorld equals: w.! !!SteloProcessTest methodsFor: 'tests-private' stamp: 'EiichiroIto 8/8/2019 22:18'!testProgram	| pr p |	pr := SProgram new.	p := SteloProcess new program: pr.	self assert: p program equals: pr.! !!SteloCode class methodsFor: 'accessing' stamp: 'EiichiroIto 9/6/2019 08:37'!addCommand: aSymbol	UsedCommands add: aSymbol.! !!SteloCode class methodsFor: 'accessing' stamp: 'EiichiroIto 9/6/2019 10:04'!clearUsedCommands	"self clearUsedCommands"	UsedCommands := Set new.! !!SteloCode class methodsFor: 'class initialization' stamp: 'EiichiroIto 9/6/2019 08:36'!initialize	self clearUsedCommands.! !!SteloCode class methodsFor: 'accessing' stamp: 'EiichiroIto 9/6/2019 08:36'!usedCommands	^ UsedCommands! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 16:20'!aimHigh: var	^ bcGenerator aimHighVar: (targetMorph patchVarId varNoFor: var choice)! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 16:16'!changePatchVar: var at: pno by: num	bcGenerator		changePatchVar: (targetMorph patchVarId varNoFor: var choice)		at: [ pno argString: parser ]		by: [ num argString: parser ].! !!SteloCode methodsFor: 'variable ops' stamp: 'EiichiroIto 9/6/2019 16:14'!changeVar: var by: num	| v |	v := var choice.	v isEmpty		ifTrue: [ self error ].	bcGenerator		changeVar: [ targetMorph varId varNoFor: v ]		by: [ num argString: parser ].! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 08:00'!changeXposBy: num	bcGenerator changeXposBy: [ num argString: parser ].! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 08:01'!changeYposBy: num	bcGenerator changeYposBy: [ num argString: parser ].! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 07:49'!clearAll	bcGenerator clearAll.! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 07:49'!clearGraphics	bcGenerator clearGraphics.! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/21/2019 15:45'!clearTurtle: bno	bcGenerator clearTurtle: [ bno argString: parser ].! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 07:49'!clearTurtles	bcGenerator clearTurtles.! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:38'!colorBlack	^ self colorOf: #black! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:38'!colorBlue	^ self colorOf: #blue! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:38'!colorBrown	^ self colorOf: #brown! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:38'!colorCyan	^ self colorOf: #cyan! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:38'!colorGray	^ self colorOf: #gray! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:38'!colorGreen	^ self colorOf: #green! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:38'!colorLime	^ self colorOf: #lime! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:38'!colorMagenta	^ self colorOf: #magenta! !!SteloCode methodsFor: 'private' stamp: 'EiichiroIto 3/13/2019 17:10'!colorOf: aSymbol	^ SColorList colorOf: aSymbol! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:39'!colorOrange	^ self colorOf: #orange! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:39'!colorPink	^ self colorOf: #pink! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:39'!colorPurple	^ self colorOf: #purple! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:39'!colorRandom	^ bcGenerator randomFrom: 1 to: SColorList default size - 1! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:39'!colorRed	^ self colorOf: #red! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:39'!colorSky	^ self colorOf: #sky! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:39'!colorTurquoise	^ self colorOf: #turquoise! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:40'!colorWhite	^ self colorOf: #white! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:40'!colorYellow	^ self colorOf: #yellow! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 07:50'!createPatchesSize: size	bcGenerator createPatchesSize: [ size argString: parser ].! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 07:51'!createTurtleSize: size breedId: bno	bcGenerator		createTurtleSize: [ size argString: parser ]		breedId: [ bno argString: parser ].! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 16:16'!diffuse4Var: var percentage: num	bcGenerator		diffuse4Var: (targetMorph patchVarId varNoFor: var choice)		percentage: [ num argString: parser ].! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 16:16'!diffuseVar: var percentage: num	bcGenerator		diffuseVar: (targetMorph patchVarId varNoFor: var choice)		percentage: [ num argString: parser ].! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:09'!directionTo: pno	^ bcGenerator directionTo: (pno argString: parser)! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:09'!distanceTo: pno	^ bcGenerator distanceTo: (pno argString: parser)! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:19'!dx	^ bcGenerator dx! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:19'!dy	^ bcGenerator dy! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 07:58'!forward: num	bcGenerator forward: [ num argString: parser ].! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:27'!front	^ bcGenerator front! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/6/2019 10:40'!getColor	^ bcGenerator getColor! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 11/28/2019 22:09'!getHeading	^ bcGenerator getVar: STurtleVarDef headingVarNo! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 10:12'!getPatchColorAt: pno	^ bcGenerator getPatchColorAt: (pno argString: parser)! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 16:18'!getPatchVar: var at: pno	^ bcGenerator		getPatchVar: (targetMorph patchVarId varNoFor: var choice)		at: [ pno argString: parser ]! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 16:21'!getTurtle: tno breed: bno var: var	^ bcGenerator		getVar: [ :b | targetMorph varFor: var choice breed: b ]		breedNo: [ bno argString: parser ]		index: [ tno argString: parser ]! !!SteloCode methodsFor: 'variable ops' stamp: 'EiichiroIto 9/6/2019 12:16'!getVar: var	| v |	v := var variable.	^ bcGenerator getVar: (targetMorph varId varNoFor: v)! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:06'!getXpos	^ bcGenerator getXpos! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:06'!getYpos	^ bcGenerator getYpos! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 08:03'!hatch	bcGenerator hatch.! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:09'!here	^ bcGenerator here! !!SteloCode methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 20:28'!initialize	super initialize.	parser := ScratchBlockParser codeGenerator: self.	bcGenerator := SteloBytecodeGenerator new.! !!SteloCode methodsFor: 'pen ops' stamp: 'EiichiroIto 9/6/2019 10:16'!isPenDown	^ bcGenerator isPenDown! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 08:10'!kill: tno breed: bno	bcGenerator		kill: [ tno argString: parser ]		breed: [ bno argString: parser ].! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 16:17'!multiplyVar: var by: num	bcGenerator		multiplyVar: (targetMorph patchVarId varNoFor: var choice)		by: [ num argString: parser ]! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 16:19'!nsum4Var: var1 to: var2	bcGenerator		nsum4Var: (targetMorph patchVarId varNoFor: var1 choice)		to: (targetMorph patchVarId varNoFor: var2 choice).! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 16:19'!nsumVar: var1 to: var2	bcGenerator		nsumVar: (targetMorph patchVarId varNoFor: var1 choice)		to: (targetMorph patchVarId varNoFor: var2 choice).! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:03'!patchAtX: x y: y	^ bcGenerator		patchAtX: [ x argString: parser ]		y: [ y argString: parser ]! !!SteloCode methodsFor: 'pen ops' stamp: 'EiichiroIto 9/6/2019 08:03'!penDown	bcGenerator penDown: true.! !!SteloCode methodsFor: 'pen ops' stamp: 'EiichiroIto 9/6/2019 08:03'!penUp	bcGenerator penDown: false.! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/12/2019 13:45'!relativeToR: r theta: theta	^ bcGenerator		relativeToR: [ r argString: parser ]		theta: [ theta argString: parser ]! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:10'!relativeToX: x y: y	^ bcGenerator		relativeToX: [ x argString: parser ]		y: [ y argString: parser ]! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 16:19'!scalePatch: var color: color from: from to: to	bcGenerator		scaleValue: (targetMorph patchVarId varNoFor: var choice)		color: [ color argString: parser ]		from: [ from argString: parser ]		to: [ to argString: parser ]! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/5/2019 22:32'!scaleValue: var color: color from: from to: to	| v |	v := var choice.	v isEmpty		ifTrue: [ ^ self ].	bcGenerator		scaleValue: (targetMorph varId varNoFor: v)		color: [ color argString: parser ]		from: [ from argString: parser ]		to: [ to argString: parser ]! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 11/28/2019 22:09'!screenHeight	^ bcGenerator getObserverVar: SObserverVarDef heightVarNo! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 11/28/2019 22:09'!screenWidth	^ bcGenerator getObserverVar: SObserverVarDef widthVarNo! !!SteloCode methodsFor: 'color ops' stamp: 'EiichiroIto 9/5/2019 22:24'!setColor: color	bcGenerator setColorTo: [ color argString: parser ].! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 07:59'!setHeading: angle	bcGenerator setHeading: [ angle argString: parser ].! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/5/2019 22:28'!setPatchColorAt: pos to: color	bcGenerator		setPatchColorAt: [ pos argString: parser ]		to: [ color argString: parser ]! !!SteloCode methodsFor: 'patch ops' stamp: 'EiichiroIto 9/6/2019 16:20'!setPatchVar: var at: pno to: num	bcGenerator		setPatchVar: (targetMorph patchVarId varNoFor: var choice)		at: [ pno argString: parser ]		to: [ num argString: parser ].! !!SteloCode methodsFor: 'variable ops' stamp: 'EiichiroIto 9/6/2019 16:14'!setVar: var to: num	| v |	v := var choice.	v isEmpty		ifTrue: [ self error ].	bcGenerator		setVar: (targetMorph varId varNoFor: v)		to: [ num argString: parser ].! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 08:01'!setXpos: num	bcGenerator setXpos: [ num argString: parser ].! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 08:02'!setYpos: num	bcGenerator setYpos: [ num argString: parser ].! !!SteloCode methodsFor: 'pen ops' stamp: 'EiichiroIto 9/6/2019 08:04'!stamp	bcGenerator stamp.! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 11/28/2019 22:09'!ticks	^ bcGenerator getObserverVar: SObserverVarDef ticksVarNo! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 9/6/2019 07:58'!turn: angle	bcGenerator turn: [ angle argString: parser ].! !!SteloCode methodsFor: 'sensing ops' stamp: 'EiichiroIto 9/6/2019 10:07'!turtle: bno at: pno	^ bcGenerator		turtle: [ bno argString: parser ]		at: [ pno argString: parser ]! !!SteloCode methodsFor: 'basic ops' stamp: 'EiichiroIto 11/28/2019 22:09'!turtlesCount: bno	^ bcGenerator		getObserverVar: SObserverVarDef countAliveVarNo		arg: (bno argString: parser)! !!SDisplay class methodsFor: 'instance creation' stamp: 'EiichiroIto 8/8/2019 08:01'!sworld: aWorld	^ self basicNew		initialize;		sworld: aWorld;		yourself.! !!SDisplay methodsFor: 'accessing' stamp: 'EiichiroIto 9/4/2018 11:48'!defaultExtent	^ 220 @ 220! !!SDisplay methodsFor: 'drawing' stamp: 'EiichiroIto 9/5/2019 18:18'!drawInfoOn: aCanvas	info ifNil: [ ^ self ].	aCanvas drawString: info at: self topLeft + (5 @ 5) font: nil color: Color white.! !!SDisplay methodsFor: 'drawing' stamp: 'EiichiroIto 9/5/2019 18:05'!drawOn: aCanvas	super drawOn: aCanvas.	sworld ifNil: [ ^ aCanvas frameRectangle: self bounds color: Color red ].	self modelChanged		ifTrue: [ self updateCache ].	self extent < modelExtent		ifTrue: [ ^ self ].	self drawWorldOn: aCanvas.	self drawInfoOn: aCanvas.! !!SDisplay methodsFor: 'drawing' stamp: 'EiichiroIto 8/8/2019 08:01'!drawWorldOn: aCanvas	| x0 x y colors index tc |	colors := sworld colors.	x0 := self left + offset x.	y := self top + offset y + (cell y * (modelExtent y - 1)).	index := 1.	modelExtent y		timesRepeat: [ x := x0.			modelExtent x				timesRepeat: [ tc := SColorList colorAt: (colors at: index).					aCanvas fillRectangle: (x @ y extent: cell) color: tc.					index := index + 1.					x := x + cell x ].			y := y - cell y ].! !!SDisplay methodsFor: 'geometry' stamp: 'EiichiroIto 10/16/2018 21:47'!extent: aPoint	super extent: aPoint.	forceModelChanged := true.! !!SDisplay methodsFor: 'event handling' stamp: 'EiichiroIto 9/15/2018 15:55'!handlesMouseDown: evt	^ true! !!SDisplay methodsFor: 'accessing' stamp: 'EiichiroIto 9/5/2019 18:19'!info: aString	info := aString.! !!SDisplay methodsFor: 'initialization' stamp: 'EiichiroIto 11/24/2019 16:42'!initialize	super initialize.	self extent: self defaultExtent.	self color: Color darkGray.	forceModelChanged := true.	info := ''.	self stepTime: 1000! !!SDisplay methodsFor: 'private' stamp: 'EiichiroIto 8/8/2019 08:01'!modelChanged	^ forceModelChanged or: [ modelExtent ~= sworld extent ]! !!SDisplay methodsFor: 'event handling' stamp: 'EiichiroIto 9/15/2018 17:51'!mouseDown: evt	| pos |	pos := evt cursorPoint - self topLeft.	self send: #clickedAt: at: pos.! !!SDisplay methodsFor: 'event handling' stamp: 'EiichiroIto 9/15/2018 17:51'!mouseMove: evt	| pos |	pos := evt cursorPoint - self topLeft.	self send: #draggedAt: at: pos.! !!SDisplay methodsFor: 'private' stamp: 'EiichiroIto 8/27/2019 16:39'!pointOf: aPoint	| p |	p := (aPoint - offset) // cell - (modelExtent // 2).	^ p x @ p y negated! !!SDisplay methodsFor: 'private' stamp: 'EiichiroIto 10/9/2018 21:00'!privCell	^ cell! !!SDisplay methodsFor: 'private' stamp: 'EiichiroIto 10/9/2018 21:01'!privOffset	^ offset! !!SDisplay methodsFor: 'private' stamp: 'EiichiroIto 8/27/2019 15:49'!send: aSymbol at: aPoint	| pos |	aPoint >= offset		ifFalse: [ ^ self ].	aPoint < (offset + (cell * modelExtent))		ifFalse: [ ^ self ].	pos := self pointOf: aPoint.	(owner notNil and: [ owner respondsTo: aSymbol ])		ifTrue: [ owner perform: aSymbol with: pos ]! !!SDisplay methodsFor: 'stepping and presenter' stamp: 'EiichiroIto 11/24/2019 16:40'!step	stepBlock ifNotNil: [ stepBlock value ]! !!SDisplay methodsFor: 'stepping and presenter' stamp: 'EiichiroIto 11/24/2019 16:41'!stepTime	^ stepTime! !!SDisplay methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 16:41'!stepTime: anInteger	stepTime := anInteger! !!SDisplay methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 08:01'!sworld	^ sworld! !!SDisplay methodsFor: 'accessing' stamp: 'EiichiroIto 8/8/2019 08:01'!sworld: aWorld	sworld := aWorld.! !!SDisplay methodsFor: 'private' stamp: 'EiichiroIto 11/29/2019 23:00'!updateCache	forceModelChanged := false.	modelExtent := sworld extent.	cell := self extent // modelExtent.	cell := 1 @ 1 * cell min.	offset := (self extent - (modelExtent * cell)) // 2! !!SDisplay methodsFor: 'stepping and presenter' stamp: 'EiichiroIto 11/24/2019 16:41'!wantsSteps	^ true! !!SDisplay methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 09:03'!whenStepsDo: aBlock	stepBlock := aBlock! !!SteloProject class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 15:13'!appVersion	^ self appVersionTag, '01'! !!SteloProject class methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 15:13'!appVersionTag	^ 'SteloV'! !!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 16:08'!addNewTurtleScript	| breed script |	breed := self observer newTurtle.	script := self newTurtlesScript		breed: breed;		yourself.	self addScript: script.	^ script! !!SteloProject methodsFor: 'variables' stamp: 'EiichiroIto 11/24/2019 21:56'!addVariable: aString var: vno breed: bno	application addVariable: aString var: vno breed: bno! !!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 21:50'!assureExistsBreed: each	((self scripts collect: #objName) includes: each)		ifFalse: [ self error: each ]! !!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 12:05'!breeds	^ self scripts collect: #breed! !!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/25/2019 21:57'!eventIdFor: aSymbol	^ self application eventIdFor: aSymbol! !!SteloProject methodsFor: 'object i/o' stamp: 'EiichiroIto 11/29/2019 13:29'!fieldsVersion	^ 1! !!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 12:05'!fixVars	self breeds do: #fixVars! !!SteloProject methodsFor: 'object i/o' stamp: 'EiichiroIto 11/29/2019 13:28'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self		initFieldsNamed: #(observerScript patchesScript)		from: anObjStream! !!SteloProject methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 15:19'!newObjStream	^ SteloObjStream new! !!SteloProject methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 15:20'!newProgram	^ SProgram new! !!SteloProject methodsFor: 'private' stamp: 'EiichiroIto 11/24/2019 16:07'!newTurtlesScript	^ TurtlesScript new		project: self;		yourself! !!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 15:59'!observer	^ observerScript breed! !!SteloProject methodsFor: 'argument menus' stamp: 'EiichiroIto 11/25/2019 07:37'!patchVarNamesMenu	^ self patches userDefinedVarNames! !!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 16:00'!patches	^ patchesScript breed! !!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 15:05'!scriptOf: bno	^ scripts detect: [ :each | each breed breedNo = bno ]! !!SteloProject methodsFor: 'private' stamp: 'EiichiroIto 12/5/2019 21:40'!setupScripts	observerScript		ifNil: [ observerScript := ObserverScript new				breed: application newObserver;				project: self;				yourself.			self addScript: observerScript ].	patchesScript		ifNil: [ patchesScript := PatchesScript new				breed: application newPatches;				project: self;				yourself.			self addScript: patchesScript ].	self breeds size < 3		ifTrue: [ self addNewTurtleScript ]! !!SteloProject methodsFor: 'object i/o' stamp: 'EiichiroIto 11/29/2019 13:29'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(observerScript patchesScript) on: anObjStream.! !!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 11/24/2019 21:30'!turtleBreeds	^ self breeds reject: [ :each | each breedNo < SBreedId turtleBreedNo ]! !!SteloProject methodsFor: 'argument menus' stamp: 'EiichiroIto 11/25/2019 12:34'!turtleVarNamesMenu	| list |	list := Set new.	self turtleBreeds		do: [ :each | list addAll: each userDefinedVarNames ].	^ list asSortedCollection asArray! !"Stelo"!----SNAPSHOT----2019-12-10T13:04:19.439477+09:00 Stelo80.image priorSource: 100!!ScratchTranslator class methodsFor: 'Unicode rendering' stamp: 'EiichiroIto 12/10/2019 13:09' prior: 33715167!centerOffsetForButtonWithFont: aStrikeFont	"Answer the vertical offset above the center of a button for the given font. If the translator has provided a render hint string, return an offset that will center the first character of that string. Otherwise, return an offset that will center a lowercase 'x'."	"[self centerOffsetForFont: (StrikeFont fontName: 'VerdanaBold' size: 10)] msecs"	| f r vOffset |	"(RenderCenterOffsetCache includesKey: aStrikeFont) ifTrue: [		^ RenderCenterOffsetCache at: aStrikeFont]."	f := (StringMorph contents: self renderHintString font: aStrikeFont) imageForm.	r := f rectangleEnclosingPixelsNotOfColor: Color transparent.	vOffset := r top + (r height // 2).  "offset of string morph above the centerline of a button to center the given letter"	r height = 0 ifTrue: [vOffset := f height // 2].	RenderCenterOffsetCache at: aStrikeFont put: vOffset.	^ vOffset! !!ScratchTranslator class methodsFor: 'Unicode rendering' stamp: 'EiichiroIto 12/10/2019 13:09' prior: 34555369!centerOffsetForButtonWithFont: aStrikeFont	"Answer the vertical offset above the center of a button for the given font. If the translator has provided a render hint string, return an offset that will center the first character of that string. Otherwise, return an offset that will center a lowercase 'x'."	"[self centerOffsetForFont: (StrikeFont fontName: 'VerdanaBold' size: 10)] msecs"	| f r vOffset |	(RenderCenterOffsetCache includesKey: aStrikeFont) ifTrue: [		^ RenderCenterOffsetCache at: aStrikeFont].	f := (StringMorph contents: self renderHintString font: aStrikeFont) imageForm.	r := f rectangleEnclosingPixelsNotOfColor: Color transparent.	vOffset := r top + (r height // 2).  "offset of string morph above the centerline of a button to center the given letter"	r height = 0 ifTrue: [vOffset := f height // 2].	RenderCenterOffsetCache at: aStrikeFont put: vOffset.	^ vOffset! !!ScratchTranslator class methodsFor: 'as yet unclassified' stamp: 'EiichiroIto 12/10/2019 13:10'!initialize	RenderCenterOffsetCache := Dictionary new! !!ScratchTranslator class methodsFor: 'class initialization' stamp: 'EiichiroIto 12/10/2019 13:10' prior: 34557393!initialize	"ScratchTranslator initialize"	RenderCenterOffsetCache := Dictionary new! !!ScratchTranslator class methodsFor: 'class initialization' stamp: 'EiichiroIto 12/10/2019 13:11' prior: 34557565!initialize	"ScratchTranslator initialize"	RenderCenterOffsetCache := Dictionary new.	RenderVerticalTrimCache := Dictionary new! !----QUIT----2019-12-10T13:13:00.190477+09:00 Stelo80.image priorSource: 1000742!----QUIT/NOSAVE----2019-12-10T13:18:07.733972+09:00 Stelo80.image priorSource: 1003469!!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 12/10/2019 13:36' prior: 33670940!blockColorFor: aCategory	'control' = aCategory		ifTrue: [ ^ Color h: 41 s: 0.85 v: 0.9 ].	'basic' = aCategory		ifTrue: [ ^ Color h: 225 s: 0.65 v: 0.83 ].	'motor' = aCategory		ifTrue: [ ^ Color h: 220 s: 0.85 v: 0.725 ].	'color' = aCategory		ifTrue: [ ^ Color h: 264 s: 0.62 v: 0.89 ].	'pen' = aCategory		ifTrue: [ ^ Color h: 165 s: 1 v: 0.63 ].	'operators' = aCategory		ifTrue: [ ^ Color h: 93 s: 0.9 v: 0.76 ].	'patch' = aCategory		ifTrue: [ ^ Color h: 296 s: 0.66 v: 0.85 ].	'sensing' = aCategory		ifTrue: [ ^ Color h: 200 s: 0.98 v: 0.86 ].	'variables' = aCategory		ifTrue: [ ^ Color h: 25 s: 0.88 v: 0.95 ].	"'list' = aCategory ifTrue: [^ ListBlockColor]."	^ Color h: 0 s: 0.81 v: 0.83! !!ScratchProject methodsFor: 'accessing' stamp: 'EiichiroIto 12/10/2019 13:22'!scriptsForMenu	^ self scripts! !!SpScratchFrame methodsFor: 'private' stamp: 'EiichiroIto 12/10/2019 13:52' prior: 34140129!stageShotSized: size	"Answer a thumbnail of me and my submorphs. Use super fullDrawOn: to avoid drawing the shadows along the top and left edges of the workspace."	| canvas thumbForm bounds display |	display := self display.	bounds := display modelBounds.	canvas := FormCanvas extent: bounds extent depth: 32.	canvas		translateBy: bounds topLeft negated		during: [ :c | display fullDrawOn: c ].	thumbForm := Form extent: size depth: 32.	(WarpBlt toForm: thumbForm)		sourceForm: canvas form;		cellSize: 2;		combinationRule: Form over;		copyQuad: (0 @ 0 extent: canvas extent) innerCorners			toRect: thumbForm boundingBox.	^ thumbForm! !!SpriteArgMorph methodsFor: 'event handling' stamp: 'EiichiroIto 12/10/2019 13:22' prior: 33764675!presentMenu	"Let the user select a Scratch object or the special value #mouse."	| project objList menu choice |	(project := self project) ifNil: [^ self].	"(owner isKindOf: CommandBlockMorph) ifTrue: [sel := owner selector]."	objList := project scriptsForMenu.	objList sort: [:obj1 :obj2 | obj1 objName asLowercase < obj2 objName asLowercase].	menu := MenuMorph new.	menu target: [ :v | choice := v ].	"sel = #getAttribute:of:		ifTrue: [			menu add: ('Stage' localized) selector: #value: argument: frame workPane]		ifFalse: [			menu add: 'mouse-pointer' localized selector: #value: argument: #mouse.			sel = #touching: ifTrue: [menu add: 'edge' localized selector: #value: argument: #edge].			objList := objList copyWithout: owner receiver]."	objList size > 0 ifTrue: [menu addLine].	objList do: [:obj | menu add: obj objName selector: #value: argument: obj].	menu invokeAt: ActiveHand position in: self world.	choice ifNil: [^ self].	morph := choice.	"self fixGetAttribueBlock."	self updateLabel.! !"FromScratch"!!SteloProject methodsFor: 'accessing' stamp: 'EiichiroIto 12/10/2019 13:23'!scriptsForMenu	^ self scripts reject: [ :each | each breedNo < SBreedId turtleBreedNo ]! !!SpStelo methodsFor: 'menu actions' stamp: 'EiichiroIto 12/10/2019 13:40' prior: 34174326!importSexpCode	self import: (ScratchSexpImporter appName: self appName) extension: self sexpExtension! !!SpStelo methodsFor: 'menu actions' stamp: 'EiichiroIto 12/10/2019 13:47'!savePatchImage	| fName saveForm pngExt |	pngExt := 'png'.	saveForm := presenter stageShotSized: 300 @ 300.	saveForm ifNil: [ ^ self ].	fName := (SpFileChooserDialog extension: pngExt)		chooseNewFileDefault: ''		title: 'Save Patches Snapshot'		type: #scriptsSnapshot.	fName ifNil: [ ^ self ].	fName := fName withExtension: pngExt.	saveForm writePNGFileNamed: fName pathString! !!SpStelo methodsFor: 'processes' stamp: 'EiichiroIto 12/10/2019 14:18' prior: 34179306!updateInfo	| msec ticks fps info |	msec := Time millisecondClockValue.	ticks := sworld ticks.	lastMSec		ifNotNil: [ fps := ((ticks - lastTicks) * 1000 / (msec - lastMSec)) truncated.			info := String new writeStream				in: [ :stream | 					stream						nextPutAll: 'ticks=';						nextPutAll: ticks truncated asString;						nextPutAll: ' (';						nextPutAll: fps asString;						nextPutAll: 'fps)';						nextPutAll: ', ';						nextPutAll: (sworld countAliveOf: SBreedId turtleBreedNo) asString;						nextPutAll: ' turtles'.					stream contents ].			presenter info: info ].	lastMSec := msec.	lastTicks := ticks! !!SDisplay methodsFor: 'accessing' stamp: 'EiichiroIto 12/10/2019 13:52'!modelBounds	offset ifNil: [ ^ self bounds ].	^ self topLeft + offset extent: modelExtent * cell! !!SteloScript methodsFor: 'blocks' stamp: 'EiichiroIto 12/10/2019 13:33'!defaultArgsFor: blockSpec	| sel turtles |	sel := (blockSpec at: 3) asSymbol.	turtles := self project scriptsForMenu.	turtles notEmpty		ifTrue: [ (#(turtlesCount: clearTurtle:) includes: sel)				ifTrue: [ ^ Array with: turtles first ].			(#(#createTurtleSize:breedId: #kill:breed:) includes: sel)				ifTrue: [ ^ Array with: 100 with: turtles first ] ].	^ super defaultArgsFor: blockSpec! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 12/10/2019 13:42' prior: 34265497!fileMenu	^ self newMenu		addItem: [ :item | 			item				name: 'New';				action: [ application newProject ] ];		addItem: [ :item | 			item				name: 'Open';				action: [ application openProject ] ];		addItem: [ :item | 			item				name: 'Save';				action: [ application saveProjectNoDialog ] ];		addItem: [ :item | 			item				name: 'Save As';				action: [ application saveProject ] ];		addItem: [ :item | 			item				name: 'Import';				subMenu: self importMenu ];		addItem: [ :item | 			item				name: 'Export';				subMenu: self exportMenu ];		addItem: [ :item | 			item				name: 'Screenshot';				action: [ application savePatchImage ] ];		addItem: [ :item | 			item				name: 'Project Notes';				action: [ application editNotes ] ];		addItem: [ :item | 			item				name: 'Close';				action: [ application close ] ];		addItem: [ :item | 			item				name: 'Quit';				action: [ application quit ] ];		yourself! !!TurtlesScript class methodsFor: 'block specs' stamp: 'EiichiroIto 12/10/2019 13:34' prior: 34292166!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	| blocks |	blocks := #(		'basic'			('forward %n'		- forward: 1)			('turn %n'				- turn: 5)			('heading %n'		- setHeading: 0)			-			('change x by %n'		-	changeXposBy: 1)			('set x to %n'				-	setXpos: 0)			('change y by %n'		-	changeYposBy: 1)			('set y to %n'				-	setYpos: 0)			-			('hatch'					-	hatch)			('die'						- die)		'pen'			('stamp'				- stamp)			('pen up'				- penUp)			('pen down'			- penDown)			('is pen down?'	r isPenDown)		'sensing'			('id'					r	getId)			('x position'		r	getXpos)			('y position'		r	getYpos)			('heading'			r	getHeading)			('dx'					r	dx)			('dy'					r	dy)			('breed id'			r	getBreedId)			-			('one of %m at %n'				r	turtle:at: '' 'where')			('distance to %n'				r	distanceTo: 'where')			('direction to %n'				r	directionTo: 'where')			('aim high %p'			r	aimHigh: '')			-			('%n of %m ''s %t'	r	getTurtle:breed:var:		0 '' '')			-			('here'								r	here)			('front'							r	front)			('x %n y %n from here'	r	relativeToX:y:		0 0)			('r %n theta %n from here'	r	relativeToR:theta:		0 0)		'control'			('when setup'		S	-)		'patch'			('patch color at %n' 			r 	getPatchColorAt: 'where')			('set patch color at %n to %c'			- setPatchColorAt:to: 'where' 15)			-			('patch''s %p at %n'							r 	getPatchVar:at: 	'' 'where')			('set patch''s %p at %n to %n'			-	setPatchVar:at:to: '' 'where' 0)			('change patch''s %p at %n by %n'		-	changePatchVar:at:by: '' 'where' 1)	).	^ blocks, self colorBlocks, self variablesBlocks, super blockSpecs! !"Stelo"!----SNAPSHOT----2019-12-10T14:26:53.099925+09:00 Stelo80.image priorSource: 1003469!----QUIT----2019-12-10T14:33:50.077925+09:00 Stelo80.image priorSource: 1011992!----QUIT/NOSAVE----2019-12-10T15:30:09.2917+09:00 Stelo80.image priorSource: 1012078!!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 12/11/2019 15:53' prior: 33675707!addGenericListBlocksTo: page y: startY	"Add the generic list blocks to the given page starting at the given y offset."	| addButton deleteButton x y |	addButton := ScratchTheme		buttonLabel: 'Make a list' localized		selector: #addList:.	deleteButton := ScratchTheme		buttonLabel: 'Delete a list' localized		selector: #deleteList:.	x := 13.	y := startY + 10.	page		addMorph:			(addButton				target: self project application;				arguments: {self};				position: x @ y).	y := addButton bottom + 3.	self listVarNames isEmpty		ifTrue: [ ^ y ].	page		addMorph:			(deleteButton				target: self;				position: x @ y).	y := deleteButton bottom + 10.	"y := (self addListReportersTo: page x: x y: y) + 10."	(self blocksFor: 'list')		do: [ :blockOrSym | 			blockOrSym = #- | (blockOrSym = #~)				ifTrue: [ "insert a half space"					blockOrSym = #-						ifTrue: [ y := y + 15 ].					blockOrSym = #~						ifTrue: [ y := y + 5 ] ]				ifFalse: [ y := self createBlock: blockOrSym atPosition: x @ y onPage: page.					page submorphs last color: ScratchTheme listBlockColor ] ].	^ y! !!ScratchScript methodsFor: 'testing' stamp: 'EiichiroIto 12/11/2019 15:54'!useList	^ true! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 12/11/2019 15:54' prior: 33693284!variablesPage	| page addButton deleteButton x y maxX |	page := self newBlockPaletteMorph		isForScript: true;		color: (Color r: 0.8 g: 0.8 b: 1.0);		borderWidth: 0.	addButton := ScratchTheme		buttonLabel: 'Make a variable' localized		selector: #addVariable:.	deleteButton := ScratchTheme		buttonLabel: 'Delete a variable' localized		selector: #deleteVariable:.	x := 13.	page		addMorph:			(addButton				target: self project application;				arguments: {self};				position: x @ 7).	y := addButton bottom + 3.	self varNames notEmpty		ifTrue: [ page				addMorph:					(deleteButton						target: self;						position: x @ y).			y := deleteButton bottom + 10.			y := self addVariableReportersTo: page x: x y: y.			y := y + 12.			y := self addGenericVariableBlocksTo: page x: x y: y ].	self useList		ifTrue: [ y := self addGenericListBlocksTo: page y: y ].	maxX := page submorphs inject: 0 into: [ :t :m | t max: m right ].	page extent: (maxX + 10) @ y.	^ page! !!ScratchCode methodsFor: 'control ops' stamp: 'EiichiroIto 12/12/2019 22:01' prior: 33628579!broadcast: msg	| eno |	eno := msg argString: parser.	eno ifNil: [ ^ self ].	bcGenerator broadcast: eno! !!ScratchCode methodsFor: 'private' stamp: 'EiichiroIto 12/12/2019 21:53' prior: 33631624!eventTitleString: aString	aString isEmpty ifTrue: [ ^ nil ].	^ targetMorph project eventIdFor: aString asSymbol! !!SpFileList class methodsFor: 'specs' stamp: 'EiichiroIto 12/12/2019 21:31' prior: 34131275!defaultSpec	^ SpBoxLayout newVertical		spacing: 4;		add:			(SpBoxLayout newHorizontal				spacing: 4;				add: #listHierarchy;				add: #buttonParent withConstraints: [ :constraints | constraints expand: false ];				add: #buttonNew withConstraints: [ :constraints | constraints expand: false ];				yourself)			withConstraints: [ :constraints | constraints expand: false ];		add: #listEntries;		yourself! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 12/12/2019 21:21'!changeParentDirectory	directory isRoot ifTrue: [ ^ self ].	self directory: directory parent! !!SpFileList methodsFor: 'initialization' stamp: 'EiichiroIto 12/12/2019 21:22' prior: 34131760!connectPresenters	listEntries		display: [ :m | self showEntry: m ];		whenActivatedDo: [ :selection | self entriesChanged: selection ].	listHierarchy		whenSelectedItemChangedDo: [ :selection | self currentChanged: selection ].	buttonParent action: [ self changeParentDirectory ].	buttonNew action: [ self newFolder ]! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 12/12/2019 21:26' prior: 34132160!currentChanged: aString	| dir |	listHierarchy selectedIndex = 0		ifTrue: [ ^ self ].	dir := directory.	directory path segments size - listHierarchy selectedIndex		timesRepeat: [ dir := dir parent ].	self directory: dir! !!SpFileList methodsFor: 'accessing' stamp: 'EiichiroIto 12/12/2019 21:28' prior: 34132591!directory: aFileReference	directory := aFileReference.	self listHierarchyContents: self directoryHierarchy.	self listEntriesContents: self getEntries! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 12/12/2019 21:26'!directoryHierarchy	^ directory path segments		withIndexCollect: [ :each :index | (String new: index withAll: Character space) , each ]! !!SpFileList methodsFor: 'initialization' stamp: 'EiichiroIto 12/12/2019 21:25' prior: 34133798!initializePresenters	listHierarchy := self newDropList		startWithoutSelection.	listEntries := self newList		beSingleSelection;		activateOnDoubleClick.	buttonParent := self newButton		icon: (Smalltalk ui icons iconNamed: #up).	buttonNew := self newButton		icon: (Smalltalk ui icons iconNamed: #add).	self directory: FileSystem workingDirectory.	self focusOrder		add: listHierarchy;		add: buttonParent;		add: buttonNew;		add: listEntries! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 12/12/2019 21:30'!listEntriesContents: aCollection	listEntries		unselectAll;		items: #();		items: aCollection! !!SpFileList methodsFor: 'private' stamp: 'EiichiroIto 12/12/2019 21:30'!listHierarchyContents: aCollection	listHierarchy		selectIndex: 0;		items: aCollection;		selectIndex: aCollection size! !!SpFileList methodsFor: 'accessing' stamp: 'EiichiroIto 12/12/2019 21:21' prior: 34135369!selectedFile	| list |	list := listEntries selectedItems.	list isEmpty ifTrue: [ ^ nil ].	^ list first! !!SpFileList methodsFor: 'accessing' stamp: 'EiichiroIto 12/12/2019 21:21' prior: 34135934!whenFileSelectedBlock: aBlock	itemSelectedBlock := aBlock.	itemSelectedBlock		ifNotNil: [ listEntries whenSelectionChangedDo: itemSelectedBlock ]! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 12/11/2019 11:08'!testDocuments	| d |	d := self newDirectory.	self assert: d documents isDirectory! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 12/11/2019 11:04' prior: 33891477!testLastFolderIsSampleProjectsFolder	| d |	d := self newDirectory.	d		setLastFolderTo: FileLocator documents asFileReference		forType: #project.	self deny: d lastFolderIsSampleProjectsFolder.	d setLastFolderTo: d examples forType: #project.	self assert: d lastFolderIsSampleProjectsFolder! !!ScratchDirectoryTest methodsFor: 'test' stamp: 'EiichiroIto 12/11/2019 11:10'!testWindowsDocuments	| d dir |	d := self newDirectory.	dir := d windowsDocuments.	Smalltalk os isWindows		ifTrue: [ self assert: dir isDirectory ]		ifFalse: [ self assert: dir isNil ]! !!VarDef methodsFor: 'accessing' stamp: 'EiichiroIto 12/11/2019 13:50' prior: 33726996!varNoFor: aString	aString isEmpty ifTrue: [ ^ nil ].	(self includes: aString)		ifFalse: [ ^ NotFound signalFor: self ].	^ varNames indexOf: aString! !!SpShortcutButtons methodsFor: 'initialization' stamp: 'EiichiroIto 12/10/2019 15:28' prior: 34145350!connectPresenters	buttonComputer action: [ self setDirectoryType: #computer ].	buttonUser action: [ self setDirectoryType: #user ].	buttonDesktop action: [ self setDirectoryType: #desktop ].	buttonExamples action: [ self setDirectoryType: #examples ].	buttonProjects action: [ self setDirectoryType: #project ]! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 12/11/2019 10:56' prior: 33638980!desktop	^ (self documents parent / 'Desktop') asFileReference! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 12/11/2019 11:10'!documents	Smalltalk os isWindows		ifTrue: [ self windowsDocuments ifNotNil: [ :dir | ^ dir ] ].	^ FileLocator documents asFileReference! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 12/11/2019 09:59' prior: 33640817!projectFor: aString	| dir |	aString ifNil: [ ^ FileSystem workingDirectory ].	dir := self documents / aString.	dir exists		ifFalse: [ dir createDirectory ].	dir isDirectory		ifFalse: [ dir := FileSystem workingDirectory ].	^ dir! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 12/11/2019 10:00' prior: 33641501!user	^ homeDirectory ifNil: [ self documents ]! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 12/11/2019 11:10'!windowsDocuments	| drive path |	drive := Smalltalk os environment at: 'HOMEDRIVE' ifAbsent: [ ^ nil ].	path := Smalltalk os environment at: 'HOMEPATH' ifAbsent: [ ^ nil ].	^ (drive , path) asFileReference! !BlockMorph class removeSelector: #setLabelFont!SpFileList removeSelector: #setParent!SpFileList removeSelector: #refreshList!SpFileList removeSelector: #refreshCurrent!SpFileList removeSelector: #initialize!"FromScratch"!!SBreedVarDef methodsFor: 'as yet unclassified' stamp: 'EiichiroIto 12/11/2019 15:27' prior: 34260811!listNames	^ #()! !!SpStelo class methodsFor: 'accessing' stamp: 'EiichiroIto 12/11/2019 15:15' prior: 34171834!appName	^ 'NovaStelo'! !!SpStelo class methodsFor: 'world menu' stamp: 'EiichiroIto 12/11/2019 15:15' prior: 34172191!menuCommandOn: aBuilder	<worldMenu>	(aBuilder item: #NovaStelo)		order: 0.5;		target: self;		action: [self new open]; 		icon: self icon! !!SteloScript methodsFor: 'testing' stamp: 'EiichiroIto 12/11/2019 15:54'!useList	^ false! !SpStelo removeSelector: #appName!"Stelo"!!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 12/13/2019 15:54' prior: 34173661!clearTurtles	project turtleBreeds do: [ :each | sworld clearBreed: each breedNo ]! !!SpSteloFrame methodsFor: 'accessing' stamp: 'EiichiroIto 12/13/2019 15:59'!updateDisplay	self display changed! !SpSteloFrame removeSelector: #updateDisplay!!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 12/13/2019 16:00' prior: 34173524!clearPatches	sworld clearBreed: project patches breedNo.	presenter updateDisplay! !!SpStelo methodsFor: 'button actions' stamp: 'EiichiroIto 12/13/2019 16:00' prior: 34576300!clearTurtles	project turtleBreeds do: [ :each | sworld clearBreed: each breedNo ].	presenter updateDisplay! !!SpStelo methodsFor: 'menu actions' stamp: 'EiichiroIto 12/13/2019 16:13'!quit	(self confirm: 'Quit Application?' translated)		ifFalse: [ ^ self ].	Smalltalk snapshot: false andQuit: true! !"Stelo"!----SNAPSHOT----2019-12-13T16:13:29.057794+09:00 Stelo80.image priorSource: 1012078!----QUIT/NOSAVE----2019-12-13T16:13:35.889794+09:00 Stelo80.image priorSource: 1022704!----QUIT/NOSAVE----2019-12-13T16:16:54.51997+09:00 Stelo80.image priorSource: 1022704!!EpLostChangesDetector class methodsFor: 'system startup' stamp: 'EiichiroIto 12/13/2019 16:19' prior: 23791209!startUp: isImageStarting	| detector |	(isImageStarting and: [ 		self isEnabled and: [ "Detector can be disabled via system settings"		EpMonitor hasCurrent and: [ "Nothing to recover if wasn't recording"		EpMonitor current isEnabled and: [ 		Smalltalk isHeadless not ]]]])  "Can't browse if UI disabled"			ifFalse: [ ^ self ].	detector := self new.		"SessionManager default addDeferredStartupAction: [		(detector hasLostChanges and: [ self confirm: 'It seems your last Pharo session exited without saving some code. Do you want to recover it?' ])			ifTrue: [ detector openBrowserIfLostChanges ] ]"! !----SNAPSHOT----2019-12-13T16:19:20.191648+09:00 Stelo80.image priorSource: 1022704!----QUIT/NOSAVE----2019-12-13T16:19:24.805648+09:00 Stelo80.image priorSource: 1023695!----QUIT/NOSAVE----2019-12-13T16:19:50.227609+09:00 Stelo80.image priorSource: 1023695!----QUIT/NOSAVE----2019-12-13T16:22:15.567106+09:00 Stelo80.image priorSource: 1023695!!ScratchScript class methodsFor: 'block specs' stamp: 'EiichiroIto 12/14/2019 08:30' prior: 33672079!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	| blocks |	blocks := #(		'control'			('when loop'					L	-)			('when I receive %e'		E	-)			-			('repeat %n'					c	doRepeat 10)			-			('broadcast %e'				-	broadcast:)			('call %S'						-	callSub: '')			-			('if %b'							c	doIf)			('if %b'							c	doIfElse)			('repeat until %b'			c	doUntil)			-			('return %n'					-	return: 0)			('stop script'					-	stopThread)			('stop all'						-	stopAll)		'operators'			('%n + %n'						r	+ - -)			('%n - %n'						r	- - -)			('%n * %n'						r	* - -)			('%n / %n'						r	/ - -)			('- %n'								r	negated: 1)			-			('pick random %n to %n'		r	randomFrom:to: 1 10)			-			('%s < %s'						b	< '' '')			('%s = %s'						b	= '' '')			('%s > %s'						b	> '' '')			('%n between %n and %n'	b is:between:and: 50 0 100)			-			('%b and %b'					b	&)			('%b or %b'						b	|)			('not %b'							b	not:)			-			('%n mod %n'					r	\\ - -)			('round %n'						r	rounded: -)			('truncate %n'					r	truncated: -)			-			('%f of %n'						r	computeFunction:of: 'sqrt' 10)		'sensing'			('return value'				r	returnValue)	).	^ blocks! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 12/14/2019 11:54' prior: 34566771!addGenericListBlocksTo: page y: startY	"Add the generic list blocks to the given page starting at the given y offset."	| addButton deleteButton x y |	addButton := ScratchTheme		buttonLabel: 'Make a list' localized		selector: #addList:.	deleteButton := ScratchTheme		buttonLabel: 'Delete a list' localized		selector: #deleteList:.	x := 13.	y := startY + 10.	page		addMorph:			(addButton				target: self project application;				arguments: {self};				position: x @ y).	y := addButton bottom + 3.	self listVarNames isEmpty		ifTrue: [ ^ y ].	page		addMorph:			(deleteButton				target: self project application;				arguments: {self};				position: x @ y).	y := deleteButton bottom + 10.	"y := (self addListReportersTo: page x: x y: y) + 10."	(self blocksFor: 'list')		do: [ :blockOrSym | 			blockOrSym = #- | (blockOrSym = #~)				ifTrue: [ "insert a half space"					blockOrSym = #-						ifTrue: [ y := y + 15 ].					blockOrSym = #~						ifTrue: [ y := y + 5 ] ]				ifFalse: [ y := self createBlock: blockOrSym atPosition: x @ y onPage: page.					page submorphs last color: ScratchTheme listBlockColor ] ].	^ y! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 12/14/2019 11:40' prior: 33678091!addVariableReportersTo: page x: x y: startY	| y b watcherButton yOffset |	y := startY.	self varNames		do: [ :vName | 			b := VariableBlockMorph new				commandSpec: vName;				receiver: self.			watcherButton := self createToggleButtonFor: b.			yOffset := (b fullBounds height - watcherButton height) // 2.			self useVariableWatcher				ifTrue: [ page addMorph: (watcherButton position: x @ (y + yOffset)) ].			page addMorph: (b position: (x + watcherButton width + 4) @ y).			y := y + b height + 3 ].	^ y! !!ScratchScript methodsFor: 'testing' stamp: 'EiichiroIto 12/14/2019 11:42'!useVariable	^ true! !!ScratchScript methodsFor: 'testing' stamp: 'EiichiroIto 12/14/2019 11:40'!useVariableWatcher	^ true! !!ScratchScript methodsFor: 'blocks' stamp: 'EiichiroIto 12/14/2019 11:47' prior: 34568059!variablesPage	| page addButton deleteButton x y maxX |	page := self newBlockPaletteMorph		isForScript: true;		color: (Color r: 0.8 g: 0.8 b: 1.0);		borderWidth: 0.	self useVariable		ifFalse: [ ^ page ].	addButton := ScratchTheme		buttonLabel: 'Make a variable' localized		selector: #addVariable:.	deleteButton := ScratchTheme		buttonLabel: 'Delete a variable' localized		selector: #deleteVariable:.	x := 13.	page		addMorph:			(addButton				target: self project application;				arguments: {self};				position: x @ 7).	y := addButton bottom + 3.	self varNames notEmpty		ifTrue: [ page				addMorph:					(deleteButton						target: self project application;						arguments: {self};						position: x @ y).			y := deleteButton bottom + 10.			y := self addVariableReportersTo: page x: x y: y.			y := y + 12.			y := self addGenericVariableBlocksTo: page x: x y: y ].	self useList		ifTrue: [ y := self addGenericListBlocksTo: page y: y ].	maxX := page submorphs inject: 0 into: [ :t :m | t max: m right ].	page extent: (maxX + 10) @ y.	^ page! !!SpFileChooserDialog methodsFor: 'accessing' stamp: 'EiichiroIto 12/14/2019 09:38' prior: 34124591!extension: aString	fileInfo extension: aString.	fileList pattern: '*.' , aString! !!SpFileChooserDialog methodsFor: 'initialization' stamp: 'EiichiroIto 12/14/2019 08:57' prior: 34125229!initializeDialogWindow: aDialog	super initializeDialogWindow: aDialog.	aDialog closeOnBackdropClick: false;	askOkToClose: true! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 10:18'!chooseExistingFileType: aSymbol title: aString extension: ext	| dialog d |	dialog := SpFileChooserDialog new.	dialog		extension: ext;		title: aString;		type: aSymbol.	d := dialog openModalWithSpec: #chooseExistingFileSpec.	d isCancelled		ifTrue: [ ^ nil ].	^ dialog selectedFile! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 10:20'!chooseNewFileDefault: filename extension: ext title: aString type: aSymbol	| dialog d |	dialog := SpFileChooserDialog new.	dialog		extension: ext;		filename: filename;		title: aString;		type: aSymbol.	d := dialog openModalWithSpec: #chooseNewFileSpec.	d isCancelled		ifTrue: [ ^ nil ].	^ dialog filename! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 10:15'!confirmFileOverwriteIfExisting: aFileReference orCancel: aBlock	| file response |	file := aFileReference withExtension: self extension.	file isFile		ifFalse: [ ^ file ].	response := UIManager default		confirm: 'The file name already exists. Overwrite existing file?' localized		orCancel: aBlock.	^ response		ifTrue: [ file ]		ifFalse: [ nil ]! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 10:21' prior: 33951946!export: anExporter extension: aString	| fName f str |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	fName := self		chooseNewFileDefault: self projectName		extension: aString		title: 'Export ...'		type: #export.	fName ifNil: [ ^ self ].	fName := fName withExtension: aString.	fName isFile		ifTrue: [ (UIManager default				confirm: 'Overwrite existing ' , fName basename , '?')				ifFalse: [ ^ self ].			fName delete ].	f := nil.	[ f := fName writeStream.	str := anExporter exportFrom: self.	f nextPutAll: str.	f close ]		ifError: [ f ifNotNil: [ f close ].			UIManager default				alert: 'Could not write file' , fName basename				title: 'Export failed' localized ]! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 10:18' prior: 33952872!import: anImporter extension: aString	| response fr f code |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	response := self		chooseExistingFileType: #export		title: 'Import ...'		extension: aString.	response ifNil: [ ^ self ].	fr := response asFileReference.	fr isFile		ifFalse: [ ^ self ].	[ f := fr readStream.	code := f contents.	f close ]		ifError: [ f ifNotNil: [ f close ].			^ UIManager default				alert: 'Could not read file' localized				title: 'Import failed' localized ].	anImporter import: code to: self.	self restoreProject.	presenter updateDisplay! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 12/14/2019 10:11' prior: 33954993!openProject	| response newProj |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	(project notNil and: [ project modified ])		ifTrue: [ response := UIManager default				confirm: 'Save the current project?'				orCancel: [ ^ self ].			response				ifTrue: [ self saveProjectNoDialog ] ].	response := self openScratchFileFor: self createProject.	response ifNil: [ ^ self ].	newProj := self createProject readProjectFrom: response.	newProj ifNil: [ ^ self ].	self projectDirectory: response parent.	self projectName: response base.	self installNewProject: newProj! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 10:11'!openScratchFileFor: aProject	| dialog d |	dialog := SpFileChooserDialog new.	dialog		extension: self extension;		project: aProject;		setupForFileInfoViewer;		title: 'Open Project';		type: #project.	d := dialog openModalWithSpec: #openScratchFileSpec.	d isCancelled		ifTrue: [ ^ nil ].	^ dialog selectedFile! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 12/14/2019 10:16' prior: 33956795!saveProject	| fName result |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	fName := self saveScratchFileFor: project.	fName ifNil: [ ^ self ].	[ (result := self		confirmFileOverwriteIfExisting: fName		orCancel: [ ^ self ]) isNil ]		whileTrue: [ fName := self saveScratchFileFor: project.			fName ifNil: [ ^ self ] ].	project		thumbnailForm: (presenter stageShotSized: self class thumbnailExtent).	(project writeProjectAs: result)		ifFalse: [ ^ self ].	self projectName: result base.	self projectDirectory: result parent! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 12/14/2019 12:02' prior: 33957579!saveProjectNoDialog	| fName dir file |	self closeMediaEditorsAndDialogs		ifFalse: [ ^ self ].	self stopAllProcesses.	fName := self projectName.	dir := ScratchDirectory current getLastFolderForType: #project.	file := dir / (fName , '.' , self extension).	file isFile		ifFalse: [ ^ self saveProject ].	ScratchDirectory current lastFolderIsSampleProjectsFolder		ifTrue: [ self projectDirectory: ScratchDirectory current project.			^ self saveProject ].	project		thumbnailForm: (presenter stageShotSized: self class thumbnailExtent).	(project writeProjectAs: file)		ifFalse: [ ^ self ].	self projectName: file base.	self projectDirectory: file parent! !!SpScratchApp methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 10:53'!saveScratchFileFor: aProject	| dialog |	dialog := SpFileChooserDialog new.	dialog		filename: self projectName;		extension: self extension;		setupForFileInfoEditor;		title: 'Save Project';		type: #project;		author: aProject author;		comment: aProject comment.	[ (dialog openModalWithSpec: #saveScratchFileSpec) isCancelled		ifTrue: [ ^ nil ].	dialog filename isNil ] whileTrue.	aProject		author: dialog author;		comment: dialog comment.	^ dialog filename! !!SpScratchApp methodsFor: 'menu actions' stamp: 'EiichiroIto 12/14/2019 10:22' prior: 33958185!saveScriptsToImage	"Take a snapshot of all scripts for a sprite and save as a GIF file"	| fName saveForm pngExt |	pngExt := 'png'.	saveForm := presenter scriptForm.	saveForm ifNil: [ ^ self ].	fName := self		chooseNewFileDefault: ''		extension: pngExt		title: 'Save Scripts Snapshot'		type: #scriptsSnapshot.	fName ifNil: [ ^ self ].	fName := fName withExtension: pngExt.	saveForm writePNGFileNamed: fName pathString! !!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 12/15/2019 09:56' prior: 34575140!windowsDocuments	| drive path fr |	drive := Smalltalk os environment at: 'HOMEDRIVE' ifAbsent: [ ^ nil ].	path := Smalltalk os environment at: 'HOMEPATH' ifAbsent: [ ^ nil ].	fr := (drive , path) asFileReference.	fr isDirectory ifFalse: [ ^ nil ].	fr := fr / 'Documents'.	fr isDirectory ifFalse: [ ^ nil ].	^ fr! !SpFileChooserDialog removeSelector: #saveScratchFileFor:!SpFileChooserDialog removeSelector: #pattern:!SpFileChooserDialog removeSelector: #openScratchFile!SpFileChooserDialog removeSelector: #confirmFileOverwriteIfExisting:orCancel:!SpFileChooserDialog removeSelector: #chooseNewFileDefault:title:type:!SpFileChooserDialog removeSelector: #chooseExistingFileType:title:!SpFileChooserDialog class removeSelector: #extension:!"FromScratch"!!SteloScript methodsFor: 'testing' stamp: 'EiichiroIto 12/14/2019 11:41'!useVariableWatcher	^ false! !!SpStelo class methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 12:05'!screenshotExtent	^ 400 @ 400! !!SpStelo methodsFor: 'menu actions' stamp: 'EiichiroIto 12/14/2019 12:05'!saveScreenshot	| fName saveForm pngExt |	pngExt := 'png'.	saveForm := presenter stageShotSized: self class screenshotExtent.	saveForm ifNil: [ ^ self ].	fName := self		chooseNewFileDefault: self projectName		extension: pngExt		title: 'Save Patches Snapshot'		type: #scriptsSnapshot.	fName ifNil: [ ^ self ].	fName := fName withExtension: pngExt.	saveForm writePNGFileNamed: fName pathString! !!SDisplay methodsFor: 'drawing' stamp: 'EiichiroIto 12/14/2019 08:41' prior: 34547781!drawInfoOn: aCanvas	info ifNil: [ ^ self ].	aCanvas		drawString: info		at: self topLeft + offset + (5 @ 5)		font: nil		color: Color white! !!SpSteloFrame class methodsFor: 'TOREMOVE' stamp: 'EiichiroIto 12/13/2019 18:48'!buttonWidth	^ (ScratchTheme formAt: #saveButton) width + 10! !!SpSteloFrame class methodsFor: 'specs' stamp: 'EiichiroIto 12/13/2019 21:59' prior: 34264049!defaultSpec	^ SpBoxLayout newVertical		add:			(SpBoxLayout newHorizontal				add: #logo withConstraints: [ :c | c width: 154 ];				add: #buttonOpen withConstraints: [ :c | c width: self buttonWidth ];				add: #buttonSave withConstraints: [ :c | c width: self buttonWidth ];				add: #menu;				yourself)			withConstraints: [ :c | c height: self toolbarHeight ];		add:			(SpBoxLayout newHorizontal				add: #viewerPane					withConstraints: [ :c | c width: self viewerPaneWidth ];				add: #scriptsPane;				add:					(SpBoxLayout newVertical						add: #titlePane withConstraints: [ :c | c height: self titleButtonHeight ];						add: #stageFrame;						add: #libraryPane							withConstraints: [ :c | c height: self libraryPaneHeight ];						yourself);				yourself);		yourself! !!SpSteloFrame methodsFor: 'initialization' stamp: 'EiichiroIto 12/13/2019 22:01' prior: 34264840!connectPresenters	buttonSave action: [ application saveProjectNoDialog ].	buttonOpen action: [ application openProject ].	libraryPane		observerAction: [ self observerSelected ];		patchesAction: [ self patchesSelected ];		turtlesAction: [ :bno | self turtlesSelected: bno ].	self		updateThumbnail! !!SpSteloFrame methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 10:33' prior: 34563178!fileMenu	^ self newMenu		addItem: [ :item | 			item				name: 'New';				action: [ application newProject ] ];		addItem: [ :item | 			item				name: 'Open';				action: [ application openProject ] ];		addItem: [ :item | 			item				name: 'Save';				action: [ application saveProjectNoDialog ] ];		addItem: [ :item | 			item				name: 'Save As';				action: [ application saveProject ] ];		addItem: [ :item | 			item				name: 'Import';				subMenu: self importMenu ];		addItem: [ :item | 			item				name: 'Export';				subMenu: self exportMenu ];		addItem: [ :item | 			item				name: 'Screenshot';				action: [ application saveScreenshot ] ];		addItem: [ :item | 			item				name: 'Project Notes';				action: [ application editNotes ] ];		addItem: [ :item | 			item				name: 'Close';				action: [ application close ] ];		addItem: [ :item | 			item				name: 'Quit';				action: [ application quit ] ];		yourself! !!SpSteloFrame methodsFor: 'initialization' stamp: 'EiichiroIto 12/13/2019 22:00' prior: 34267020!initializePresenters	logo := self newImage.	buttonSave := self newButton.	buttonOpen := self newButton.	menu := self newMenuBar.	viewerPane := self instantiate: SpSteloViewer.	scriptsPane := self instantiate: SpScratchEditor.	titlePane := self instantiate: SpSteloTitle.	stageFrame := self instantiate: SpSteloStage.	libraryPane := self instantiate: SpSteloLibrary.	self setupTopPane.	self setupTitlePane.	self focusOrder		add: scriptsPane! !!SpSteloFrame methodsFor: 'initialization' stamp: 'EiichiroIto 12/13/2019 22:01' prior: 34268312!setupTopPane	logo image: (ScratchTheme formAt: #scratchLogo).	buttonOpen		icon: (ScratchTheme formAt: #openButton);		help: 'Open project'.	buttonSave		icon: (ScratchTheme formAt: #saveButton);		help: 'Save this project'.	menu		addItem: [ :item | 			item				name: 'File';				subMenu: self fileMenu ];		addItem: [ :item | 			item				name: 'Help';				subMenu: self helpMenu ].	menu applyTo: self! !!SpSteloTitle methodsFor: 'private' stamp: 'EiichiroIto 12/14/2019 10:26' prior: 34278938!setupButtons	buttonClearTurtles		icon: (ScratchTheme formAt: #clearTurtlesButtonGray);		help: 'Clear turtles'.	buttonClearPatches		icon: (ScratchTheme formAt: #clearGraphicsButtonGray);		help: 'Clear patches'.	buttonStartSetup		icon: (ScratchTheme formAt: #setupButtonGray);		help: 'Setup'.	buttonStopAll		icon: (ScratchTheme formAt: #stopButtonGray);		help: 'Stop'.	buttonStepLoop		icon: (ScratchTheme formAt: #stepButtonGray);		help: 'Step'.	buttonStartLoopSlow		icon: (ScratchTheme formAt: #loopSlowButtonGray);		help: 'Loop slowly'.	buttonStartLoop		icon: (ScratchTheme formAt: #loopButtonGray);		help: 'Loop'! !!ObserverScript methodsFor: 'testing' stamp: 'EiichiroIto 12/14/2019 11:43'!useVariable	^ false! !SpStelo removeSelector: #savePatchImage!"Stelo"!----QUIT----2019-12-16T09:56:38.993279+09:00 Stelo80.image priorSource: 1023695!!ScratchDirectory methodsFor: 'private' stamp: 'EiichiroIto 12/16/2019 10:04' prior: 34590404!windowsDocuments	| drive path fr |	drive := Smalltalk os environment at: 'HOMEDRIVE' ifAbsent: [ ^ nil ].	path := Smalltalk os environment at: 'HOMEPATH' ifAbsent: [ ^ nil ].	fr := (drive , path) asFileReference.	fr isDirectory ifFalse: [ ^ nil ].	(fr / 'Documents') isDirectory ifFalse: [ ^ fr ].	^ fr / 'Documents'! !"FromScratch"!----QUIT----2019-12-16T10:05:40.351681+09:00 Stelo80.image priorSource: 1042099!